<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[DOM操作方法]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle14%2F</url>
      <content type="text"><![CDATA[1、DOM体验DOM（Document Object Model，文档对象模型）描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。这使得JavaScript操作HTML，不是在操作字符串，而是在操作节点，极大地降低了编程难度。编写例子整体感知一下这个事儿。 1 //获得元素 2 var oDiv = document.getElementById(&quot;box&quot;); 3 var oKaola = document.getElementById(&quot;kaola&quot;); 4 //添加点击事件，盒子变色，图片变图 5 oDiv.onclick = function(){ 6 oDiv.style.backgroundColor = &quot;yellowgreen&quot;; 7 oKaola.src = &quot;images/kaola2.jpeg&quot;; 8 } DOM规范在1998年10月制定，称为“DOM1级规范”。随着ECMAScript的升级，DOM也发展出了2级规范、3级规范。另外，早于1998年的DOM也有事实上的标准，我们称为0级规范。 DOM对很多东西做了抽象，提供了丰富的API：取得元素、css样式、事件、运动、元素尺寸位置、节点操作。每个知识体系都非常庞大，千丝万缕。我们今天的课程，把一些线头都掐出来，日后的课程深入研究每个线头。 2、获取元素JavaScript通过document对象表示文档，它表示整个页面。它有很多属性和方法，包含了绝大多数多页面的特征和操作。学习DOM，说白了就是学习document对象。例如document.title属性，就是页面的标题。 1 document.title = &quot;获取元素&quot;; 2 alert(document.title); DOM操作，往往都是从取得某个（些）HTML元素开始，然后对这个（些）元素进行一些操作。所以得到元素是非常重要的。得到元素的操作可以使用document对象的两个方法来完成： document.getElementById() document.getElementsByTagName() getElementById：get得到 element 元素 by 通过 id id属性值。通过id名字获得某一个元素。 驼峰命名法：一个标识符由多个英文单词组成，首个单词正常小写，从第二个开始每个单词首字符要大写，其他的小写。 JS的书写位置：如果要想获得某一个元素，那么获得之前，元素必须是加载过的。js的书写顺序，需要写在标签后面。 1 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; //标签写在获取元素的前面 2 &lt;script&gt; 3 // document.title = &quot;获取元素&quot;; 4 // alert(document.title); 5 6 //获取div元素 7 var box = document.getElementById(&quot;box&quot;); 8 box.onclick = function(){ 9 box.style.border = &quot;10px solid #0f0&quot;; 10 } 11 &lt;/script&gt; 获取元素语法：直接将获得的这个元素的id属性值写在参数里。名字必须加引号。跟css区别，不需要加#。 错误写法： 1 var box = document.getElementById(&quot;#box&quot;); 正确写法： 1 var box = document.getElementById(&quot;box&quot;); 获得的元素的数据类型。通过检测，得到一个对象类型。 1 console.log(typeof box); 也就是说，我们通过id获得元素本身又是一个对象类型的数据，内部还包含了一些属性和方法。可以对这些元素打点继续调用属性和方法。 注意：id名不能重复。 1 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; 2 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; 3 //id名字不能重复，如果有重复的，只得到第一个 4 var oBox = document.getElementById(&quot;box&quot;); 5 oBox.style.backgroundColor = &quot;#0f0&quot;; id大小写要严格区分，但是在IE6、7中，大小写是不区分的。 IE7及较低版本还有一个怪癖，表单元素name特性也会被当做id。为了避免这个问题，所以页面上的name最好也不要和任何id相同。 3、操作html获取一个html标签之后，得到一个对象类型变量。 可以控制html的属性：得到属性、更改属性。 有两种选择：getAttribute()和setAttribute()方法，或者使用点语法。 点语法： 获得元素属性：直接在元素对象后点语法调用，输出属性值。 1 //获得img标签的src属性 2 console.log(oImg.src); 3 console.log(oImg.id); 4 console.log(oImg.alt); 更改html标签属性：可以通过点语法调用相关属性后，通过等号给这个属性赋值，更改属性值的方法。 1 //通过点语法得到相关属性，等号赋新值 2 oImg.src = &quot;images/kaola2.jpeg&quot;; 3 //不要去更改id属性，id是只读。 第二种方法： 得到属性值getAttribute()，需要得到什么属性，直接将名字写在小括号内。 1 console.log(oImg.getAttribute(&quot;src&quot;)); //得到的就是属性值的字符串 2 console.log(oImg.getAttribute(&quot;alt&quot;)); //得到的就是属性值的字符串 设置属性值setAttribute()，设置属性的新的属性值，直接写在小括号内，用引号包裹。 1 oImg.setAttribute(&quot;src&quot;,&quot;images/kaola.jpg&quot;); 第一个参数：设置属性名，第二个参数：新的属性值，中间用逗号隔开。 区别： ①html标签可以使用自定义属性，自定义属性调用和更改都不能使用点语法实现。getAttribute（）可以获得自定义属性，setAttribute（）可以更改自定义属性。 1 //自定义属性 2 oImg.setAttribute(&quot;kaola&quot;,&quot;yuanxing&quot;); 3 console.log(oImg.kaola); 4 console.log(oImg.getAttribute(&quot;kaola&quot;)); ②点语法调用html属性时，有一些属性名需要进行更改，这些属性名可能是其他的关键字，规避这些名字。getAttribute方法不用规避，直接写原属性名。 class 改为className for 改为htmlFor rowspan 改为rowSpan colspan 改为colSpan 1 //更改一些属性名的写法，只限于点语法 2 console.log(oImg.class); 3 console.log(oImg.className); getAttribute方法不需要改变写法，如果改了反而错。 1 console.log(oImg.getAttribute(&quot;className&quot;)); 2 console.log(oImg.getAttribute(&quot;class&quot;)); ③如果调用style属性得到的还是一个css对象，可以继续打点调用css的样式，遇到复合属性的单一写法，点语法需要些驼峰命名，另外一种方法不需要。 text- font- line- background- border- margin- padding- 1 //console.log(oImg.style.border-color); 2 console.log(oImg.style.borderColor); getAttribute方法直接写css内的命名就行。 ④点语法得到的style属性是一个对象，可以继续打点调用内部的属性。getAttribute方法得到style属性，是一个字符串，不能再继续打点调用。 1 //console.log(oImg.style.border-color); 2 console.log(typeof oImg.style); 3 console.log(typeof oImg.getAttribute(&quot;style&quot;)); 点语法才能继续打点调用css样式属性。 总结：除了自定义属性用getAttribute和setAttribute之外，其他情况都用点语法。 4、操作css通过对一个元素对象打点调用style属性，得到的是css样式的一个对象。可以通过得到css样式的对象，进行css属性的读取和更改。 通过点语法读取和更改的css样式都是行内样式。 1 &lt;img src=&quot;images/kaola.jpg&quot; alt=&quot;这是一只考拉&quot; style=&quot;border:2px solid #f00;&quot; class=&quot;tupian&quot; id=&quot;image&quot; kaola=&quot;bianxing&quot; /&gt; 2 //点语法得到样式都是行内样式，更改的也是行内样式 3 console.log(oImg.style.width); 4 console.log(oImg.style.border); 通过点语法改的css样式属性都是在行内式进行更改的。 1 //更改样式 2 oImg.style.height = &quot;400px&quot;; 语法注意：点语法直接调用。如果给属性赋新值，通过等号赋值，右侧的值必须写在一对儿引号里，css里面怎么写属性值，引号里直接就这么些。 1 oImg.style.height = &quot;400px&quot;; 2 oImg.style.borderColor = &quot;#00f&quot;; innerHTML表示标签内的文本。 input标签有自己的获得方法，点语法直接调用value属性。 1 console.log(oBox.innerHTML); 2 console.log(oTxt.value); 5、事件 DOM0级事件： onclick 单击事件 ondblclick 双击事件 onmouseover 鼠标移上事件 onmouseout 鼠标移出事件 onmousedown 鼠标按下事件 onmouseup 鼠标弹起事件 onfocus 获得焦点事件 onblur 失去焦点事件 onload 加载事件 事件监听：给一个元素去添加事件，如果触发事件就会执行相应的功能。JS在加载的时候，先去整个页面去查看，看谁绑定了事件，引擎就会给这个元素进行监控（监听），监控我们的元素有没有被触发这个事件的动作，如果触发动作，在瞬间执行相应的功能。 语法：给哪个元素绑定事件，就给这个元素对象打点添加对应的事件，用等号给这个事件添加事件函数。 2 box.onmouseover = function(){ 3 事件触发之后要做的事。 4 }; 如果事件被触发，立即执行后面的事件函数，不需要加()调用函数。 6 //获取元素 7 var oImg = document.getElementById(&quot;image&quot;); 8 // 绑定鼠标移上的效果，变图片 9 oImg.onmouseover = function(){ 10 oImg.src = &quot;images/kaola2.jpeg&quot;; 11 }; 调用函数方法：用小括号调用，触发事件执行事件函数。 onclick：单击事件,鼠标单击事件元素触发事件。 5 //鼠标单击事件 6 oImg.onclick = function(){ 7 oImg.style.width = &quot;300px&quot;; 8 }; 4 //鼠标双击事件 5 oImg.ondblclick = function(){ 6 oImg.style.width = &quot;300px&quot;; 7 }; 3 //绑定鼠标移上的效果，变图片 4 oImg.onmouseover = function(){ 5 oImg.src = &quot;images/kaola2.jpeg&quot;; 6 }; 7 //鼠标移出效果，一般与鼠标移上成对出现 8 oImg.onmouseout = function(){ 9 oImg.src = &quot;images/kaola.jpg&quot;; 10 }; 2 //获取元素 3 var oBox = document.getElementById(&quot;box&quot;); 4 //添加鼠标移上和移出事件 5 oBox.onmouseover = function(){ 6 oBox.style.backgroundImage = &quot;url(images/jd2.png)&quot;; 7 }; 8 oBox.onmouseout = function(){ 9 oBox.style.backgroundImage = &quot;url(images/jd1.png)&quot;; 10 }; 5 //添加鼠标按下和弹起事件 6 oBtn.onmousedown = function(){ 7 oBtn.style.backgroundColor = &quot;pink&quot;; 8 }; 9 oBtn.onmouseup = function(){ 10 oBtn.style.backgroundColor = &quot;skyblue&quot;; 11 }; 点击： 松开： 4 //获得焦点事件，输入框清空 5 oTxt.onfocus = function(){ 6 oTxt.value = &quot;&quot;; 7 }; 8 oTxt.onblur = function(){ 9 oImg.src = &quot;images/kaola2.jpeg&quot;; 10 }; onload事件：表示元素加载完之后执行某一个事件函数。 3 //onload加载，图片加载完之后，弹出一句话，加载完了 4 oImg.onload = function(){ 5 alert(&quot;加载完毕&quot;); 6 }; 页面整体加载事件： window.onload:表示页面的所有html标签、css样式都加载完。JS就可以随意书写加载位置。 3 // 只有页面全部加载完了才会触发window.onload 4 window.onload = function(){ 5 //获取元素 6 var oImg = document.getElementById(&quot;image&quot;); 7 var oTxt = document.getElementById(&quot;txt&quot;); 8 //绑定鼠标移上的效果，变图片 9 oImg.onmouseover = function(){ 10 oImg.src = &quot;images/kaola2.jpeg&quot;; 11 }; 12 //鼠标移出效果，一般与鼠标移上成对出现 13 oImg.onmouseout = function(){ 14 oImg.src = &quot;images/kaola.jpg&quot;; 15 }; 16 }； window浏览器对象，alert就是window对象里面的一个方法。window可以省略。 window.alert(&quot;yes&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[延时器setTimeout讲解]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle23%2F</url>
      <content type="text"><![CDATA[1、延时器延时器：setTimeout()。在指定时间之后，执行1次函数。 window方法，可以省略书写。 比喻定时炸弹：在多少时间之后，炸弹爆炸。 1 语法：setTimeout(函数，等待时间); 1 console.log(1); 2 console.log(2); 3 console.log(3); 4 setTimeout(function(){ 5 console.log(&quot;booom shakalaka&quot;); 6 },1000); 7 console.log(4) 使用情况：setTimeout，如果需要在一段时间之后才执行某一个函数。只执行一次。setInterval，如果需要每隔一段时间执行函数一次，反复执行。 2、函数节流函数被调用的时候，最好有一个时间间隔，现在函数不具备这个功能。 事件被频繁触发，事件函数就会频繁调用。 解决方法：函数节流。用一个变量限制函数后面的语句到底能不能走到。定义一个延时器，将变量的限制解开。 1 //给函数上一把锁，锁开的时候，执行函数的语句，锁关上之后，不能执行函数 2 var lock = true ; //表示锁是开的能够执行事件函数 3 btn.onclick = function(){ 4 //如果锁开着可以执行后面的语句，如果关闭，直接return返回，不执行后面的代码 5 if(lock == false){ 6 return; 7 } 8 //给函数上一把锁 9 lock = false; 10 //隔一段时间打开锁 11 setTimeout(function(){ 12 lock = true; 13 },2000); 14 console.log(Math.random()); 15 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[call和apply]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle22%2F</url>
      <content type="text"><![CDATA[call和apply了解普通函数内部有没有this关键，指向是谁。 1 var box = document.getElementById(&quot;box1&quot;); 2 animate(box,{&quot;left&quot;:300},1000,function(){ 3 console.log(this); 4 }); 5 function move(){ 6 console.log(this); 7 } 普通函数（事件函数除外）内部的this默认指向window对象。 call方法和apply方法能够帮我们制定函数内部this的指向。 1 fun.call(obj); 2 fun.apply(obj); obj就是内部this规定的指向元素。 1 //作用：第一个执行函数，第二个指定this。 2 move.call(box); 3 move.apply(box); 两种方法都能用。 区别：就是函数传参的方式不同。 1 fn.call(obj,参数1,参数2,参数3……); 2 fn.apply(obj,[参数1,参数2,参数3……]);3 1 // call方法直接传递 2 sum.call(box,1,2,3); 3 //apply必须将参数放在一个数组 4 sum.apply(box,[2,3,4]); 对封装的函数制定内部的回调函数的this。 1 move(box1); 2 function move(obj){ 3 animate(obj,{&quot;left&quot;:400},1000,function(){ 4 //运动执行完，回调函数内执行的语句 5 this.style.background = &quot;#0f0&quot;; 6 animate(this,{&quot;top&quot;:400},1000,function(){ 7 this.style.background = &quot;#00f&quot;; 8 //在调用运动函数 9 animate(this,{&quot;left&quot;:0},1000,function(){ 10 this.style.background = &quot;#0ff&quot;; 11 //在调用运动函数 12 animate(this,{&quot;top&quot;:100},1000,function(){ 13 this.style.background = &quot;#f00&quot;; 14 move(this); 15 }); 16 }); 17 }); 18 }); 19 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用JS封装简单运动框架方法]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle20%2F</url>
      <content type="text"><![CDATA[封装简单运动框架之前的案例都是单属性变化的运动，如果是多属性的运动，定义多个全局信号量，要有一个合理的时间，同时开始同时结束，需要知道每个属性变动的步长。 两个属性要变动：left从0变到400，width从100变到300，间隔时间50毫秒。 可以随意定义left的步长，可以计算次数，同样可以计算宽度的步长 1 △left = 20； 2 次数 = （400 - 0） / 20 = 20 3 △width = (300 - 100) / 20 = 10 傻瓜版程序：给固定的值进行运动，耦合性太强。 1 //两个属性要变动：left从0变到400，width从100变到300，间隔时间50毫秒。 2 // 全局信号量 3 var nowleft = box.offsetLeft; 4 var nowwidth = box.offsetWidth; 5 var interval = 50; 6 var timer; 7 start.onclick = function(){ 8 timer = setInterval(function(){ 9 //全局信号量变动 10 nowleft += 20; 11 nowwidth += (300 - 100) / ((400 - 0) / 20 ); 12 //判断 13 if(nowleft &gt;= 400){ 14 //同时拉到终点 15 nowleft = 400; 16 nowwidth = 300; 17 clearInterval(timer); 18 } 19 //赋值 20 box.style.left = nowleft + &quot;px&quot;; 21 box.style.width = nowwidth + &quot;px&quot;; 22 },interval); 23 }; 封装一个运动框架： 准备：传入什么数据，实现功能。 运动：运动元素，运动的结束位置以及运动的属性，运动总时间，间隔时间可以在内部定义一个具体值。 多个属性变动结束位置，可以一个JSON对象。 1 var jieshujson = { 2 “width” : 300, 3 “left” : 4004 } 封装一个函数：animate(obj,jieshuJson,time); 1 // 封装运动函数 2 function animate(obj,jieshuJson,time){ 3 //准备三个数据，开始的JSON，结束的JSON，还有步长JSON 4 //开始JSON有多少个属性，由jieshuJson决定 5 //给开始JSON添加新属性，来源于jieshuJson。 6 var kaishiJson = {}; 7 for(var k in jieshuJson){ 8 //通过赋初始值，用到计算后样式，将字符串转数字 9 //结束后的样式名k 10 kaishiJson[k] = parseFloat(getStyle(obj,k)); 11 } 12 //console.log(kaishiJson); 13 //步长JSON = （jieshuJson - kaishiJson） / 总次数 14 //总次数 = 总时间 / 间隔时间 15 var interval = 50; 16 var zongcishu = time / interval; 17 //获得步长JSON 18 var buchangJson = {}; 19 for(var k in jieshuJson){ 20 //避免输入的是字符串，先转数字 21 jieshuJson[k] = parseFloat(jieshuJson[k]); 22 buchangJson[k] = (jieshuJson[k] - kaishiJson[k]) / zongcishu; 23 } 24 // console.log(buchangJson); 25 //============三个JSON都准备完了=============== 26 //程序部分 27 //全局信号量接收初始值，每次的步长 28 //定义信号量JSON 29 var xinhaoliangJson = {}; 30 for(var k in kaishiJson){ 31 xinhaoliangJson[k] = kaishiJson[k]; 32 } 33 //执行次数等于总次数，停止运动 34 //累加器 35 var cishu = 0; 36 var timer ; 37 timer = setInterval(function(){ 38 //每执行一次，次数增加 39 cishu++; 40 //信号量JSON每次加一个步长 41 for(var k in xinhaoliangJson){ 42 xinhaoliangJson[k] += buchangJson[k]; 43 } 44 //验收，停止定时器 45 if(cishu &gt;= zongcishu){ 46 //拉终停表 47 for(var k in xinhaoliangJson){ 48 xinhaoliangJson[k] = jieshuJson[k]; 49 } 50 clearInterval(timer); 51 } 52 //赋值,如果是透明度属性，需要单独设置 53 for(var k in xinhaoliangJson){ 54 if(k == &quot;opacity&quot;){ 55 obj.style.opacity = xinhaoliangJson[k]; 56 obj.style.filter = &quot;alpha(opacity=&quot; + xinhaoliangJson[k] * 100 +&quot;)&quot;; 57 }else{ 58 obj.style[k] = xinhaoliangJson[k] + &quot;px&quot;; 59 } 60 } 61 },interval); 62 } 1、js书写的位置将自己封装的函数全部拿到一个单独的js文件内，如果需要这个js，就直接调用。 在html页面内用一对script来调用。 src属性：查找js文件的路径，绝对路径、相对路径。 注意：引入一个外部js的过程，可以叫做引包。这一对标签内部不能再写js代码。 如果想使用这个js的内容，另起一个script标签。 引包过程必须是写在使用代码之前。 1 &lt;!-- 调用外部js --&gt; 2 &lt;script src=&quot;iqianduan.js&quot;&gt;&lt;/script&gt; 3 &lt;!-- 使用js库内的方法需要另写一个script --&gt; 4 &lt;script&gt; 5 var box = document.getElementById(&quot;box&quot;); 6 var start = document.getElementsByTagName(&quot;input&quot;)[0]; 7 animate(box,{&quot;width&quot;:400,&quot;left&quot;:500,&quot;height&quot;:400,&quot;opacity&quot;:1},2000); 8 &lt;/script&gt; 好处：多个文件可以共用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[异步和回调函数]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle21%2F</url>
      <content type="text"><![CDATA[1、异步异步（Asynchronous），是计算机多线程的异步处理。与同步处理相对，异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。 js如果没有特殊语句：都是单线程，必须等到前面语句执行完之后，才能执行下面的语句。 同步： 1 console.log(1); 2 console.log(2); 3 console.log(3); 4 console.log(4); 5 //for循环，必须跳出循环才能走后面的语句 6 for(var i = 0 ; i &lt;= 100000 ; i++){ 7 console.log(1); 8 } 9 //后面的语句必须等到前面执行完才嫩执行，否则，只能排队等待。 10 console.log(5); 同步：工作中，完成一个demo，拿给项目经理去看，你就在旁边站着等，经理看完之后，告诉你这个可以了，继续下一个工作。 异步：工作中，完成一个demo，拿给项目经理去看，在经理看的过程，你回工位做下一个demo，经理同时也在检查你的原demo，他做完了之后告诉你，你这个可以了，继续工作。 如果要做异步：必须有异步语句的参与，setInterval、setTimeout、Ajax、node.js。 1 //定时器做异步 2 console.log(1); 3 console.log(2); 4 console.log(3); 5 console.log(4); 6 setInterval(function(){ 7 console.log(1); 8 },30) 9 console.log(5); 2、回调函数回调函数：定时器走完，可以利用一个回调函数告诉我的程序，某一个线程走完了，可以做什么工作了。 1 var timer; 2 var sum = 0; 3 timer = setInterval(function(){ 4 sum++; 5 console.log(1); 6 if(sum == 100){ 7 //清除定时器 8 clearInterval(timer); 9 //可以告诉程序下一步做什么 10 //回调函数，告诉我们定时器结束之后要做的工作 11 end(); 12 } 13 },30); 14 function end(){ 15 alert(&quot;定时器走完了&quot;); 16 } 一般有一个固定的写法：将结束后的回调函数作为一个参数。每次执行可以传递函数参数。 1 function yundong(callback){ 2 var timer; 3 var sum = 0; 4 timer = setInterval(function(){ 5 sum++; 6 console.log(1); 7 if(sum == 100){ 8 //清除定时器 9 clearInterval(timer); 10 //可以告诉程序下一步做什么 11 //回调函数，告诉我们定时器结束之后要做的工作 12 callback(); //必须写函数的调用 13 } 14 },30); 15 } 某一段代码结束后，继续执行的下一个内容。 1 animate(box1,{&quot;left&quot;:400},1000,function(){ 2 //运动执行完，回调函数内执行的语句 3 box1.style.background = &quot;#0f0&quot;; 4 animate(box1,{&quot;top&quot;:400},800,function(){ 5 box1.style.background = &quot;#00f&quot;; 6 }); 7 });]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON对象使用方法]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle19%2F</url>
      <content type="text"><![CDATA[概述 数组：存储的是一组数据，可以操作每一项内容，有自己的局限性，通过具体下标才能获得某一项。 数据多的时候，数组的使用效率变低。 JSON对象可以解决这个问题。也可以存多个数据，每个数据都有自己的名字。可以通过数据的名字得到数据的值。 JSON叫做JavaScript Object Notation， JavaScript对象表示法。 JSON对象创建的最简单的方式，就是字面量，一对大括号{}。 语法：{}内部包括多个数据，每个数据之间用逗号隔开，最后一个数据后不能写逗号。每一项数据都包含属性名和属性值，属性名必须用引号包括，属性值根据数据类型单独设置，键值对写法”k”:v。 1 语法：{“k”: v, “k”: v} 创建一个最简单的JSON对象。 1 var json = { 2 &quot;name&quot; : &quot;kaola&quot;, 3 &quot;age&quot; : 18, 4 &quot;sex&quot; : &quot;男&quot;, 5 &quot;tall&quot; : 100, 6 &quot;weight&quot; : 178 7 }; 8 console.log(typeof json); 数据类型：对象型。引用类型数据，变量存的是地址。 调用每一项数据的方法：JSON对象点语法调用属性名即可，或者用[属性名]。 1 //调用 2 console.log(json.name); 3 console.log(json.age); 4 console.log(json.sex); 5 console.log(json.tall); 6 console.log(json[&quot;weight&quot;]); JSON对象内部还能嵌套JSON对象。 1 var json = { 2 &quot;name&quot; : &quot;kaola&quot;, 3 &quot;age&quot; : 18, 4 &quot;sex&quot; : &quot;男&quot;, 5 &quot;tall&quot; : 100, 6 &quot;weight&quot; : 178, 7 &quot;couple&quot; : { 8 &quot;name&quot; : &quot;daishu&quot;, 9 &quot;age&quot; : 17, 10 &quot;sex&quot; : &quot;女&quot;, 11 &quot;tall&quot; : 160, 12 &quot;weight&quot; : 90 13 } 14 }; 如果想调用内部JSON的属性，继续打点调用即可。 1 console.log(json.couple.tall); 修改某一个属性：给调用的属性名去直接赋值。 1 json.tall = 170; 2 console.log(json); 删除：用到一个delete关键字，后面必须加空格，书写他的属性。 1 //删除 2 delete json.couple; 3 console.log(json); 添加：直接给JSON对象打点添加属性，属性值同时赋值。 1 //添加 2 json.hobby = &quot;台球&quot;; 3 console.log(json); 2、JSON的遍历for……in语法：通过属性名去遍历所有属性，从前到后依次去遍历，直到最后一个数据被遍历完。循环结束。 1 for(var k in json){ 2 语句3 } k：表示属性名 json：你要遍历的那个JSON对象。输出每一个属性值： 1 //输出每一个属性值，需要遍历JSON对象 2 for(var k in json){ 3 console.log(json[k]); 4 } 复制一个JSON对象： 属性名都一样，属性值也一样。 过程：新的JSON对象接收复制来的数据。给新对象添加新属性，新属性等于原对象属性，再给新属性赋值，值等于原对象属性的值。 1 var newJson = {}; //必须是空的JSON对象 2 for(var k in json){ 3 //定义新属性并赋值 4 newJson[k] = json[k]; //红色是添加属性，绿色是调用原JSON的属性值 5 } 6 //循环完之后得到一个新的JSON 7 console.log(newJson);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[setInterval定时器]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle18%2F</url>
      <content type="text"><![CDATA[1、概念window给我们提供的一个方法，setInterval定时器。 1 window.setInterval(函数,间隔时间); 1 //获得div标签 2 var box = document.getElementsByTagName(&quot;div&quot;)[0]; 3 //全局变量累加 4 var nowleft = 0; 5 window.setInterval(function(){ 6 //每次执行函数都让nowleft递加 7 nowleft += 20; 8 //赋值给left属性值 9 box.style.left = nowleft + &quot;px&quot;; 10 },100) 定时器执行的功能由第一个参数，函数来决定： 1 window.setInterval(function(){ 2 console.log(1); 3 },100); 第一个参数可以是一个匿名函数，也可以是一个函数的函数名。 1 window.setInterval(shuchu,100); 2 function shuchu(){ 3 console.log(1);4 } 第二种方法是工作中常用的。 定时器第二个参数：间隔时间。单位：毫秒，1000毫秒等于1秒。规定的是我们函数执行间隔。 1 window.setInterval(function(){ 2 //每次执行函数都让nowleft递加 3 nowleft += 20; 4 //赋值给left属性值 5 box.style.left = nowleft + &quot;px&quot;; 6 },10); 时间间隔可以决定运动的速度。间隔时间越短，函数在一秒钟内执行的次数越多，变量变动的越快。 运动内：时间越短，速度越快。 定时器的启动是不需要其他条件，只要遇到setInterval语句就会立即开启一个定时器。 常用的形式：会省略window对象。 1 setInterval(move,50); 2、简单运动原理：利用定时器，每个多长时间，走多少步。 不需要知道要走多远，只要知道每隔多长时间走多长。 视觉暂留：视觉残留。人的视觉有一个残留时间０.１秒－０.４秒。 1 //定义定时器，让宽度每隔100毫秒变宽一点 2 setInterval(move,100); 3 function move(){ 4 now += 10; 5 //给元素宽度赋值 6 box.style.width = now + &quot;px&quot;; 7 } 间隔时间在一秒钟内让函数执行几次，次数可以叫做帧频，frame percent second，每秒执行几帧，简称fps。一个运动的帧频是24fps，指的是一秒钟动24次。 控制运动速度：帧频越大，1秒运动的次数越多。间隔时间变短，帧频变大。 第一种方法：缩短间隔时间。 1 setInterval(move,20); 第二种方法：增大步长。 1 now += 30; 3、清除定时器clearInterval又叫停止定时器。 clearInterval：清空一个定时器的作用。 方法：将定时器setInterval给一个变量，要停止的时候，将变量传给clearInterval的参数。 1 var timer; 2 start.onclick = function(){ 3 timer = setInterval(move,100); 4 }; 5 end.onclick = function(){ 6 //关闭定时器 7 clearInterval(timer); 8 }; 4、存在的问题第一个问题： 如果多次点击一个运动开始的按钮，会开启多个定时器，在一个时间内有多个定时器都在隔一段时间执行函数。造成一个现象，运动的变量每一个间隔时间变动的值是多个定时器累加的效果。运动速度回越来越快。 防骚扰操作：每开启一个定时器之前，先停止一次定时器。设表先关。 1 var timer; 2 start.onclick = function(){ 3 //设表先关 4 clearInterval(timer); 5 timer = setInterval(move,100); 6 }; 7 end.onclick = function(){ 8 //关闭定时器 9 clearInterval(timer); 10 }; 第二个问题： 有时需要元素停在一个固定位置，如果步长给的不合理，不会正好停在这个位置，有误差。解决方法：先将变量判断，if语句的后验收，如果大于终点值，强制给变量赋值，再停止定时器。拉终停表。 1 start.onclick = function(){ 2 timer = setInterval(function(){ 3 //设置步长 4 now += 13; 5 // 给元素属性赋值 6 //后验收 7 if(now &gt; 500){ 8 //拉回到终点，然后停止定时器 9 now = 500; 10 clearInterval(timer); 11 } 12 box.style.left = now + &quot;px&quot;; 13 console.log(now); 14 15 }, 50);16 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取尺寸和位置的方法]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle17%2F</url>
      <content type="text"><![CDATA[前面封装的函数得到的值都是字符串，使用的时候，一部分需要转成数字取计算。JS提供了几个常用的快捷尺寸，得到的就是数字类型的数据。 offsetLeft offsetTop offsetWidth offsetHeight clientWidth clientHeight 1、offsetLeft和offsetTop严重的兼容性问题。以offsetLeft为例。offset具有偏移量的含义。元素天生具有一个属性，认识一个叫做offsetParent的元素，偏移参考元素。 调用方法：打点调用offsetLeft。 兼容IE9以上及高级浏览器 1 &lt;div class=&quot;box1&quot;&gt; 2 &lt;div class=&quot;box2&quot;&gt; 3 &lt;div class=&quot;box3&quot;&gt; 4 &lt;p&gt;&lt;/p&gt; //本身不管有没有定位，祖先元素都没有定位，偏移参考元素就是body 5 &lt;/div&gt; 6 &lt;/div&gt; 7 &lt;/div&gt; 8 &lt;div class=&quot;box1&quot;&gt;//有定位 9 &lt;div class=&quot;box2&quot;&gt; //有定位 距离p元素最近且有定位，是offsetParent 10 &lt;div class=&quot;box3&quot;&gt; //无定位 11 &lt;p&gt;&lt;/p&gt; //本身不管有没有定位，祖先元素有定位，偏移参考元素就是距离最近的box2 12 &lt;/div&gt; 13 &lt;/div&gt; 1 &lt;/div&gt; offsetParent：不管元素自身有没有定位，如果祖先元素有定位，偏移参考元素就是距离该元素最近的有定位的祖先元素。如果祖先元素都没有定位，偏移参考元素变成body。 offsetLeft：就是自身元素的左边框外到offsetParent的左边框内部的距离。 offsetTop与offsetLeft一样：自身元素的上边框外到offsetParent的上边框内部的距离。 IE6/7浏览器： 区分两种情况，元素自身有没有定位： 第一种：元素自身没有定位。 offsetParent：距离最近的有宽高的祖先元素，如果都没有宽高，参考body。 offsetLeft：与高级浏览器一样，元素左边框外到offsetParent的左边框内部的距离。 1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[getComputedStyle使用方法]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle16%2F</url>
      <content type="text"><![CDATA[计算后样式点语法不能得到计算后样式，只能得到和更改行内样式。计算后样式：其实是多个选择器叠加的最终样式。 1、高级浏览器1 var box = document.getElementById(&quot;box&quot;); 2 console.log(box.style.width); W3C制定的标准API，所有现代浏览器（包括IE9，但不包括之前的版本）都window.getComputedStyle()，该方法接收一个要进行样式计算的元素，并返回一个可以进行属性查询的接口。返回接口提供了一个名为getPropertyValue()的方法，用于检索特定样式属性的计算样式。getPropertyValue方法接收css属性名称，而不是驼峰式的名称。getPropertyValue()可以不写，直接用方括号来检索属性也可以。 兼容问题：在高级浏览器和IE9以上才能使用。 window.getComputedStyle：window指的是浏览器对象，可以省略window。内部有一个获得计算后样式的方法。 传入一个元素对象，返回时这个元素的所有计算后样式。直接写在参数位置，不需要加引号，因为我是传的是元素对象的变量。 1 console.log(window.getComputedStyle(box)); 进一步可以打点调用getPropertyValue：获得属性值。 第一种方法：小括号内的参数直接写css属性名，直接在小括号内的引号内书写，必须写css内的名字格式，不能用驼峰。 1 //var a = window.getComputedStyle(box).getPropertyValue(&quot;width&quot;); 2 var a = window.getComputedStyle(box).getPropertyValue(&quot;backgroundColor&quot;); 必须使用css的写法。 第二种方法：不用小括号调用，用中括号调用，将属性名写在中括号内部。不需要getPropertyValue。属性名必须用引号包裹。这种方法可以用驼峰命名法。 1 var a = window.getComputedStyle(box)[&quot;width&quot;]; 复合属性既能用css写法，也能用驼峰。 1 var a = window.getComputedStyle(box)[&quot;backgroundColor&quot;]; 2、低版本浏览器IE6/7/8IE9之前的版本提供了一个专有API访问计算后样式：附加在元素身上的currentStyle属性，它表现和style点语法一样，使用驼峰式访问。 使用方法与点语法调用style一模一样。点语法继续调用属性。 1 //低版本浏览器 2 var a = box.currentStyle.width; 1 //var b = box.currentStyle.backgroundColor; 3 4 box.innerHTML = a; 也可以用中括号的方式调用：只能用驼峰，不能用css写法。 2 var a = box.currentStyle[&quot;width&quot;]; 3 var b = box.currentStyle[&quot;background-color&quot;]; 3、兼容写法 ## 不是去测试浏览器版本，检测浏览器能力。如果浏览器具备调用某一个方法的能力，就使用。 能力检测：将方法作为判断条件。 1 var box = document.getElementById(&quot;box&quot;); 2 //通过能力检测写兼容 3 if(window.getComputedStyle){ 4 //高级浏览器 5 var a = window.getComputedStyle(box)[&quot;background-color&quot;]; 6 }else if(box.currentStyle){ 7 var a = box.currentStyle[&quot;backgroundColor&quot;] 8 } 9 box.innerHTML = a; 去封装一个函数，输入一个属性名，输出一个兼容后的属性值。 1 //封装一个函数，兼容高级浏览器和低版本浏览器 2 function fetchComputedStyle(ele,property){ 3 //判断是高级浏览器还是低版本 4 //能力测试判断 5 if(window.getComputedStyle){ 6 //针对用户输入的属性名进行兼容写法，不管是不是驼峰，都改成横线写法 7 property = property.replace(/([A-Z])/g,function(match,$1){ 8 return &quot;-&quot; + $1.toLowerCase(); 9 }); 10 return window.getComputedStyle(ele)[property]; 11 }else if(ele.currentStyle){ 12 //针对用户输入的属性名进行兼容写法，不管是不是驼峰，都改成驼峰 13 property = property.replace(/\-([a-z])/gi,function(match,$1){ 14 return $1.toUpperCase(); 15 }); 16 return ele.currentStyle[property]; 17 } 18 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符串属性和方法]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle11%2F</url>
      <content type="text"><![CDATA[1、length属性length 属性可返回字符串中的字符数目。 49 //数组可以存一组数据 50 var str = &quot;今天要多讲一会儿了hahaha，你能怎 样？&quot;; 51 console.log(str.length); 2、方法charAt() 方法可返回指定位置的字符。 index:字符索引值，从0开始。 36 语法：str.charAt(index); 52 var str = &quot;今天要多讲一会儿了hahaha，你能怎 样？&quot;; 53 console.log(str.charAt(3)); concat() 方法用于连接两个或多个字符串。原字符串不会被改变。 37 //concat() 方法用于连接两个或多个字符串。 38 var str2 = str.concat(&quot;不怎么样啊&quot;); 39 console.log(str); 40 console.log(str2); indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。得到的结果是字符串的索引值。 注意：区分字母大小写。如果找不到对应的字符，返回-1. 54 //indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 55 console.log(str.indexOf(&quot;多讲&quot;)); lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 注意：输出的还是索引值，它是从后面找第一次出现的位置。 41 console.log(str.indexOf(&quot;a&quot;)); 42 console.log(str.lastIndexOf(&quot;a&quot;)); slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。生成新的字符串，对原字符串没影响。 56 //slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。 57 var str2 = str.slice(4,8); 58 console.log(str); 59 console.log(str2); split() 方法用于把一个字符串分割成字符串数组。参数：分隔符。 43 var str2 = &quot;lsdfowekfsdfowekdowfefsfwepp&quot;; 44 var arr = str2.split(&quot;f&quot;); 45 console.log(str2); 46 console.log(arr); toLowerCase() 方法用于把字符串转换为小写。 toUpperCase() 方法用于把字符串转换为大写。 60 var str4 = str3.toUpperCase(); 61 var str5 = str4.toLowerCase(); 62 console.log(str3); 63 console.log(str4); 64 console.log(str5); substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。 start：开始的索引值。可以为正、可以为负。 length：截取的字符串数量。可以写可以不写，不写截取到字符串结尾。 47 var str4 = str3.substr(5,6); 48 console.log(str3); 49 console.log(str4); substring() 方法用于提取字符串中介于两个指定下标之间的字符。 substring() 方法返回的子串包括 start 处的字符，但不包括 end 处的字符。与slice一样。 不一样：substring参数不能为负。两个参数位置可以互换，第一个参数字符位置可以在第二个参数位置之后。 如果 start 比 end 大，那么该方法在提取子串之前会先交换这两个参数。end参数可以不写。 29 //substring() 方法用于提取字符串中介于两个指定下标之间的字符。 30 var str4 = str3.substring(4,9); 31 var str5 = str3.substring(9,4); 32 console.log(str3); 33 console.log(str4); 34 console.log(str5);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则的术语和操作符]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle12%2F</url>
      <content type="text"><![CDATA[由一些普通字符和一些特殊字符（又叫元字符–metacharacters）组成。普通字符包括大小写的字母和数字，而元字符则具有特殊的含义。 特殊字符： （） [ ] { } \ ^ $ | ? * + . 就想匹配特殊字符，将特殊字符进行转义。用到转义符号\。 ( [ . 1、精确匹配精确匹配指的是我们要去匹配某一个固定值或者常量，匹配abc，正则表达式里必须用精确的术语进行匹配。 正则表达式：/abc/,表示我们要匹配的是三个字符，分别是a，b，c，必须是顺序在一起，顺序不能颠倒。 2、预定义特殊字符：\t /\t/ 制表符 eg: console.log(/\t/.test(&apos; &apos;)) \n /\n 回车符 eg: console.log(/\n/.test(`aaa bbb`)); \f /\f/ 换页符 \b /\b/ 空格 3、字符集用正则表达式中的一类字符去配字符串中的一个字符。字符集用[]包括。 比如[abc]，表示可以匹配a，也可以匹配b，也可以匹配c，只要存在其中任意一个都是对的。 简单类:正则的多个字符对应一个字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符。将所有可能性都列在[]内，不要任何其他字符，直接连写 范围类:有时匹配的东西过多，而且类型又相同，全部输入太麻烦，我们可以在中间加了个横线。[a-z]、[0-9]、[A-Z] 组合类:允许用中括号匹配不同类型的单个字符[0-9a-b]只要数字和小写字母：[0-9a-z] 负向类:[]前面加个元字符(^)进行取反，表示匹配不能为括号里面的字符。[^a] 4、修饰符g 修饰符用于执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 match、replace这两种方法可以使用。 i 修饰符用于执行对大小写不敏感的匹配。 注意：修饰符书写位置，都是在//写完之后，紧跟在后面。修饰符可以同时使用，连写就可以。 5、边界^ 开头 注意不能紧跟于左中括号的后面 界定的是我们的字符串必须以什么为开头。^后面的正则术语匹配的字符串就必须是开头。 $ 结尾 界定的是必须以$前面的字符为结尾，$写在正则的最后。 ^和$可以同时使用，必须以他们中间的内容当做开头和结尾，字符串只能有中间的内容。 \b 单词边界，用于查找位于单词的开头或结尾的匹配。 对我们字符匹配是前后字符的界定。\b写在前面，表示后面的那个字符匹配时必须是一个单词的开始，\b写在后面，表示前面的那个字符匹配时必须是一个单词的结尾。 借用：\w,表示单词字符，包括数字、大小写字母、下划线。 \B 非单词边界，用于查找不处在单词的开头或结尾的匹配。 \B写在前面，表示后面的那个字符匹配时必须不是一个单词的开始，\B写在后面，表示前面的那个字符匹配时必须不是一个单词的结尾。 对比记忆：单词边界\b必须包括单词边界。非单词边界\B不能有单词边界。 6、预定义类预定义类其实都是对一些字符集的简写。 . [^\n\r] 除了换行和回车之外的任意字符 \d [0-9] 数字字符 digital \D [^0-9] 非数字字符 只要不是数字都可以 \s [ \t\n\x0B\f\r] 空白字符 空格、缩进、换行、换页 space \S [^ \t\n\x0B\f\r] 非空白字符 \w [a-zA-Z_0-9] 单词字符(所有的字母/数字/下划线) word \W [^a-zA-Z_0-9] 非单词字符 7、量词规定数量：作用范围是量词的前面的一个字符。 {n} 硬性量词 对应零次或者n次，n人为自定义的，可以是任意正数和0 {n,m} 软性量词 至少出现n次但不超过m次(中间不能有空格) {n,} 软性量词 至少出现n次(+的升级版) ? 软性量词 出现零次或一次 等价于{0,1} 软性量词 出现零次或多次(任意次) 等价于{0,} 软性量词 出现一次或多次（至少一次） 等价于{1,} 量词除了修饰前面的单个字符，还经常搭配预定义类使用。 8、或操作符可以使用竖线（|）字符表示或者的关系。 会匹配|前面或者后面。 a|bcd : 表示匹配的字符串，要么包括一个单独的a，要么包括一个整体的bcd。 可以利用小括号分组，将|操作符包裹起来，跟后面就没关系了。 (a|b)cd : 表示从a、b选一个，后面是cd。 验证一个月的31天： 1 ^((0?[1-9])|((1|2)[0-9])|30|31)$ 9、分组的反向引用反向引用标识是对正则表达式中的匹配组捕获的子字符串进行编号，通过“\编号(在表达式中)”，“$编号（在表达式外）”进行引用。从1开始计数。 在正则表达式里反向引用。 1 &apos;123*456&apos;.replace(/(\d{3})\*(\d{3})/, &apos;$2*$1&apos;) 除了直接反向引用 之外，还可以对引用的字符做一些复杂操作。 1 &apos;123*456&apos;.replace(/(\d{3})\*(\d{3})/, function (match, $1, $2) { 2 return $2 + &apos;*&apos; + $1 3 })4 10、中文匹配固定用法：[\u4e00-\u9fa5] 1 var str = prompt(&quot;请输入用户名，必须是4-6位的汉字&quot;); 2 var reg = /^[\u4e00-\u9fa5]{4,6}$/; 3 if(reg.test(str)){ 4 alert(&quot;right&quot;); 5 }else{ 6 alert(&quot;wrong&quot;); 7 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[arguments对象]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle13%2F</url>
      <content type="text"><![CDATA[1、arguments对象在其他语言里，一个函数定义两次，每次有不同的形式参数，代表的就是两个不同的函数，叫做函数的重载（overloaded）。 1 function fun(a,b){ 2 console.log(1); 3 } 4 function fun(a,b,c){ 5 console.log(2); 6 } 以上在其他语言里，作为两个不同的函数执行，如果实际参数有2个，调用第一个函数，如果实际参数有三个，调用第二个函数。 JS语言没有函数重载的现象。一个标识符不能给两个函数，如果给了两个函数，第二个会覆盖前面的。不论参数是多少个，都会去执行最后一个函数内部的代码。 1 function fun(a,b){ 2 console.log(1); 3 } 4 function fun(a,b,c){ 5 console.log(2); 6 } 7 fun(1,2,3,4); JS的函数内部默认都有一个叫做arguments的类数组对象。在调用函数过程中，会传递参数，所有的实际参数不管有没有对应的形参都会存到arguments对面。 arguments对象内部存的是所有的实参，将实参以数组单独数据的形式存起来。 1 function fun(a,b){ 2 console.log(arguments); 3 } 4 fun(1,2,3,4,45,6,7); 1 function fun(a,b){ 2 // console.log(arguments); 3 arguments[5] = 10; 4 arguments.length = 10; 5 console.log(arguments.length); 6 var sum = 0; 7 for(var i = 0 ; i &lt; arguments.length ; i++){ 8 sum += arguments[i]; 9 } 10 console.log(sum); 11 } 12 fun(1,2,3,4,45,6,7); arguments并不能完全使用数组的所有方法。 1 var arr = arguments.slice(3,5); 2 console.log(arr); arguments常用于封装函数时，模拟函数重载现象。 一个函数有三个形式参数，用户传一个参数，直接给参数乘以2，传2个参数，求两个参数的和，如果穿3个参数，先比较前两个数的大小，大的数与第三个数求和。 1 function sum(a,b,c){ 2 //根据实际参数个数不同，走不同的分支 3 switch(arguments.length){ 4 case 1: 5 return a * 2; 6 break; 7 case 2: 8 return a + b; 9 break; 10 case 3: 11 return (a &gt; b ? a : b) + c; 12 break; 13 default: 14 throw new Error(&quot;参数个数必须是1到3个，请重新输入&quot;); 15 } 16 } 17 console.log(sum(1)); 18 console.log(sum(1,2)); 19 console.log(sum(1,2,3)); 20 console.log(sum(1,2,3,4)); 2、IIFEIIFE：immediately-invoked function expression。即时调用函数表达式。指的就是函数在声明、定义的同时，直接调用。 （）调用函数的操作符。不能直接用在关键字定义的函数后面。 1 function fun(){ 2 console.log(1); 3 }(); 可以用函数表达式直接调用。函数表达式中，将函数矮化成了表达式，表达式是可以参数数学运算。 1 var fun = function(){ 2 console.log(2); 3 }(); 可以通过将函数矮化成表达式的形式，直接进行调用。常用的其他方法：如果函数前面加一个数学运算符，就可以矮化成表达式。 1 2 +function fun(){ 3 console.log(1); 4 }(); 5 -function fun(){ 6 console.log(1); 7 }(); 8 !function fun(){ 9 console.log(1); 10 }(); 11 (function fun(){ //()是我们最常用 12 console.log(1); 13 })(); IIFE的函数不能再外面使用函数名调用，认为函数是未定义。 1 (function fun(){ 2 console.log(1); 3 })(); 4 fun(); IIFE将fun函数的作用域给关住，在外面调用找不到这个函数定义。最常见的IIFE的写法：内部的函数是一个匿名函数。 1 (function(){ 2 console.log(1); 3 })(); IIFE可以自身传递参数。 1 2 (function(a){ 3 a++; 4 console.log(a); 5 })(5); 6 (function(a){ 7 a++; 8 console.log(a); 9 })(5); 10 (function(a){ 11 a++; 12 console.log(a); 13 })(8); 在查找变量时，在IIFE内部查找，不会去全局。 1 var a = 5; 2 (function(a){ 3 a++; 4 console.log(a); 5 })(); 作用：用来解决一些闭包的问题。 3、通过数组观察闭包数组内部每一项都是一个函数。可以自动的通过遍历给数组添加项。 1 //在数组内添加十个函数 2 var arr = []; 3 for(var i = 0 ; i &lt; 10 ; i++){ 4 //闭包：记住自己的定义域环境、内部语句。 5 arr[i] = function(){ 6 console.log(i); 7 }; 8 } 9 console.log(arr[8]); 10 arr[0](); 11 arr[1](); 12 arr[2](); 13 arr[3](); 14 arr[4](); 15 arr[5](); 每个函数都记住了自己的定义域环境和内部语句，环境记住了一个i变量，最终执行时，i变量的值已经变成了10. 利用IIFE解决问题。 1 //在数组内添加十个函数 2 var arr = []; 3 for(var i = 0 ; i &lt; 10 ; i++){ 4 //闭包：记住自己的定义域环境、内部语句。 5 //IIFE可以关注函数的作用域 6 (function(a){ 7 //内部记住a的值是固定的了，就是这次循环传进来的i 8 arr[a] = function(){ 9 console.log(a); 10 } 11 })(i); 12 } 13 console.log(arr[8]); 14 arr[0](); 15 arr[1](); 16 arr[2](); 17 arr[3](); 18 arr[4](); 19 arr[5](); IIFE可以解决数组中闭包出现的问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[getElementsByTagName使用方法]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle15%2F</url>
      <content type="text"><![CDATA[1、概述getElementsByTagName：get获取 elements多个元素 by 通过 tagname标签名字。 参数：引号包裹标签名。 通过p标签获得元素：查找所有页面上的p标签，得到的是所有标签元素对象组成的数组。 1 &lt;p&gt;1&lt;/p&gt; 2 &lt;p&gt;2&lt;/p&gt; 3 &lt;p&gt;3&lt;/p&gt; 4 &lt;p&gt;4&lt;/p&gt; 5 &lt;p&gt;5&lt;/p&gt; 6 &lt;p&gt;6&lt;/p&gt; 7 &lt;script&gt; 8 //通过p标签获取元素 9 var ps = document.getElementsByTagName(&quot;p&quot;); 10 console.log(ps); 11 console.log(typeof ps); 12 &lt;/script&gt; 1 //得到的是数组，得到一个具体的p元素 2 console.log(ps[0]); 3 console.log(ps.innerHTML); 4 console.log(ps[0].innerHTML); 通过数组下标得到的数据才是我们的具体的元素对象，才有控制元素的属性和方法。 操作内部的每个元素对象，必须遍历元素 1 //我要看得到的元素内部的html内容 2 //遍历对象数组，得到每一个元素对象，打点调用属性和方法 3 for(var i = 0 ; i &lt; ps.length ; i++){ 4 console.log(ps[i].innerHTML); 5 } 通过标签名获得元素，是页面内所有的这个名的元素，不论嵌套多深。 1 &lt;div&gt; 2 &lt;div&gt; 3 &lt;p&gt;7&lt;/p&gt; 4 &lt;/div&gt; 5 &lt;/div&gt; 数组有下标，下标顺序按照什么来排序：按照元素出现的顺序排序，首标签出现靠前，在数组里位置靠前。跟嵌套关系无关。 1 &lt;div class=&quot;box1&quot;&gt; 2 &lt;div class=&quot;box2&quot;&gt; 3 &lt;div class=&quot;box3&quot;&gt; 4 &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; 5 &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt; 6 &lt;/div&gt; 7 &lt;div class=&quot;box6&quot;&gt;&lt;/div&gt; 8 &lt;/div&gt; 9 &lt;/div&gt; 10 //遍历得到的div数组的单个元素的class。 11 for(var i = 0 ; i &lt; divs.length ; i++){ 12 console.log(divs[i].className); 13 } 如果得到元素在页面内只有一个，使用元素对象时也必须用数组的方法得到这个对象。 1 //选中的如果只有一个p元素 2 console.log(ps); 3 ps[0].style.background = &quot;yellowgreen&quot;; 连续打点调用：不仅仅document可以使用这个方法， 任何HTML元素也能调用这个方法。可以连续打点调用get系列方法。 1 //连续打点调用方法 2 //将范围缩小到id为box1的标签内部 3 var ps = document.getElementById(&quot;box1&quot;).getElementsByTagName(&quot;p&quot;); 4 for(var i = 0 ; i &lt; ps.length ; i++){ 5 ps[i].style.background = &quot;#f00&quot;; 6 } 等价写法： 1 var box1 = document.getElementById(&quot;box1&quot;); 2 //在box1里去找p 元素 3 var ps = box1.getElementsByTagName(&quot;p&quot;); 还可以对getElementsByTagName连续打点调用。 1 //连续使用getElementsByTagName获得元素，不用id。 2 var spans = document.getElementsByTagName(&quot;div&quot;)[1].getElementsByTagName(&quot;p&quot;)[2].getElementsByTagName(&quot;span&quot;); 3 spans[2].style.color = &quot;#f00&quot;; 错误写法： 1 var spans = document.getElementsByTagName(&quot;div&quot;)[1].document.getElementsByTagName(&quot;p&quot;)[2].getElementsByTagName(&quot;span&quot;); 更加好用的方法：先用id限制范围，用标签选元素。 1 var spans = document.getElementById(&quot;p1&quot;).getElementsByTagName(&quot;span&quot;); 2、批量控制①批量添加事件 通过标签名得到的是一个元素对象的数组，对数组遍历，里面每一项分别添加事件。批量添加过程。过程中注意闭包影响： 第一种解决方法：IIFE 1 // 选取第一个盒子的所有p 2 var box1 = document.getElementById(&quot;box1&quot;); 3 var ps = box1.getElementsByTagName(&quot;p&quot;); 4 5 //批量添加，for循环 6 //闭包对函数内部语句的影响 7 for(var i = 0 ; i &lt; ps.length ; i++){ 8 //用IIFE解决闭包问题 9 (function(a){ 10 ps[a].onclick = function(){ 11 ps[a].style.background = &quot;yellowgreen&quot;; 12 // console.log(ps[i].innerHTML); 13 }; 14 })(i); 15 } 第二种方法：我们可以给一个对象自定义属性，用这个属性存储每次循环是传进来的变量的值。事件函数内部有一个关键字叫做this，它本身就是指代的触发事件的对象本身。 1 //用自定义属性和事件函数内部的this来解决闭包问题 2 for(var i = 0 ; i &lt; ps.length ; i++){ 3 //自定义一个属性存储下标 4 ps[i].index = i; 5 //绑定事件 6 ps[i].onclick = function(){ 7 //谁触发事件，它就有一个this指向他自身，this本身就是这个对象 8 //this.index的值就是触发的这个对象的index。 9 ps[this.index].style.background = &quot;yellowgreen&quot;; 10 } 11 } 第二种方法较为常用。 ②批量控制 第一种：用两个按钮控制 1 //选中所有input标签 2 var checks = document.getElementById(&quot;box&quot;).getElementsByTagName(&quot;input&quot;); 3 var all = document.getElementById(&quot;all&quot;); 4 var none = document.getElementById(&quot;none&quot;); 5 6 //批量全选 7 all.onclick = function(){ 8 //遍历每一个多选框，添加checked属性 9 for(var i = 0 ; i &lt; checks.length ; i++ ){ 10 checks[i].checked = &quot;checked&quot;; 11 } 12 }; 13 none.onclick = function(){ 14 //遍历每一个多选框，更改checked属性 15 for(var i = 0 ; i &lt; checks.length ; i++ ){ 16 checks[i].checked = &quot;&quot;; 17 } 18 } 第二种方法：一个按钮控制。 1 //给all这个元素添加点击事件 2 all.onclick = function(){ 3 //判断all的value值如果是全选，将前面全部选中，将自己的value改成全不选 4 // 如果是全不选，将前面全部取消选择，将自己改成全选 5 if(all.value == &quot;全选&quot;){ 6 //全部选中 7 for(var i = 0 ; i &lt; checks.length ; i++ ){ 8 checks[i].checked = &quot;checked&quot;; 9 } 10 // value改为全不选 11 all.value = &quot;全不选&quot;; 12 }else{ 13 //全部不选中 14 for(var i = 0 ; i &lt; checks.length ; i++ ){ 15 checks[i].checked = &quot;&quot;; 16 } 17 // value改为全选 18 all.value = &quot;全选&quot;; 19 } 20 }; 第三种：一个按钮。用一个全局信号量当做一个中间值。全选和全不选作为两种状态。 1 //信号量方法 2 //如果信号量为1，表示我要全选，0表示全不选 3 var sema = 1; 4 var str = &quot;&quot;; 5 //添加点击事件 6 all.onclick = function(){ 7 //判断信号量是谁，如果是1，表示全选，str变成checked选中，信号量要改为0，value要变成全不选 8 //如果是1，str变成checked选中，如果不是变成“” 9 str = sema == 1 ? &quot;checked&quot; : &quot;&quot;; 10 //信号量更改 11 sema = sema == 1 ? 0 : 1; 12 //改按钮的value 13 all.value = sema == 0 ? &quot;全不选&quot; : &quot;全选&quot;; 14 //调用变动函数 15 choose(); 16 } 17 //变动函数 18 function choose(){ 19 for(var i = 0 ; i &lt; checks.length ; i++ ){ 20 checks[i].checked = str; 21 } 22 } 3、对应控制用一个元素去控制另外一个元素的变动。需要找到之间的关系。一般找数组下标。 1 //获取所有元素 2 var ps1 = document.getElementById(&quot;box1&quot;).getElementsByTagName(&quot;p&quot;); 3 var ps2 = document.getElementById(&quot;box2&quot;).getElementsByTagName(&quot;p&quot;); 4 5 //批量给PS1里的元素加事件 6 for(var i = 0 ; i &lt; ps1.length ; i++){ 7 //自定义属性存储下标 8 ps1[i].index = i; 9 ps1[i].onclick = function(){ 10 ps2[this.index].style.background = &quot;yellowgreen&quot;; 11 } 12 } 4、排他控制保留自己，排除别人。 排他控制方法：在点击事件函数内部多做一步工作，先将所有元素回归默认样式，给对应的元素再添加单独样式。 1 //获取所有元素 2 var ps1 = document.getElementById(&quot;box1&quot;).getElementsByTagName(&quot;p&quot;); 3 var ps2 = document.getElementById(&quot;box2&quot;).getElementsByTagName(&quot;p&quot;); 4 5 //批量给PS1里的元素加事件 6 for(var i = 0 ; i &lt; ps1.length ; i++){ 7 //自定义属性存储下标 8 ps1[i].index = i; 9 ps1[i].onclick = function(){ 10 //先将所有元素回归默认样式，给对应的元素再添加单独样式 11 //排他操作 12 for(var j = 0 ; j &lt; ps1.length ; j++){ 13 ps1[j].style.background = &quot;skyblue&quot;; 14 ps2[j].style.background = &quot;skyblue&quot;; 15 } 16 17 //给这个元素和对应的p加特殊样式 18 ps1[this.index].style.background = &quot;yellowgreen&quot;; 19 ps2[this.index].style.background = &quot;pink&quot;; 20 } 21 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS循环语句]]></title>
      <url>%2F2014%2F11%2F11%2Ftitle7%2F</url>
      <content type="text"><![CDATA[1、循环语句循环语句是一系列反复执行直到符合特定条件的命令。 循环语句实际是对某一段代码进行循环执行，在规定的一个判断条件表达式为假的时候，跳出循环，停止重复执行。 JavaScript 支持 for, do while, while这些循环语句。另外，你可以在循环语句中使用break和continue 语句 。 1、for循环语句for循环语句是一种前测试循环语句。在执行下一次需要重复的代码之前，我需要先测试一下条件表达式到底是真还是假。如果是真，可以执行，如果是假，就不在循环，跳出for循环。for循环内部的循环语句执行时有先决条件。 1 //体验一下考拉体重飙升的过程 2 for(var i = 7 ; i &lt;= 178 ; i+=3){ 3 console.log(&quot;考拉今天&quot; + i + &quot;斤了&quot;); 4 } for循环的语法： 1 for(){} 其他人总结的规律： 1 for(定义循环变量；变量的最大值；步长){ 2 循环体； 3 }以上总结有局限性，for循环并不是只有这一种书写情况。 运行原理： 遇到for循环，先执行①位置的语句，然后执行语句②条件表达式，如果②的值为true，继续执行语句③；如果②的结果为false，直接跳出for循环，执行语句⑤。如果能执行到语句③，执行完之后，去执行语句④，然后再执行语句②，如果②的值为true，继续执行语句③；如果②的结果为false，直接跳出for循环，执行语句⑤。重复这个过程……直到条件②语句为假false，彻底跳出for循环，去执行语句⑤。 注意：（）里面有三个语句，用两个分号分割开，最后一个语句后面不要加分号。 1 for(var i = 3 ; i &lt;= 35 ; i += 6;){ 2 console.log(i); 3 } 1 //第二个 2 for(var i = 5 ; i &lt; 25 ; i += 5){ 3 console.log(i); 4 } 1 //第三个 2 for(var i = 30; i &gt;= 10 ; i -= 7){ 3 console.log(i); 4 } 1 //第四个 2 for(var i = 3 ; i &lt;= 35 ; i *= 2){ 3 console.log(i); 4 } for循环内部定义的这个i变量，是一个全局变量，定义在全局，可以在全局任意地方使用。可以将i变量的声明和赋初值，写在for循环外面，第一个语句的位置可以空着。 1 //第五种 2 var i = 3; 3 for(; i &lt;= 10 ; i += 3){ 虽然第一个语句可以不写，但是分号不能省略 4 console.log(i); 5 } 如果不写第一个分号，会报错，认为你没写第三个语句 1 //第六个 2 var i = 3; 3 for(console.log(i++); i &lt;= 10 ; i += 3){ 4 console.log(i); 5 } 如果限制条件没有了，不写，认为可以一直进入到语句③，循环会无限进行下去，叫做死循环。程序一定要合理，不要书写死循环。 1 //第七个 2 var i = 3; 3 for(console.log(i++); ; i += 3){ 4 console.log(i); 5 } 6 var i = 3; 7 for(console.log(i++); i &gt; 1 ; i += 3){ 8 console.log(i); 9 }10 1 //第八个 2 for(var i = 4 ; i &lt;= 12 ;){ 3 i += 3; 4 console.log(i); 5 } 1 //第九个 2 for(var i = 4 ; i &lt;= 3 ;){ 3 i += 3; 4 console.log(i); 5 } for循环内部可以嵌套if语句，输出并不是无条件输出，只有满足某一个条件才会执行输出代码。 1 //第十个，嵌套if语句 2 for(var i = 3 ; i &lt;= 20 ; i += 5){ 3 if(i % 2 == 0){ 4 console.log(i); 5 } 6 } for循环还可以嵌套for循环，注意我们定义的循环变量一定不能重复。循环变量常用名字i,j,k. 1 //第十一个 2 for(var i = 1 ; i &lt;= 5 ; i++){ 3 for(var j = 1; j &lt;= 4 ; j++){ 4 console.log(i,j); 5 } 6 } 2、穷举思想一般我们希望得到一组有特殊意义的数据，电脑并不会直接帮我们输出，而是需要我们编写一段代码，规定一个合理范围，从范围内找到这些数据。电脑需要一一去验证某一个数据是否符合条件，如果符合就输出。 程序必须将范围内每一个数据都检测一遍，通过判断条件确定是否符合要求。这些都需要我们来编写。用到我们的循环将所有可能情况循环一遍，挑出有用的，用if语句。 穷举思想：将可能性全部列举完，穷就是穷尽、完全的意思。 外层：for循环，列举。 内层：if语句，判断。 3、do while循环do while循环是一种后测试循环语句，重复执行某一段代码，直到入口条件测试为假时，跳出循环。 1 语法： 2 do{ 3 statement 4 }while(expression);5 6 do：做某事 while：当……时候 特点：在第一次测试条件之前，结构体会提前执行一次。通常会定义一些变量，让循环有一些不同。需要将这样的变量定义在循环外面，如果定义在内部，会每次重置，有可能死循环。 1 //循环变量定义在循环外面 2 var i = 1; 3 do{ 4 console.log(i); 5 i++; 6 }while(i &lt;= 10); 结构体总是会至少输出一次，条件是后测试的，哪怕条件为假，我也会执行一次结构体。 1 //循环变量定义在循环外面 2 var i = 1; 3 do{ 4 console.log(i); 5 i++; 6 }while(i &gt;= 10); for循环其实可以模拟do while的结构体先执行一次的情况，但是不够优化，尽量少用。 1 //for循环模拟do while 2 var i = 1; 3 for(console.log(i); i &gt;= 9 ; ){ 4 console.log(++i); 5 } 1 //如果变量写在内部，每次循环都会重置，有可能是死循环 2 do{ 3 var i = 1; //全局变量不要定义在内部，会被重置，死循环 4 console.log(i); 5 i++; 6 }while(i &lt;= 10); 7 变量自加的语句，写在输出语句前面和后面，得到的结果是不一样的。 4、while循环while语句反复执行直到一个特定的条件计算为假。 while语句是一个前测试循环语句，在循环体中的代码执行之前，就要测试出口条件。 语法： 1 while(expression){ 2 statement;} 注意：如果有循环变量，需要定义在循环外边。 1 //循环变量写在外面 2 var i = 1; 3 while(i &lt; 10){ 4 console.log(i); 5 i += 3; 6 } 可以用for循环模拟，都是前测试循环语句。 1 //while语句能做的，for循环都能做 2 for(var i = 1 ; i &lt; 10 ; i += 3){ 3 console.log(i); 4 } 变量自加的过程写的位置不同，结果不同。 1 var i = 1; 2 while(i &lt; 10){ 3 i += 3; 4 console.log(i); 5 } 总结：for循环是最重要，用的最多的循环语句。如果必须先执行一次结构体，再判断，最好用do while循环。while能做的for都能做。随意挑选。 5、breakbreak会终止我们的循环。 1 //碰到5的倍数，就停止循环 2 for(var i = 1 ; i &lt; 40 ; i++){ 3 console.log(i); 4 if(i % 5 == 0){ 5 break; 6 } 7 } break如果没有特殊指向，只能终止自己在的内层循环，不能终止外层的其他循环。 1 for(var i = 1 ; i &lt;= 4 ; i++){ 2 for(var j = 1 ; j &lt;= 4 ; j++){ 3 console.log(i,j); 4 if(j == 2){ 5 break; 6 } 7 } 8 } break控制外层循环：给外层循环加一个标签，标签可以代表外层循环，在break后面加这个标签，就会终止标签对应的这一层循环。 1 waiceng : for(var i = 1 ; i &lt;= 4 ; i++){ 2 for(var j = 1 ; j &lt;= 4 ; j++){ 3 console.log(i,j); 4 if(j == 2){ 5 break waiceng; 6 } 7 } 8 } 所有循环语句：如果能够执行break语句，都会跳出循环。 6、continue作用：终止当前这一次的循环，直接进入下一次循环。案例：从1到10，去找偶数，判断如果不是2，不输出直接进入下一个循环。 1 for(var i = 1 ; i &lt;= 10 ; i++){ 2 //如果你不能被3整除，直接跳过看下一个可能性 3 if(i % 3 != 0){ 4 continue; 5 } 6 console.log(i); 7 } continue语句与break一样，也只能作用于当前的循环，不能控制外层循环。 1 for(var i = 1 ; i &lt; 4; i++){ 2 for(var j = 1 ; j &lt; 4 ; j++){ 3 if(j == 2){ 4 //这不是我要的，继续下一次循环 5 continue; 6 } 7 console.log(i,j); 8 } 9 } 控制外层循环：给外层循环加一个标签，将标签名写在continue后面，就可以控制了。 1 waiceng:for(var i = 1 ; i &lt; 4; i++){ 2 for(var j = 1 ; j &lt; 4 ; j++){ 3 if(j == 2){ 4 //这不是我要的，继续下一次循环 5 continue waiceng; 6 } 7 console.log(i,j); 8 } 9 } break和continue：能够优化我们的代码。判断一个数是不是质数，通过break简化。 1 var sum = 0; 2 for(var i = 2 ; i &lt;= Math.sqrt(n) ; i++){ 3 if(n % i == 0){ 4 //说明i是n的一个约数，n肯定不是质数 5 sum++; 6 // alert(n + &quot;不是质数&quot;); 7 break; 8 } 9 } 10 if(sum == 0){ 11 alert(n+&quot;是质数&quot;); 12 }else{ 13 alert(n + &quot;不是质数&quot;);14 } 简化：输出1~10000之间的质数 1 //输出2~10000之间的质数 2 //列出所有的情况，只要发现这个数不是质数的可能性，直接跳到下一次循环 3 waiceng:for(var i = 2 ; i &lt;= 10000 ; i++){ 4 //判断除了1和本身之外只要有质数，打断，跳入下一次循环 5 for(var j = 2 ; j &lt;= Math.sqrt(i) ; j++ ){ 6 if(i % j == 0){ 7 continue waiceng; 8 } 9 } 10 //能够进行到这一步，说明前面的continue没发生作用，j一直都不是i的约数 11 // 确定i就是一个质数 12 console.log(i); 13 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS条件分支语句]]></title>
      <url>%2F2014%2F11%2F10%2Ftitle6%2F</url>
      <content type="text"><![CDATA[1、三元运算符他是唯一一个需要三个元素参与的运算。也叫作三元表达式。 符号：? : 1 语法：boolean_expression ? true_value : false_value; 表示：前面的布尔表达式的值只有true和false两种，如果为true，运算结果就是冒号前面的true_value，如果是false，运算结果就是冒号后面的false_value。 表达式：在js里面如果出现表达式，在参与代码运行时，会先计算出结果。 1 var a = 23; 2 console.log(true ? 1 : 0); 3 console.log(false ? 1 : 0); 4 console.log(7 &gt; 8 ? 1 : 0); 5 console.log(a &gt; 0 ? 1 : 0); 6 console.log(&quot;nihao&quot; ? 1 : 0); 7 console.log(&quot;&quot; ? 1 : 0); 三元运算符的结果都可以用if语句模仿。 1 //用if语句模拟三元运算符 2 var a = 23; 3 if(a &gt; 0){ 4 console.log(1); 5 }else{ 6 console.log(0); 7 } 简单的二选一得到值的程序里，三元运算符比if语句要更加简单。而且，三元运算符会直接计算出一个值，可以赋值给变量。 1 var a = 7 &gt; 8 ? 1 : 0; 2 console.log(a); 遇到给变量通过条件二选一赋值的时候，三元表达式更加好用。 1 var beishu; 2 if(year == 0){ 3 //发月薪的1倍月薪年终奖，如果月薪大于8000，那么就是发1.2倍 4 beishu = salary &gt; 8000 ? 1.2 : 1; 5 }else if(year == 1){ 6 beishu = salary &gt; 10000 ? 1.7 : 1.5; 7 }else{ 8 beishu = salary &gt; 12000 ? 3.2 : 3; 9 } 10 bonus = salary * beishu; 11 alert(&quot;您的年终奖是&quot; + bonus + &quot;元&quot;); 拓展：逻辑运算符也有选择的功能。 1 var year = parseFloat(prompt(&quot;请输入你的工作年限，不满1年输入0&quot;)) || 0; 2、switch语句开关语句允许一个程序求一个表达式的值，并且尝试去匹配表达式的值到一个case标签。如果匹配成功，这个程序执行相关的语句。 比较if语句和switch语句： if语句： 1 if(xingzuo == &quot;白羊座&quot;){ 2 alert(&quot;会有旧朋友约见面，还有一两场的应酬，相对是比较有口福的一天，但是要注意别饮食过量，引起肠胃不适，另外还需要花费一笔钱。爱情不太稳定，会有点的小状况，部...&quot;); 3 }else if(xingzuo == &quot;金牛座&quot;){ 4 alert(&quot;今天运势佳，生活无忧无虑，爱情欢乐浪漫，时刻能感受到激情的乐趣，单身者寻寻觅觅，真爱可能就在身边。另一半会是你工作上的好帮手，能为你解决许多问题。&quot;); 5 }else if(xingzuo == &quot;双子座&quot;){ 6 alert(&quot;今日头脑清醒，思路也变得清晰许多，时间比较宽裕，可以多看看书，多补充一些额外的专业知识，对以后的发展会有帮助。对投资理财有点兴趣，领悟能力不错&quot;); 7 }else{ 8 alert(&quot;不好意思，查不到了&quot;); 9 } switch语句： 1 switch(xingzuo){ 2 case &quot;白羊座&quot;: 3 alert(&quot;会有旧朋友约见面，还有一两场的应酬，相对是比较有口福的一天，但是要注意别饮食过量，引起肠胃不适，另外还需要花费一笔钱。爱情不太稳定，会有点的小状况，部...&quot;); 4 break; 5 case &quot;金牛座&quot;: 6 alert(&quot;今天运势佳，生活无忧无虑，爱情欢乐浪漫，时刻能感受到激情的乐趣，单身者寻寻觅觅，真爱可能就在身边。另一半会是你工作上的好帮手，能为你解决许多问题。&quot;); 7 break; 8 case &quot;双子座&quot;: 9 alert(&quot;今日头脑清醒，思路也变得清晰许多，时间比较宽裕，可以多看看书，多补充一些额外的专业知识，对以后的发展会有帮助。对投资理财有点兴趣，领悟能力不错&quot;); 10 break; 11 default: 12 alert(&quot;不好意思，查不到了&quot;); 13 break; 14 } 语法： 1 switch(expression){ 2 case label1: //如果表达式的值等于label1，执行下面的statement1. 3 statement1; 4 break; //遇到break，直接跳出switch语句。 5 case label2: //如果表达式的值等于label2，执行下面的statement2. 6 statement2; 7 break; //遇到break，直接跳出switch语句。 8 case label3: //如果表达式的值等于label3，执行下面的statement3. 9 statement3; 10 break; //遇到break，直接跳出switch语句。 11 …… 12 default://前面的情况都不匹配，执行default后面的结构体 13 statement_n; 14 break;15 } default：相当于if语句里面的else。可以省略。如果写了，前面不符合就走default，如果不写，前面情况都不符合，直接跳出switch。后面的break可以不写。 break：打断程序，强制跳出当前的switch语句。如果不写break，程序会继续往下进行，直到碰到一个break或者程序执行完，才能跳出。 1 switch(a){ 2 case 3: 3 alert(&quot;three&quot;); 4 case 4: 5 alert(&quot;four&quot;); 6 case 5: 7 alert(&quot;five&quot;); 8 case 6: 9 alert(&quot;six&quot;); 10 case 7: 11 alert(&quot;seven&quot;); 12 case 8: 13 alert(&quot;eight&quot;); 14 case 9: 15 alert(&quot;nine&quot;); 16 default: 17 alert(&quot;sorry, I don&apos;t know&quot;); 18 } 虽然不写不能跳出程序，我们可以利用这个特点做一些特殊的小程序。 1 var a = parseInt(prompt(&quot;请输入一个个位数，会输出它是奇数还是偶数&quot;)); 2 switch(a){ 3 case 1: 4 case 3: 5 case 5: 6 case 7: 7 case 9: 8 alert(&quot;奇数&quot;); 9 break; 10 default: 11 alert(&quot;偶数&quot;); 12 } 以下写法是错误： 1 case 1 || 3 || 5 || 7 || 9: //程序遇到表达式会先计算出结果。2 alert(“奇数”);3 break; switch语句能做的，if语句都能做。但是对于给某一个值进行匹配的情况，switch语句更优化。 总结： if语句最常用，可以做所有的条件分支语句。三元运算符，多用于给某一个变量赋值时二选一的情况。switch语句，多用于给某一个变量去匹配固定值的情况。以下也可以判断成绩好坏，但是不如if语句清晰。 1 var a = 67; 2 switch(true){ 3 case a &gt;= 90: 4 alert(&quot;best&quot;); 5 break; 6 case a &gt;= 70: 7 alert(&quot;better&quot;); 8 break; 9 case a &gt;= 60: 10 alert(&quot;good&quot;); 11 break; 12 default: 13 alert(&quot;bad&quot;); 14 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[if语句]]></title>
      <url>%2F2014%2F11%2F10%2Ftitle5%2F</url>
      <content type="text"><![CDATA[1、if语句if是如果的意思。else，否则。 1 语法： 2 if(condition){ 3 statement1 //结构体，多行代码，写在一对大括号内部 4 }else{ 5 statement2 6 } 结构体要执行就都执行，要不执行，就都不执行。 condition：条件表达式，强制给我们转成布尔值。 含义：如果条件condition为真，执行第一个结构体。如果为假，执行第二个结构体。 1 if(条件){ 2 条件为真，执行的结构体； 3 }else{ 4 条件为假，执行的结构体； } if语句可以没有else，条件成立执行结构体，不成立直接退出程序 1 if(a &lt; 60){ 2 alert(&quot;抱歉没及格，努力吧&quot;);3 } 如果执行的结构体只有单行语句，可以省略大括号 1 if(a &gt;= 60) 2 alert(&quot;恭喜，及格了&quot;); 3 else 4 alert(&quot;很遗憾，没及格，继续努力&quot;); 也能写在if语句的同一行，仅限单行结构体。 1 if(a &gt;= 60) alert(&quot;恭喜，及格了&quot;); 2 else alert(&quot;很遗憾，没及格，继续努力&quot;); 这两种写法不会报错，但是为了避免出一些不必要的问题，尽量写大括号。大括号后面不需要写分号，不会出错。 if语句殊途同归，不管执行哪个程序，退出后都继续执行后面的语句 1 if(a &gt;= 60){ 2 alert(&quot;恭喜，及格了&quot;); 3 }else{ 4 alert(&quot;很遗憾，没及格，继续努力&quot;); 5 } 6 alert(&quot;好好准备下一次考试&quot;); 2、多条件分支语句条件并不是只有一个，每一个条件对应一个结构体。 if……else if …… else if…… else if…… else …… 如果……否则如果……否则如果……否则…… 1 if(条件1){ 2 满足条件1执行的结构体 3 }else if(条件2){ 4 条件1不满足，满足条件2时执行的结构体 5 }else if(条件3){ 6 条件1/2都不满足，满足条件3时执行的结构体 7 }else if(条件4){ 8 条件1/2/3都不满足，满足条件4时执行的结构体 9 }else{ 10 以上条件都不满足，执行的结构体11 } 跳楼现象：程序会选择一个分支执行（跳楼），如果执行了这个分支，表示前面分支的条件都没有满足。 案例：详细划分成绩评价，优秀，良好，及格，不及格。 1 if(a &gt;= 90){ 2 alert(&quot;优秀&quot;); 3 }else if(a &gt;= 70){ //如果走到这一步，隐含了a&lt;90 4 alert(&quot;良好&quot;); //执行完之后，直接跳楼，不会执行后面的条件分之 5 }else if(a &gt;= 60){ 6 alert(&quot;及格&quot;); //如果走到这一步，隐含了a&lt;70 7 }else{ 8 alert(&quot;不及格&quot;);9 } 大坑 1 var b = 1; 2 if(b &lt;= 3){ //只会选择这个条件内部的结构体，执行后直接跳楼 3 b += 4; 4 }else if(b == 5){ 5 b += 3 6 }else if(b == 8 ){ 7 b += 4 8 }else{ 9 b += 10; 10 } 11 console.log(b); 3、if语句嵌套制作一个结构的时候，有两个限制条件，可以使用if语句的嵌套。 if语句可以嵌套if语句使用，最终执行符合条件成立的结构体 1 if(sex == &quot;男&quot; &amp;&amp; age &gt;= 22){ 2 alert(&quot;可以领证了&quot;); 3 }else if(sex == &quot;女&quot; &amp;&amp; age &gt;= 20){ 4 alert(&quot;可以领证了&quot;); 5 }else{ 6 alert(&quot;你还小，等等吧&quot;); 7 } 以上程序也可以达到效果：结构划分不清晰，条件比较复杂。 1 //if语句嵌套方法，每一层if语句只判断一个条件，内部再去进行另一个条件的判断。 2 //第一层，只判断性别 3 if(sex == &quot;男&quot;){ 4 //第二次，判断年龄 5 if(age &gt;= 22){ 6 alert(&quot;可以领证了&quot;); 7 }else{ 8 alert(&quot;你还小，等等吧&quot;); 9 } 10 }else{ 11 //第二次，判断年龄 12 if(age &gt;= 20){ 13 alert(&quot;可以领证了&quot;); 14 }else{ 15 alert(&quot;你还小，等等吧&quot;); 16 } 17 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数的使用]]></title>
      <url>%2F2014%2F11%2F04%2Ftitle8%2F</url>
      <content type="text"><![CDATA[函数就是功能。函数可以封装一段代码，整体会具备一个功能，可以人为的定义自己的功能。函数执行时候，所有的这一段封装的代码都会立即执行，实现这个功能。 1 //定义函数 2 function fun(){ 3 console.log(1); 4 console.log(2); 5 console.log(3); 6 console.log(4); 7 console.log(5); 8 } 9 //使用函数 10 fun(); 11 fun(); 函数的特点①：函数能够封装一些重复性的代码，使用时直接调用，简化代码。 1、函数的声明和调用1.1 函数的声明 函数必须先定义才能使用。 函数定义：也叫作函数声明。关键字：function。本身就是功能意思。定义语法：function关键字后面必须跟一个空格，后面是我们自定义的函数名字，紧跟着是一个小括号（参数），后面紧跟着是一个大括号，里面放的就是我们封装的结构体。函数后面不用加分号。 1 function 函数名(参数){ 2 封装的结构体； 3 } 函数名是一种标识符，必须遵循标识符命名规范： 首字符必须是字母、下划线、美元符号。 其他字符可以是字母、下划线、美元符号、数字。 区分大小写，且不能是关键字和保留字。 1 function fun(){ 2 alert(&quot;hello world&quot;); 3 } 意义：只是定义了一下函数执行时要做的工作，并不会去自动执行这些代码。函数只有调用的时候，才会执行内部的结构体。 1.2函数的调用 函数调用方法：函数名（）；直接在函数名后面加小括号。 1 //函数声明 2 function fun(){ 3 alert(&quot;hello world&quot;); 4 } 5 //函数的调用 6 fun(); 函数内部的结构体执行的位置，与定义的位置无关，与函数调用的位置有关。 1 //定义函数 2 function fun(){ 3 console.log(1); 4 console.log(2); 5 console.log(3); 6 } 7 console.log(10); 8 console.log(20); 9 console.log(30); 10 fun(); 函数一次声明，可以多次调用。函数每次调用时，内部的结构体都会全部一起执行。 1 fun(); 2 fun(); 2、函数的参数函数使用的目的，方便我们重复使用某一个功能，有时候需要功能发生一些变化，函数留了一个接口给我们，让我们的程序可以根据输入值的不同发生相应变化。 参数就是函数预留的接口：通过参数的变化，让函数执行结果发生改变。参数书写位置：函数名后面的小括号里。 1 function 函数名(参数){ 2 封装的结构体； 3 } 参数：就是一些变量。可以有一个变量或者多个变量。 1 //定义函数 2 function fun(a){ 3 console.log(a); 4 } 5 //调用时 6 fun(1); 函数的参数：定义时，小括号内的参数叫做形式参数（形参），调用时小括号内的参数叫做实际参数（实参），真正调用时参与到结构体里面的数据是实际参数的数据。 整个函数调用的过程，就是实际参数传递给形式参数（过程叫做传参），执行语句的过程。 函数的执行结果跟传递的参数息息相关。 参数本身是变量：变量的数据类型是动态变化，跟我们变量的赋值的数据类型有关。根据传参的不同，我们的函数会出现不同的结果。 案例：定义一个求和的函数。 1 //定义求和函数 2 function sum(a,b){ 3 console.log(a + b); 4 } 5 //调用 6 sum(2,3); 7 sum(2,&quot;3&quot;); arguments：实际参数组成的一个类数组对象。函数的形参和实参的个数可以不同。函数的形式参数可以少于实际参数，匹配对应形参的个数，多余的实参，不参与程序的执行。 1 //定义求和函数 2 function sum(a,b){ 3 console.log(a + b); 4 } 5 //调用 6 sum(1,2,3,4); 函数的形式参数多于实际参数，对应的实参先匹配传递，多出来的形式参数相当于只定义没有赋值，有一个默认的undefined值，会参与程序执行。 1 //定义求和函数 2 function sum(a,b){ 3 console.log(a + b); 4 } 5 //调用 6 sum(3); 函数参数提供了一个便利： 其实根本不需要去看函数内部的结构体怎么定义的，只需要知道执行函数传递几个参数，能实现什么功能就行了。后期，只需要对相应的函数传参，执行实现某种功能即可。 定义函数后：给一个说明，告诉用户输入几个参数，参数的数据类型要求是什么，执行之后会有什么后果。也叫API使用说明。 函数的特点 ②：函数很便利，只需要知道怎么使用某一个函数，不需要了解内部的构造。可以使用自己的函数，也可以使用别人的定义的函数，只需要知道怎么用，不需要知道为什么。简化我们自己的编程。 3、函数的返回值函数可以通过参数接收数据，也可以通过一个return返回一个值。 return：返回的意思。将函数执行结果返回一个固定的值。 1 //定义函数 2 function sum(a,b){ 3 return a + b; 4 } 5 //函数返回的是一个计算后的值，需要一个输出语句看值是多少 6 console.log(sum(2,3)); 如果函数有return返回值，就相当于将函数矮化成了一个表达式，表达式都会计算出一个结果参与到程序里。 可以将有return的函数执行后赋值给一个变量。 函数的参数也是变量，函数执行时，传递实参可以是另外一个有return函数的执行结果。 2 console.log(sum(4,sum(2,3))); 函数的特点③： 函数可以有返回值，可以将他的返回值当做另一个函数的参数，参与编程。模块化编程。 return的另外一个功能：函数内部如果遇到return，不会往下继续执行，跳出函数。 2 function fun(){ 3 console.log(1); 4 console.log(2); 5 console.log(3); 6 return; 7 console.log(4); 8 console.log(5); 9 console.log(6); 10 } 11 fun(); 4、模块化编程逆向思维：输出0~10000之间的完美数 → 什么是完美数 → 一个数的约数和 写的过程：约数和函数 → 判断完美数函数 → 输出所有完美数 13 // 逆向思维：输出0~10000之间的完美数 → 什么是完美数 → 一个数的约数和 14 // 写的过程：约数和函数 → 判断完美数函数 → 输出所有完美数 15 16 //封装一个约数和函数，传入一个数，返回它的约数和 17 function sum(a){ 18 var sum = 0; 19 for(var i = 1 ; i &lt; a ; i++){ 20 if(a % i == 0){ 21 sum += i; 22 } 23 } 24 return sum; 25 } 26 //console.log(sum(10)); 27 //可以封装判断完美数函数，传入一个数，返回它是否是完美数 28 function isWanmei(a){ 29 if(a == sum(a)){ 30 return true; 31 }else{ 32 return false; 33 } 34 } 35 //console.log(isWanmei(16)); 36 //输出0-10000之间的所有完美数 37 for(var i = 1 ; i &lt;= 10000; i++){ 38 if(isWanmei(i)){ 39 console.log(i); 40 } 41 } &gt; 5、函数递归递归：函数内部通过函数名调用这个函数本身。 19 //定义函数，内部调用了这个函数 20 function sum(a,b){ 21 b = sum(a,b); 22 return a + b; 23 } 24 console.log(sum(1,2)); 递归如果写的不够严谨，容易出错。使用时一定要考虑好。 斐波那契数列： 1、1、2、3、5、8、13、21、34、55、89、144、233……用求和函数内部，参数就是自己的上一次函数执行。 2 //定义函数，从第三项开始，等于前两项的和 3 //输出第几项斐波那契数列的值 4 function fib(a){ 5 if(a == 1 || a == 2){ 6 return 1; 7 }else{ 8 return fib(a-1) + fib(a-2); 9 } 10 } 11 console.log(fib(1)); 12 console.log(fib(2)); 13 console.log(fib(3)); 14 console.log(fib(4)); 15 console.log(fib(5)); 16 console.log(fib(6)); 17 console.log(fib(7)); 18 console.log(fib(8)); 6、函数表达式通过将一个匿名函数（或者有函数名的函数）矮化成一个表达式，赋值给一个变量的形式定义函数。 调用方法：使用变量名加小括号调用。不能用函数自身的名字调用，会报错。能够在函数内部用自己函数名字。 匿名函数：函数没有名字。也叫拉姆达函数。 9 //定义：将一个函数赋值给变量 10 //这种定义方式最后要加分号，相当于一个普通的语句给变量赋值。 11 var fun = function(){ 12 console.log(1); 13 }; 14 // 调用使用变量加小括号 15 //因为变量内部的值是一个函数，数据类型是函数的类型，函数能加小括号执行。 16 fun(); 9 var fun = function fun1(){ 10 console.log(1); 11 }; 12 //函数赋值给一个变量，函数名在外面就相当于未定义 13 fun(); 14 fun1(); 但是，函数名在函数内部是可以使用的。 8 var fun = function fun1(a){ 9 if(a == 1 || a == 2){ 10 return 1; 11 }else{ 12 return fun1(a - 1) + fun1(a - 2); 13 } 14 }; 15 //函数赋值给一个变量，函数名在外面就相当于未定义 16 console.log(fun(3)); 17 console.log(fun1(3)); 7、函数的数据类型函数数据类型：function。函数类型 10 // //定义：将一个函数赋值给变量 11 var fun = function fun1(a){ 12 if(a == 1 || a == 2){ 13 return 1; 14 }else{ 15 return fun1(a - 1) + fun1(a - 2); 16 } 17 }; 18 function fun2(){ 19 console.log(1); 20 } 21 console.log(typeof fun); 22 console.log(typeof fun2); function数据类型是一种复杂数据类型，也叫作引用类型。 简单数据类型：number、string、undefined、boolean、null。 变量内部数据类型是动态数据类型，存储数据是什么类型就是什么。 变量内部存的数据如果是简单数据类型的，存的就是一个实际的确切的能自身更改的值。 变量内部存的数据如果是引用类型，存的不是一个确切的object，而是这个对象的地址、指针。 如果存的是简单数据类型，将一个变量赋值给另一个变量的时候，相当于将变量内部的值复制了一份给新变量，而其中一个变量发生变化，对另一个不会产生任何影响。 7 var a = 1; 8 var b = a; 9 b = 2; 10 console.log(a); 11 console.log(b); 如果变量存的是引用类型，赋值给别的变量时，是将对象的地址复制一份给b，a和b指向的是一个对象原型，通过a或者b对对象做出变化，另外一个也会相应发生变化。 17 //复杂的数据类型，存储地址 18 var a = function(){ 19 console.log(1); 20 }; 21 var b = a; 22 b.haha = 2; 23 console.log(a.haha); 24 console.log(b.haha);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[运算符介绍]]></title>
      <url>%2F2014%2F11%2F04%2Ftitle4%2F</url>
      <content type="text"><![CDATA[运算符1、概述 运算符（Operators，也翻译为操作符），是发起运算的最简单形式。数学运算符(Arithmetic operators)比较运算符(Comparison operators)逻辑运算符(Logical operators)赋值运算符(Assignment operators)按位运算符(Bitwise operators)条件 (三元) 运算符(Conditional operator) 2、数学运算符数学运算符： + - * / % () 运算顺序：先算乘除取余，再算加减，有小括号先算小括号。js里数学运算没有[]、{}，全部用（）代替。 正规：数字与数字之间进行数学运算。非正规：数字与其他类型数据进行运算，其他类型数据之间进行数学运算。 ①如果是数字与纯数字字符串字符串之间进行运算。 除了＋号之外，其他的运算符，会自动将字符串转成数字。这个过程是私下进行，叫做隐式转换。不需要使用parseInt等方法。 1 // 数字与纯数字字符串,纯数字字符串之间 2 console.log(12 + &quot;2&quot;); //&quot;122&quot; 3 //在纯数字字符串参与运算之前，被隐式转换成数字类型 4 console.log(12 - &quot;2&quot;); //&quot;122&quot; 5 console.log(12 * &quot;2&quot;); //&quot;122&quot; 6 console.log(12 / &quot;2&quot;); //&quot;122&quot; 7 console.log(12 % &quot;2&quot;); //&quot;122&quot; 8 console.log(&quot;12&quot; % &quot;2&quot;); //&quot;122&quot; ②其他类型的数据参与数学运算。 其他类型的数据也会发生饮食转换。] 转换为0：空字符串、null、false转成1：true转NaN：undefined、非空非纯数字字符串。 1 console.log(23 + true); 2 console.log(23 - true); 3 console.log(23 * true); 4 console.log(23 / true); 5 console.log(23 % true); 6 console.log(23 + false); 7 console.log(23 + null); 8 console.log(23 - “”); 9 console.log(23 - undefined); 10 console.log(23 - “hello”); 11 console.log(23 - “12hello”); 1 “”→0 null→0 false→0 true→1 “12helle”→NaN undefined→NaN ③特殊数字参与运算。 特殊值NaN参与的运算都会返回NaN。 1 //所有NaN参与的运算都返回NaN 2 console.log(12 + NaN); 3 console.log(12 - NaN); 4 console.log(12 * NaN); 5 console.log(12 / NaN); 6 console.log(12 % NaN); Infinity参与的运算，要单独看。 1 //Infinity参与运算 2 console.log(23 + Infinity); 3 console.log(23 - Infinity); 4 console.log(23 * Infinity); 5 console.log(23 / Infinity); 6 console.log(23 % Infinity); 7 console.log(Infinity % Infinity); 8 console.log(Infinity + Infinity); 9 console.log(Infinity - Infinity); 10 console.log(Infinity * Infinity); 11 console.log(Infinity / Infinity); 特殊值的数学运算，防止被大公司面试阴，要过一下脑子。不过数学运算的特殊值，真心没有任何实战价值，建议没必要刻意记忆，留着脑容量记更有用的。《高3》P47~P50 总结一下：纯数字字符串、字符串在参与数学运算时，除了加号之外，其他的运算都会隐式转换。其他数据类型参与任何数学运算都会被隐式转换。 3、比较运算符种类： 大于&lt; 小于= 大于等于&lt;= 小于等于== 相等!= 不等=== 全等!== 不全等 比较运算符输出结果，都是布尔值，要么是true，要么是false。 1 //数字与数字比较 2 console.log(7 &gt; 8); 3 console.log(7 &lt; 8); 4 console.log(7 &gt;= 8); 5 console.log(7 &lt;= 8); 6 console.log(7 == 8); 7 console.log(7 != 8); 8 console.log(7 === 8); 9 console.log(7 !== 8); 10 console.log(8 === 8); 11 console.log(8 !== 8); 非常规：数字与其他类型数据进行比较，或者其他数据类型之间进行比较。 ①如果数字进行其他比较，其他类型的数据会隐式转换为数字，然后再比较。 纯数字字符串转为对应的数字，空字符串、null、false转0，true转成1. 1 console.log(1 == “1”); 2 console.log(1 == true); 3 console.log(0 == false); 4 console.log(0 == null); 5 console.log(0 &gt;= null); 6 console.log(0 &lt;= null); 7 console.log(0 == “”); 相等于和全等于的区别：相等只判断值相等就够了，全等于还要判断数据类型。 1 //判断全等,除了判断值得大小，还要判断数据类型。 2 console.log(1 === &quot;1&quot;); 3 console.log(1 === true); 4 5 //不等于、不全等于，先看等于和全等于，取反 6 console.log(1 !== &quot;1&quot;); ②字符串与字符串进行比较。 不会隐式转换为数字，比较的是Unicode字符编码顺序。顺序在前面的小于顺序在后面。 字符编码顺序：数字0~9、大写字母A~Z、小写字母a~z。 比较方法：比较的不是字符串的长度，根据字符编码顺序，一个字符一个字符比较，直到比较出大小。 1 //字符串与字符串进行比较 2 console.log(&quot;12&quot; &lt; &quot;2&quot;); 3 console.log(&quot;22&quot; &lt; &quot;2&quot;); 4 console.log(&quot;abc&quot; &lt; &quot;banana&quot;); 5 console.log(&quot;ball&quot; &lt; &quot;banana&quot;); 6 console.log(&quot;ball&quot; &lt; &quot;23&quot;); 7 console.log(&quot;ball&quot; &lt; &quot;ABC&quot;); ③NaN参与的比较 除了不等于和不全等于，NaN参与的比较运算返回的都是false。 ④Infinity自身的比较 特殊情况： 比较：3&gt;2&gt;1; 原因：代码从前往后执行，先计算3&gt;2,得到的是true，再比较时true&gt;1,返回false。控制台快捷键：清空控制台：ctrl+L执行代码：enter换行：shift+enter重新输入上一次代码：Ctrl+↑。 4、逻辑运算符逻辑运算符常用于布尔类型值之间; 当操作数都是布尔值时，返回值也是布尔值。 &amp;&amp; 逻辑与运算符 且 交集|| 逻辑或运算符 并集! 逻辑非运算符 ①逻辑与运算 真值表 a &amp;&amp; ba b 输出真 真 真真 假 假假 真 假假 假 假 规律：都真才真，有假就假。 1 //逻辑与运算 2 console.log(true &amp;&amp; true); 3 console.log(true &amp;&amp; false); 4 console.log(false &amp;&amp; true); 5 console.log(false &amp;&amp; false); ②逻辑或运算 真值表 a || b a b 输出 真 真 真 真 假 真 假 真 真 假 假 假 规律：有真就真，都假为假。 1 //逻辑或运算 2 console.log(true || true); 3 console.log(true || false); 4 console.log(false || true); 5 console.log(false || false); ③逻辑非运算 规律：非真即假，非假即真。 1 // 逻辑非运算 2 console.log(!true); 3 console.log(!false); 4 console.log(!!!!!!!!!!!!false); 正常：用于布尔值之间的逻辑运算。 非正常：其他类型的数据参与逻辑运算。将其他的数据隐式转换成布尔类型的值，计算完之后，输出对应位置的数据。不一定是输出布尔值。 隐式转换成true：非0数字、非空字符串。隐式转换为false：0、NaN、空字符串、undefined、null 1 //非布尔类型的数据 2 console.log(35 &amp;&amp; null); 3 console.log(35 || null); 4 console.log(35 &amp;&amp; &quot;nihao&quot;); 5 console.log(35 || &quot;nihao&quot;); 当它们用于非布尔值的时候，返回值就可能是非布尔值。其实这种运算非常简单，就两句话： (逻辑与 &amp;&amp; ) 如果a能被转换为false，那么返回a；否则，返回b。(逻辑或 || ) 如果a能被转换为true，那么返回a；否则，返回b。 要能深层次的理解上面的话，达到不用刻意背，自行能推倒出来的“最高境界”。花式写法：短路语法。 5、短路语法将逻辑运算，模拟电路里面的短路。 ①逻辑与比喻成串联电路。 电流通过a到b；如果a为真，电流可以流通到b，不论b为真还是假，直接抛出b。如果a为假，电流通不过，停留在a，就直接抛出a。 1 // //逻辑与运算 2 console.log(23 &amp;&amp; &quot;haha&quot;); 3 console.log(23 &amp;&amp; null); 4 console.log(undefined &amp;&amp; Infinity); 5 console.log(NaN &amp;&amp; null); ②逻辑或比喻成并联电路。 电流优先通过a。如果a为真，电流可以直接通过a，不需要到b，直接抛出a。如果a为假，电流不能通过a，换到b流过，不管b为真还是假，都抛出b。 1 //逻辑或运算 2 console.log(23 || &quot;haha&quot;); 3 console.log(23 || null); 4 console.log(undefined || Infinity); 5 console.log(NaN || null); 逻辑运算有顺序：非、与、或。 案例：NaN &amp;&amp; null || 23 &amp;&amp; !true || !false 原式= NaN &amp;&amp; null || 23 &amp;&amp; !true || !false = NaN &amp;&amp; null || 23 &amp;&amp; false || true = NaN || false || true = false || true = true 6、赋值运算符做了两步工作：先运算，后赋值。必须有变量参与运算。 = 等于 += 加等于 将后面的值加到原来的变量值上，得到的值赋值给变量 -= 减等于 *= /= %= ++ 递加 在原来的基础上加1，再赋值 – 递减 在原来基础上减一，在赋值 1 //带等号的赋值运算符 2 var a = 1; 3 4 //加等于 5 a += 2;// a = a + 2; 6 console.log(a); //3 7 8 //减等于 9 a -= 5; // a = a - 5; 10 console.log(a); //-2 11 12 //乘等于 13 a *= -5; // a = a * -5; 14 console.log(a); //10 15 16 //除等于 17 a /= 2; // a = a / 2; 18 console.log(a); //5 19 20 //取余等于 21 a %= 6; // a = a % 6; 22 console.log(a); //5 递加：符号++，与前面的变量之间不能有空格。而且++符号可以写在变量的前面，也可以写在后面。着这两种情况使用时有一些区别。 ++a:如果在一个算式里，第一次使用的值，是加完后的值，第二次使用也是加完后的新值。a++：如果在一个算是里，参与运算时，第一次使用时原来的就值，第二次使用的时候就是新值。 1 var a = 2; 2 console.log(a++); 3 console.log(a); 4 a = 2; 5 console.log(++a); 6 console.log(a); 特殊运算： 1 var a = 10, 2 b = 20, 3 c = 30; 4 var sum = ++a + b++ + a++ + ++c; 5 console.log(sum); //73 6 console.log(a); //12 7 console.log(b); //21 8 console.log(c); //31 7、综合运算顺序贴身的 → 数学的 → 比较 → 逻辑的 → 赋值的。 1 综合案例： 2 var a = 4; 3 a *= 1 * (2 + 3) &amp;&amp; ++a || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || !9;4 原式 = a *= 1 * (2 + 3) &amp;&amp; ++a || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || !9; = a *= 1 * (2 + 3) &amp;&amp; 5 || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || false; = a *= 5 &amp;&amp; 5 || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || false; = a *= 5 &amp;&amp; 5 || false &amp;&amp; true || false = a *= 5 || false || false = a *= 5 a = 20]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IE6兼容及hack使用]]></title>
      <url>%2F2014%2F10%2F31%2Ftitle3%2F</url>
      <content type="text"><![CDATA[一、HACK我们真正的网页是由一份html和css来完成，在不同用户电脑上可能不一样的渲染效果。但是我们需要所有浏览器渲染效果都是一致的，由于存在兼容问题，对于一些特殊的html和css，要根据浏览器的不同，写不同的代码，显示效果是一样的，这个技术就叫做HACK（Hacker黑客）。 hack：针对不同的浏览器写不同的html和css，达到显示一致的效果。分类：html hack，css hack。 1、html的hack根据不同的浏览器写不同的html代码。需要用到一个辅助的代码，叫做hack符号。IE浏览器存在很多兼容问题，IE给我们留了一个接口，规定的IE版本的浏览器认识里面是html结构，其他的浏览器认为里面的是注释。 &lt;!--[if lte IE 9]&gt; 这是一段文字 &lt;![endif]--&gt; 这段代码里面的文字，只能在IE9及以下的版本浏览器内看得到。其他的不显示，认为是注释。 if：如果 lte：小于等于 IE 浏览器 9版本。 lte：less than or equal ，小于等于 lt：less than ，小于 gt：greater than ，大于 gte： greater than or equal ，大于等于 如果低于IE8就显示，其他的认为是注释。 &lt;!--[if lt IE 8]&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;![endif]--&gt; 如果高于IE8就显示，其他的认为是注释。 &lt;!--[if gt IE 8]&gt; &lt;h2&gt;大于IE8能看见&lt;/h2&gt; &lt;![endif]--&gt; 如果只有IE8认识，其他都是注释。 &lt;!--[if IE 8]&gt; &lt;p&gt;只有IE8认识&lt;/p&gt; &lt;![endif]--&gt; 作为浏览器版本提醒： 有一些代码在IE中加载，其他浏览器不加载。 位置不能乱写：不能卸载css样式里面 &lt;style&gt; .box{ width: 100px; height: 100px; border-radius: 50%; background: skyblue; } &lt;!--[if IE 6]&gt; &lt;script src=&quot;js/ie6.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/style&gt; 2、css的hack针对不同的浏览器写不同的css样式。 css hack：值的hack、选择器的hack 2.1 值的hack 对某一个特定的属性值写hack。/IE6/hack符：_下划线、-横线。 .box{ width: 100px; height: 100px; background: skyblue; _background: gold;//表示只有IE6认识 } 其他浏览器会认为是未知的属性名：unknown property name。 /IE6、7/ hack符：~ ! @ # $ % ^ &amp; * ( ) + ` [ ] | &lt; &gt; ? / .任意一个符号都可以，表示只有ie6/7认识，其他的都是不认识。 !background: green; |background: green; +background: green; [background: green; /IE8/hack符：在属性值的后面加\0/。 .selector { color: blue\0/; } 只有IE8里加载这个属性。 background: red\0/; /IE8/9/hack符：在属性值后面加\0. /*IE6/7/8/9/10*/ hack符：在属性值后面加\9 background: red\9; 实际工作：记住IE6的下划线。IE6/7记住一个！。 2.2 选择器hack 针对不同的浏览器，加载不同选择器内的所有样式。 / IE 6 and below /  html .selector {}只有IE6及以下的浏览器认识这个选择器。高级浏览器认为html就是整个结构的根元素，不包含在*通配符选择器内，所以不认识这个选择器。而IE6及以下是认识。 .box{ width: 100px; height: 100px; background: skyblue; } * html .box{ width: 200px; height: 200px; background: pink; } 等价于：内部的属性值都加hack符。 _width: 200px; _height: 200px; _background: pink; / IE 7 and below / .selector, {}IE7及以下才认识的选择器写法。 .box,{ width: 200px; height: 200px; background: green; } 等价于： .box{ !width: 200px; !height: 200px; !background: green; } / Everything but IE 6 / html &gt; body .selector {}表示出了IE6其他的浏览器都认识。IE6不支持&gt;表示的子级选择器。 html&gt;body .box{ width: 200px; height: 200px; background: purple; } / Everything but IE 6/7 / html &gt; /**/ body .selector {} head ~ / / body .selector {} 除了IE6/7，其他的都认识。实际：选择器的hack不常用，不会把所有的属性都重写，单一的属性单独设置，直接用值hack。 二、IE6兼容问题 1、盒模型 1.1 DTD 如果页面没有写文档DTD，页面盒子在加载时其他高级浏览器正常加载，IE6加载模式是一种怪异模式。 正常：宽高确定后，添加内边距、border盒子整体外扩。 怪异：宽高确定后，添加内边距、border盒子会往内自减，实际书写内容区域变小。 解决方法：写DTD。 1.2盒子高度不能低于字号 IE6有默认字号是18px。其他浏览器都能够设置盒子高度低于默认字号的盒子。IE6不能让盒子高度低于18px。 解决方法：给你要设置高度的盒子单独设置一个字号属性，属性值小于你要设置的盒子高度。 _font-size: 0;只有IE6加载这个属性。 1.3 图片边框问题 图片外如果包裹了一个a标签，在IE6里会比正常情况给图片多加了一个蓝色的边框。 解决方法：给img都清除边框。 img{ border: none; } 2、浮动 2.1 一个浮动一个不浮动 高级浏览器：不浮动的元素会钻到浮动元素下面。 IE6：排在浮动元素后面。不会出现压盖效果。 解决方法：不要用浮动制作压盖，同级元素一个浮动另外一个也要浮动。 2.2 3像素bug 如果元素一个浮动，一个不浮动，IE6里会并排排列，同时两个元素之间多了3像素间距。 解决方法： ①同级元素一个浮动另外一个也要浮动。②给浮动的元素添加一个margin-right值为-3px的属性。 .box1{ width: 100px; height: 100px; background: #f40; float: left; margin-right: -3px; } 2.3 双倍margin问题 如果浮动的方向和margin边距的方向相同，那么首个浮动的元素距离父盒子的边距是margin值的两倍。 解决方法： ①浮动的方向与margin的方向相反，父盒子和第一个元素的间距用父盒子的padding挤出来。不要用儿子踹父亲。 ul{ list-style: none; width: 780px; padding-right: 20px; height: 40px; border: 1px solid #000; margin: 100px auto; } ul li{ float: right; width: 100px; height: 40px; background: #f40; margin-left: 20px; } ②非要用margin去撑开。单独给IE6的第一个盒子设置一个margin值减半。 ul li.half_margin{ _margin-right: 10px; } 2.4 overflow:hidden失效 加了overflow属性之后，盒子可以清除内部的浮动，自适应高度。IE6以前不能使用它来清浮动的效果。布局：layout。 IE有两个加载机制：有布局、没有布局。 有布局：hasLayout，盒子在布局时，根据内部元素的内容来进行布局。 没有布局：盒子在布局时，盒模型数据是来源于父元素。我们需要想办法触发有布局机制。有很多属性都能触发。有一个属性始终能够触发zoom放大属性。属性值：数字，1表示按1倍放大，2表示按2倍放大…… .box{ width: 700px; border: 10px solid #999; margin-bottom: 20px; overflow: hidden; _zoom: 1; } 三、图片和透明 1、图片 网页使用的三种图片：JPG、png、GIF。分辨率：72像素/英寸 1.1 JPG图片 是我们最常用的一种图片格式。 特点：色彩丰富。可以压缩，品质可以调整。 缺点：不能保存图层，不能做动图，不能保存背景透明、图片半透明的效果。 用途：有实际意义的结构，用作插入图，背景不是透明的背景图，图片大小比较小。 1.2 png图片 特点：不可压缩，可以保存图层，可以保存透明和半透明。 缺点：文件太大。 大小并不是一定png就比JPG大。色彩很丰富，图层保存比较多的时候，肯定是png文件大。如果保存的图片背景透明，文件色彩、形状都比较简单，png图片导出成没有图层的时候，文件反而比JPG要小。png图片保留一份带图层，往网上上传是需要将png图片导出一份图层合并之后。 用途：背景透明和半透明的图片，精灵图，图片比较小色彩不是很复杂。 1.3 GIF图片 GIF图片无所压缩不压缩的问题。色彩比较单一，色值有256种、128种、216种、64种……2种。 特点：文件小，可以存动图，能够保存透明，不能保存半透明。 动图：通过添加时间轴帧动画，每一帧都有一张图片，连续按照一定的时间间隔播放，有一个动图的效果。背景透明：同一个图片，png比GIF文件要大。 用途：动图，完全透明的背景图片（解决pngIE6背景透明的兼容问题）。 2、盒子透明 需要用一个属性完成，透明度属性opacity，属性值是0到1之间的小数。 opacity: 0.5;透明效果：盒子本身半透明，内部的元素也跟着透明。 IE8及以下的浏览器不支持opacity属性。虽然不支持，IE有自己的设置盒子透明的属性，滤镜属性filter。http://justcoding.iteye.com/blog/940184/比较强大。内部有多重滤镜属性，其中包括alpha通道透明。 透明度的数值注意：0~100之间的整数。 filter: alpha(opacity=50); 解决内容同时透明的问题：只让盒子透明，内容不透明。将文字单独拿出来放在别的盒子里，用定位定到半透明幕布上面。 3、图片透明 除了IE6，其他浏览器都能够正常的加载背景透明或半透明效果的PNG图片。ie6不支持。 解决IE6的png图片兼容问题： 方法一：如果只有透明，没有半透明，可以用GIF图片格式代替，GIF在IE6里没有兼容问题。 方法二：给我们页面添加一段只有IE6认识的js代码，解决png背景透明问题。 &lt;!--[if IE 6]&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/png.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; DD_belatedPNG.fix(&quot;选择器&quot;);//多个选择器，用逗号隔开 &lt;/script&gt; &lt;![endif]--&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS中定位的使用]]></title>
      <url>%2F2014%2F10%2F16%2Ftitle2%2F</url>
      <content type="text"><![CDATA[1、相对定位定位：元素位置相对于某一个参考物进行的位置的偏移。 相对定位：元素相对于自身进行的位置偏移。position：定位属性。属性值：relative。相对的。 偏移的数据量。有其他属性来控制，方向属性，left、right、top、bottom。 position: relative; left: 100px; top: 110px; 便宜方向判断：如果属性值为正，偏移方向与属性方向相反。 left: 100px; 向右100 top: 110px; 向下110 right: 20px; 向左20 bottom: 20px; 向上20 等价于：属性值为负值，便宜方向与属性方向相同。 right: -100px; 向右100 bottom: -110px; 向下110 综合：水平方向和垂直方向可以任选一个属性，进行搭配。 .box{ left: 100px; //以元素自身左上角顶点为参考点，向右向下移动 top: 110px; } left: 100px; bottom: 110px; //以元素自身的左下顶点为参考点，向右上移动。 right: 50px; bottom: 110px; //以元素自身的右下顶点为参考点，向左上移动。 right: 50px; top: 110px; //以元素自身的右上顶点为参考点，向左下移动。 特点：显示的位置是偏移后的位置，原位置还保留，没有被其他元素给占有，形影分离。相对定位不会让元素脱离标准流，标准流的位置还是他自己的。用途不是很多，也有自己的特殊用途。 ①结构比较稳固，经常拿来做绝对定位的参考元素，子绝父相。②微调。 div span{ font-size: 12px; position: relative; bottom: 6px; } 2、绝对定位绝对定位的定位参考元素不固定的，但是不是本身。属性值：absolute。绝对的。也有四个方向的偏移量：left、right、top、bottom。 position: absolute; top: 100px; left: 150px; 特点：与相对定位比较，元素绝对定位之后，脱离标准流，标准流的位置让给了后面的元素。绝对定位的元素根据选取偏移方向不同，参考点也不同。 ①参考元素为body时的定位参考点 有top参与的绝对定位，定位的参考点是页面（body）的左上角和右上角 position: absolute; top: 200px; right: 300px; 有bottom参与的绝对定位：参考点是页面（body）首屏的左下角和右下角。 position: absolute; bottom: 200px; left: 300px; ②祖先元素作为参考元素 如果祖先元素中有定位的元素，元素绝对定位的参考元素就是距离它最近的有定位的祖先元素。 &lt;div class=&quot;box1&quot;&gt; //有相对定位 &lt;div class=&quot;box2&quot;&gt; //有相对定位 &lt;div class=&quot;box3&quot;&gt;//没有定位 &lt;p&gt;&lt;/p&gt; //绝对定位，参考元素是box2 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box1&quot;&gt; //有相对定位 &lt;div class=&quot;box2&quot;&gt; //有绝对定位 &lt;div class=&quot;box3&quot;&gt;//没有定位 &lt;p&gt;&lt;/p&gt; //绝对定位，参考元素是box2 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 绝对定位元素的参考盒子，可以是相对定位，也可以是绝对定位，还可以是固定定位。 子绝父相：子元素是绝对定位，参考的祖先元素是相对定位。 子绝父绝：子元素是绝对定位，参考的祖先元素是绝对地位。 子绝父固：子元素是绝对定位，参考的祖先元素是固定地位。 只要祖先元素中有任何一种定位，距离该子元素最近，它就是定位参考元素。子绝父相方法最常用：相对定位的元素不脱离标准流，结构稳定，对于当参考物来说比较方便。 ③祖先元素参考时的参考点 会忽视我们祖先元素的padding区域，以border内部的四个顶点作为相应方向的参考。相应方向：与使用的定位偏移方向是一致。 position: absolute; bottom: 50px; left: 50px; ④制作压盖效果 用绝对定位制作压盖效果。 .box{ position: relative; width: 400px; height: 400px; border: 1px solid #000; padding: 20px; margin: 100px auto; } .demo1{ width: 400px; height: 400px; background: skyblue; } .demo2{ width: 100px; height: 30px; background: gold; position: absolute; left: 160px; bottom: 40px; } ⑤绝对定位元素的居中 不能使用标准流的方法，只能先左边线居中，自身拽回宽度一半。 .demo2{ width: 100px; height: 30px; background: gold; position: absolute; left: 50%; 移动父亲宽度的50% bottom: 40px; margin-left: -50px;将元素本身拽回自身宽度的一般 } 补充：鼠标显示小手状态cursor: pointer; 3、固定定位固定定位，参考我们的浏览器窗口进行定位。属性值：fixed。始终保持针对浏览器窗口某一个顶点位置相对不变。也有四个方向的偏移量的值：left、right、top、bottom。 position: fixed; bottom: 80px; right: 80px; 4、压盖顺序z-index默认压盖顺序： ①有定位的元素压盖没有定位的元素。②有定位的元素，不区分定位类型，只要html结构写在后面的压盖写在前面。 自定义压盖顺序 属性：z-index，压盖顺序。属性值：数字，没有任何单位，数值越大，压盖数值小的。 ①只能给定位的元素加，其他的标准流的或者浮动元素都没有z-index属性。默认的定位元素的z-index值是1. position: relative; left: 0; bottom: 300px; z-index: 2; ②属性值越大的会压盖属性值越小的。 ③如果属性值相同，看html结构书写顺序，后面的压盖前面的。 ④父子盒模型里，如果父子都有定位，都有自定义的z-index值，两对父子对比时，不管子元素的属性值多大，只要父亲z-index值小，都只能被压盖。子级再大，如果父级数值小，都不管用。 &lt;div class=&quot;box1&quot; //父亲一z-index是5 &lt;div class=&quot;small&quot;&gt;1&lt;/div&gt;//30 &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;//父亲二z-index是4 &lt;div class=&quot;big&quot;&gt;2&lt;/div&gt;//100 &lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CSS-background背景]]></title>
      <url>%2F2014%2F10%2F16%2Ftitle1%2F</url>
      <content type="text"><![CDATA[background是一个复合属性。 1、background-color背景色渲染位置：border及以内。属性值：十六进制、rgb、rgba、颜色名。 background-color: blue; 2、background-image背景图实际渲染位置：跟背景色一样，能看到的其实就是border以内。属性值：url(图片路径)。 background-image: url(images/hai.jpg); 添加的背景图片会铺满整个盒子的背景区域。 url：uniform resource locator。统一资源定位符。实际就是背景图片的来源。url内部的值：图片的路径，可以是相对路径，也可以是绝对路径。 背景图和背景色的压盖顺序：image压盖color。 3、background-repeat背景重复设置背景图片以什么方式进行重复。属性值：repeat 默认值，整个背景区域重复no-repeat 不重复repeat-x 水平方向重复repeat-y 垂直方向重复 background-repeat: repeat; background-repeat: no-repeat; background-repeat: repeat-x; background-repeat: repeat-y;` body背景加载效果： repeat-x的一个妙用：制作一个渐变背景的导航栏。给盒子添加一个背景图：水平方向1像素宽，垂直方向就是正常高度，让背景图，水平重复铺开。 background-image: url(images/nav_bg.png); background-repeat: repeat-x; background-position背景图位置 作用：规定我们插入的背景图的在盒子里的位置。属性值：像素表示法、单词表示法、百分比表示法。 ①像素表示法属性值有两个，都用像素表示： background-position: 150px 100px; 第一个属性值：背景图片左上角距离盒子背景区域左上角（border以内）的水平偏移量。 第二个属性值：背景图片左上角距离盒子背景区域左上角（border以内）的垂直偏移量。 位置的属性值分正负。正方向：向右向下移动；负方向：向左向上移动。指的是图片针对（0,0）点移动的方向。 css精灵图技术：很多元素都有背景图，需要有实际存在图片，就需要发送多个http请求下载图片。将很多小的背景图合成在一张图片上，谁用背景图加载的都是一张图片。用法：给一个合适盒子大小，通过背景图定位找到图片的位置。 ②单词表示法 图片位置水平和垂直方向用代表方向的单词来表示 水平方向，第一个属性值：left ，center，right。背景在盒子内部居左、居中、居右。 垂直方向，第二个属性值：top，center，bottom。背景图在盒子内部居上、居中、居下。 background-position: center center; body大背景效果：水平居中、垂直居上。 background-position: center top; 制作通栏ｂａｎｎｅｒ。 ③百分比表示法 关注：百分比参考依据。 background-position: 100% 50%; background-attachment背景附着 指的是背景是否随着页面滚动而滚动。 属性值：scroll 滚动，背景图会随着页面滚动走。 fixed 固定，背景图不会随着页面滚动而滚走。 background-attachment: fixed; background复合属性background: #f00 fixed url(images/bg4.jpg) no-repeat center top; 五个属性之间位置可以更换，position的两个属性值位置不能电脑。 #二、背景实际应用# 1、padding挤出背景图效果方法：给盒子用padding-left留出一个空白区域，添加一个合适的背景图，不重复。 padding-top: 96px; background: url(images/in_12.png) no-repeat center top; 2、文字换图片提高搜索引擎优化：搜索时都是搜索文字。 h1标签内部放的是logo的图片。用一个技巧，logo图不用插入图，换成背景图，内部放置的是简单的关键字。 h1 a{ display: block; height: 96px; background: url(images/in_15.png); 添加背景图，用户看到 text-indent: -9999px; 隐藏文字 overflow: hidden; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css中浮动的影响]]></title>
      <url>%2F2014%2F10%2F11%2Ftitle%2F</url>
      <content type="text"><![CDATA[1、浮动存在的问题浮动的元素不能撑高父级。元素脱离标准流之后， 不能再撑高它的父级盒子浮动会影响后面的浮动的元素。如果后面的浮动方向相同， 会去贴上一个浮动最后一个元素的边。 2、清楚浮动影响的方法 给父盒子加高度给父级元素增加高度， 它内部的浮动元素， 被限制了范围， 不会再影响后面的元素浮动。 效果： 解决父级高度的问题， 解决浮动影响后面的浮动的问题。 问题： 高度还是不能够自适应。 清除浮动属性 clear 元素都可以设置一个叫做 clear 的属性， 清除浮动的作用。 属性值： left、 right、 both。作用： clear 整体表示清除自身受到的其他元素带来的浮动的影响。left： 清除受到的左浮动影响。right： 清除受到的右浮动影响。both： 清除受到的左右两个方向的浮动影响。 box1{ clear: both;} ` 解决： 浮动的互相影响。` 问题： 父盒子还是不能被子盒子撑高。 margin 如果小于中间浮动的子元素的高度， 显示效果失效。隔墙法外墙法：在右浮动元素的父盒子之间隔一堵墙。 添加两个类， 一个是用来清除浮动， 一个用来模拟外边距。 cl{ clear: both; 清除浮动 } .h20{ height: 20px; 模拟间距 } 解决： 浮动互相影响。问题： 高度自适应， MARGIN 失效。 内墙法：将清除浮动的墙放在有浮动元素的父盒子内部的最后。 只要有浮动， 就在盒子内部加一堵墙。 解决： 浮动互相影响， 高度自适应， margin 失效。 缺点： ①html 结构布局， 很多需要进行浮动， 每个浮动的盒子内都需要隔一堵墙。 页面结构复杂会出现很多冗余的没有意义的标签。 ②一个盒子内的标签要浮动就都浮动， 浮动后面的墙是一个标准流里的元素overflow： hidden盒子内部的元素可以设置溢出模式， 隐藏， 自动显示。overflow： 溢出。 属性值： hidden 溢出隐藏， auto 溢出滚动（ 多出的内容出现滚动条）` { `overflow： hidden; overflow： auto;` } overflow 的其他小功能： 能够清除盒子内部元素的浮动影响 解决： 浮动互相影响， 高度自适应， margin 失效。 优势： 能够解决所有的问题， 不会增加无用的标签。 3、overflow： hidden； 的加载机制：高度自适应： 如果元素有溢出隐藏的属性， 网页加载时， 会强制的去元素内部搜索， 识别所有内部元素的高度， 会用最高的元素高度配给我们父盒子的自适应高度。 浮动影响： 加载时， 如果有溢出隐藏， 强制检索， 看盒子内部是否有浮动的元素， 如果有， 会被整体管理起来， 在自身的高度内， 不会影响其他的浮动元素。实际工作中： 就用 overflow 来清浮动]]></content>
    </entry>

    
  
  
</search>
