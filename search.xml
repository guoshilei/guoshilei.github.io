<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[教你如何搭建github技术博客]]></title>
      <url>%2F2016%2F09%2F23%2Ftitle11%2F</url>
      <content type="text"><![CDATA[适合人群 喜欢写Blog的人 有一定的编程基础 爱折腾的人 熟练使用版本控制Git 了解使用Github 熟悉基本的MarkDown语法 环境准备 安装Git 下载 msysgit 并执行即可完成安装。 安装Node.js 在 Windows 环境下安装 Node.js 非常简单，仅须下载安装文件并执行即可完成安装。 安装hexo 利用 npm 命令即可安装。（在任意位置点击鼠标右键，选择Git bash） npm install -g hexo 问题 npm ERR! registry error parsing json 错误可能需要设置npm代理,执行命令 npm config set registry http://registry.cnpmjs.org hexo:command not found删除刚刚安装的npm目录，重新执行命令npm install -g hexo安装hexo 创建hexo文件夹 安装完成后，在你喜爱的文件夹下（如H:\hexo），执行以下指令(在H:\hexo内点击鼠标右键，选择Git bash)，Hexo 即会自动在目标文件夹建立网站所需要的所有文件。 hexo init 安装依赖包 npm install 本地查看 现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\hexo)，然后到浏览器输入localhost:4000看看。 hexo generate hexo server 好了，至此，本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。 问题 执行hexo server提示找不到该指令 解决办法： 在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下： npm install hexo -server --save 安装此server后再试，问题解决 github 创建博客注册账号 地址：https://github.com/ 输入账号、邮箱、密码,然后点击注册按钮. 创建页面仓库 这个仓库的名字需要和你的账号对应，格式: yourname.github.io输入基本信息，然后点击创建仓库. 注意命名规则：你的github账号.github.io，我这里被坑了，之前是jekell写的，现在换成hexo，所以我是另建创库了。 生成SSH密钥 ssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，密码为空。 在C:\Users\Administrator.ssh下，得到两个文件id_rsa和id_rsa.pub。 在GitHub上添加SSH密钥 打开id_rsa.pub，复制全文。https://github.com/settings/ssh ，Add SSH key，粘贴进去。 hexo使用 目录结构 .├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json 全局配置 _config.yml # Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site #站点信息 title: #标题 subtitle: #副标题 description: #站点描述，给搜索引擎看的 author: #作者 email: #电子邮箱 language: zh-CN #语言 # URL #链接格式 url: #网址 root: / #根目录 permalink: :year/:month/:day/:title/ #文章的链接格式 tag_dir: tags #标签目录 archive_dir: archives #存档目录 category_dir: categories #分类目录 code_dir: downloads/code permalink_defaults: # Directory #目录 source_dir: source #源文件目录 public_dir: public #生成的网页文件目录 # Writing #写作 new_post_name: :title.md #新文章标题 default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿） titlecase: false #标题转换成大写 external_link: true #在新选项卡中打开连接 filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false highlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace: # Category &amp; Tag #分类和标签 default_category: uncategorized #默认分类 category_map: tag_map: # Archives 2: 开启分页 1: 禁用分页 0: 全部禁用 archive: 2 category: 2 tag: 2 # Server #本地服务器 port: 4000 #端口号 server_ip: localhost #IP 地址 logger: false logger_format: dev # Date / Time format #日期时间格式 date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/ time_format: H:mm:ss # Pagination #分页 per_page: 10 #每页文章数，设置成 0 禁用分页 pagination_dir: page # Disqus #Disqus评论，替换为多说 disqus_shortname: # Extensions #拓展插件 theme: landscape-plus #主题 exclude_generator: plugins: #插件，例如生成 RSS 和站点地图的 - hexo-generator-feed - hexo-generator-sitemap # Deployment #部署，将 lmintlcx 改成用户名 deploy: type: git repo: 刚刚github创库地址.git branch: master 注意 配置文件的冒号“:”后面有一个空格 repo: 刚刚github创库地址.git hexo命令行使用 常用命令： hexo help #查看帮助 hexo init #初始化一个目录 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成网页，可以在 public 目录查看整个网站的文件 hexo server #本地预览，&apos;Ctrl+C&apos;关闭 hexo deploy #部署.deploy目录 hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹** 简写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 编辑文章 新建文章 hexo new &quot;标题&quot; 在 _posts 目录下会生成文件标题.md title: Hello World date: 2015-07-30 07:56:29 #发表日期，一般不改动 categories: hexo #文章文类 tags: [hexo,github] #文章标签，多于一项时用这种格式 --- 正文，使用Markdown语法书写 编辑完后保存，hexo server 预览 hexo部署 执行下列指令即可完成部署。 hexo generate hexo deploy 以下提示说明部署成功 [info] Deploy done: git 点击 Github 上项目的 Settings，GitHub Pages，提示Your site is published at http://****.com 图床 1.墙裂推荐七牛云储存,注册地址。 2.七牛云储存提供10G的免费空间,以及每月10G的流量.存放个人博客图片最好不过了 3.七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力（非打广告）。 具体使用见使用七牛作为github博客的图床 域名 将独立域名与GitHub Pages的空间绑定 方法一：在站点source目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如wuxiaolong.me方法二：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如wuxiaolong.me DNS设置 用DNSpod，快，免费，稳定。注册DNSpod，添加域名，如下图设置。 其中A的两条记录指向的ip地址是github Pages的提供的ip如何知道你的github上项目的IP，如下： 去Godaddy修改DNS地址 更改godaddy的Nameservers为DNSpod的NameServers。 总结 之前用的jekell写的，手把手教你建github技术博客by jekyll，也是折腾了几天才做成自己满意的，昨天决定换成hexo，也是花了一天半时间，为了追求更好，必须折腾！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[8种方法加快你的网站访问速度]]></title>
      <url>%2F2016%2F03%2F12%2Ftitle4%2F</url>
      <content type="text"><![CDATA[一、 网站程序中采用DIV+CSS这种模式，不用Table 目前DIV+CSS是主流的编程语言，这与其体积小加载快的优点是密不可分的。主流的网站和CMS采用的也都是这种模式。因此建议大家也采用这种模式来编程，而不要采用原始的Table结构。Table结构不但管理不方便，网页体积也会变大，降低网站的加载速度。 二、 采用Gzip技术对网页进行压缩 采用Gzip技术对网页进行压缩是减少网页体积的一个很好的方式.一般情况下这是需要你的网站空间支持的，像我用的A5的合租主机，压缩率可以达到80%。网页体积小了，自然加载速度就快了。 三、 减少CSS文件数量和体积 在采用DIV+CSS过程中，CSS文件是非常重要的。如果在编写过程中有多个CSS文件，建议将多个CSS文件进行合并，这样可以加快网站加载速度。另外，可以采用专业的网页减肥软件对CSS文件进行减肥，以减少CSS文件的体积。 四、使用CDN加速。 近一年CDN已经在我们个人站长中听的较多，也有很多朋友在使用。CDN的全称是Content Delivery Network，解释为内容分发网络。原理思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。也就是网站加速器，这个需要付费使用的，免费的不是太稳定。 五、优化代码，减少臃肿结构。 如果我们使用较为流行的CMS这方便应该不会有臃肿的代码结构存在，但需要注意的是我们在制作或者选择网站模 板的时候也会存在不合理的结构。我们需要在写模板或者程序的时候使用较为简洁的程序框架，简洁有利于用户体验，也更利于搜索引擎蜘蛛的爬行和抓取。 六、减少图片大小和数量。 我们尽量在上传网站图片的时候减少图片的大小和尺寸，可以在上传图片之前对图片进行压缩处理，图片适当尺码即可，不要过大。图片仅仅是网站的点缀，而不需要都是图文。同时，我们也尽量避免使用大量的视频或者音频内容。 七、减少JavaScript脚本文件，尽量存放在一个文件中。 尽量外部调用JS代码，不要放在网页中，更不要远程调用外部的JS代码。例 如Google建议您加载在HEAD标签的分析。您也可以尝试结合的JavaScript和压缩他们更快地加载。有些时候我们在头部的CSS，JS代码太 多，导致中间内容部分加载太慢。所以尽量减少头部的代码。 八、运用静态的HTML页面 众所周知，ASP、PHP、JSP等顺序完成了网页信息的静态交互，运转起来确实十分方便，由于它们的数据交互性好，能很方便地存取、更改数据库的内容，但是这类顺序也有本人的缺陷，那就是它必需由效劳器先生成HTML页面，然后在“传送”给用户，多了一个步骤，必定会影响到网站的拜访速度，所以笔者建议，在新站开端的时分，在对本人网站的重要调查期内还是采用静态的HTML页面比拟保险。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数声明提升]]></title>
      <url>%2F2016%2F01%2F11%2Ftitle9%2F</url>
      <content type="text"><![CDATA[1、函数声明提升变量可以先使用后定义。js的解析器在运行的时候，会将所有的全局变量提升到最开始的位置，如果使用的时候可以找到这个变量定义。变量声明提升只提升定义，不提升赋值。初始值默认是undefined。 1 var a; 2 console.log(a); 3 a = 12; 函数声明提升：函数可以先调用，后定义。解析器在程序最开始，将全局范围内定义的函数声明提升到代码最前面，声明的时候提升的就是那个变量名指针，总能够根据函数名找到这个函数的圆型。 1 //先调用 2 fun(); 3 //后定义 4 function fun(){ 5 console.log(1); 6 } 函数声明头提升是强制性的：无视if语句以及for循环。 函数的另外一种定义方式：函数表达式的定义，不会进行函数声明提升，它进行的是变量的声明提升。变量声明提升只提升定义 ，不提升函数赋值，里面存的undefined，给调用函数方法，出现引用类型错误。 1 fun1(); 2 var fun1 = function(){ 3 console.log(2); 4 } 对比：同一个变量名给函数和变量，看顺序。变量写在后面，覆盖掉前面的函数名。 1 function fun(){ 2 console.log(1); 3 } 4 var fun = function(){ 5 console.log(2); 6 } 7 fun(); 函数声明优先于变量声明：同一个标识符，给变量和函数，在定义提升的时候，会将这个标识符优先给函数使用。 1 //先调用 2 3 fun(); 4 //后定义 5 function fun(){ 6 console.log(1); 7 } 8 var fun = function(){ 9 console.log(2); 10 } 11 fun(); 特殊情况解释：函数在定义的时候，进行强制性的声明提升，定义过程已经被提升到代码最前面了，后面再遇到定义的代码，直接忽视。后面定义的变量会遮盖掉这个定义。 1 var fun = function(){ 2 console.log(2); 3 } 4 function fun(){ 5 console.log(1); 6 } 7 fun(); 注意：尽量不要用同一个标识符给变量和函数，定义函数时不要使用函数表达式的方式，用函数关键字的方式。 2、作用域2.1 概述 在函数内定义的变量不能从函数之外的任何地方取得，变量仅仅在该函数的内部有定义。因为我们的函数关住了变量的作用域（定义域）。 JS的作用域：没有块级作用域{}，唯一关住作用域的结构就是函数。在函数内部定义的变量就是函数内部的局部变量，只能在函数内部调用，在外部调用会出现错误。 1 //函数关住作用域，内部定义的是局部变量 2 function fun(){ 3 var a = 1; 4 console.log(a); 5 } 6 fun(); 7 console.log(a); 全局变量：从广义上讲，是一个最外层的局部变量，作用域是全局，所以叫做全局变量。可以在全局范围内都访问到这个变量。 1 var b = 2; 2 function fun(){ 3 var a = 1; 4 console.log(a); 5 console.log(b); 6 } 7 fun(); 原理：全局变量语句没有任何限制，只要遇到就会生成一个变量，在任何地方是能找到。局部变量是声明在函数内部的，函数定义时，内部语句并没有执行，没有定义成这个变量，在函数执行的瞬间，立即定义了一个局部变量，执行完之后，这个变量被立即销毁，从外部找不到这个变量的定义，不能调用。 2.2作用域链 函数内部在调用一个变量的时候，查找的路径问题：当遇见一个变量时，JS引擎会从其所在的作用域依次向外层查找，查找会在找到第一个匹配的标识符的时候停止。在多层嵌套的作用域中可以定义同名的标识符，发生“遮蔽效应”。 1 var a = 1; 2 function outer(){ 3 var a = 2; 4 function inner(){ 5 //var a = 3; 6 console.log(a); 7 } 8 inner(); 9 } 10 outer(); 如果函数内部定义变量时，没有写var关键字，认为我们自动在全局进行了变量的声明，我们创建的不在是局部变量，而是全局变量。会造成一个全局污染。 1 var a = 1; 2 function outer(){ 3 a = 2; 4 function inner(){ 5 //var a = 3; 6 console.log(a); 7 } 8 inner(); 9 } 10 outer(); 11 console.log(a); 在全局定义变量，忘了写var关键字，只要有赋值，变量会自动在全局进行声明。 1 b = 3; 2 console.log(b); 建议：任何时候定义变量都要写var关键字，避免全局污染。 2.3 函数的参数 函数的参数是一个局部变量。在函数内部可以正常使用。在函数外部不能访问函数参数这个变量。 1 function fun(a,b){ 2 a = 1; 3 b = 4; 4 console.log(a + b); 5 } 6 fun(); 7 console.log(a); 实际工作中如果能封装函数，用到的变量，尽量定义在函数内部，不会影响其他的函数或者全局变量。 2.4 全局变量 全局变量尽量少定义，但是它有自己独特的作用：传递、累加。 程序：有两个函数，执行函数加，给我们的一个变量加1，如果执行函数减，让我们的这个变量减1.两个函数控制同一个变量。 传递：在不同的函数之间进行通信，函数都能使用，必须使用全局变量。 1 //全局变量，可以让任何函数使用，通信 2 var a = 1; 3 function plus(){ 4 a++; 5 return a; 6 } 7 function minus(){ 8 a--; 9 return a; 10 } 11 console.log(plus()); 12 console.log(plus()); 13 console.log(plus()); 14 console.log(plus()); 15 console.log(minus()); 16 console.log(minus()); 17 console.log(minus()); 如果一个函数需要累加一个变量的值，多次执行，值依次累加的。不能使用局部变量，因为每次初始值都会被重置。 累加：全局变量会将变化的值存起来，以备下次使用。 1 //全局变量。，累加功能 2 var a = 1; 3 function sum(){ 4 a++; 5 return a; 6 } 7 console.log(sum()); 8 console.log(sum()); 9 console.log(sum()); 10 console.log(sum()); 2.5 函数的作用域 函数也有作用域，就是它定义的那个环境，如果定义在另一个函数内，它也只能在这个函数内部调用，在函数外面调用时引用错误。 1 function sum(a){ 2 return ++a; 3 } 4 //函数定义在另一个函数内部，在外面是访问不到 5 function outer(){ 6 var a = 1; 7 function inner(){ 8 console.log(sum(a)); 9 } 10 inner(); 11 } 12 outer(); 13 inner(); 3、闭包观察闭包的经典案例： 1 //函数定义在另一个函数内部，在外面是访问不到 2 function outer(){ 3 var a = 1; 4 function inner(){ //只能在定义域内使用 5 console.log(a); 6 } 7 return inner; //返回值得到一个inner函数的定义 8 } 9 // 将函数执行结果赋值给一个变量 10 var fun = outer();//其实将inner函数赋值给了fun 11 //函数如果执行，需要在定义域范围去找变量a。全局没有，正常输出了一个1 12 //执行fun函数，其实是执行指向的那个函数原型，它会在自己定义的作用域内执行 13 // inner定义时作用域内有一个a = 1，inner函数记住了这个定义域 14 // 哪怕在outer函数外面使用inner的时候，我也可以访问到a的定义 15 // console.log(typeof fun); 16 // console.log(fun); 17 fun(); 每个函数天生就是一个闭包。函数在定义时，会记住自己的作用域环境以及内部的语句，将外部环境和内部语句组成了一个密闭的环境，就是闭包。 闭包不需要特殊的结构，只是会通过特殊结构来观察函数的这一性质。案例观察： 1 function outer(x){ 2 function inner(y){ //如果执行函数outer，才会定义inner 3 console.log(x + y); 4 } 5 return inner; //一定不要加小括号，如果加了，就立即执行 6 } 7 var i = outer(3); //inner函数定义的位置，环境x = 3 8 // x = 3; 9 // i = function inner(y){ 10 // console.log(x + y); 11 // } 12 console.log(i); 13 i(5); 1 function fun1(m,n){ 2 function fun2(m){ 3 console.log(m + n); 4 } 5 return fun2; 6 } 7 var f = fun1(3,4);//fun2定义的位置 8 f(6); 函数这个闭包里的变量并不是一成不变，可以通过函数调用发生一些变化。 1 function outer(){ 2 var i = 9; 3 function inner(){ 4 return i++; 5 } 6 return inner; 7 } 8 var inn = outer(); //新建了一个函数，函数是inner，赋值给了变量inn 9 console.log(inn()); 10 console.log(inn()); 11 console.log(inn()); 函数定义一次，可以进行多次调用。我们可以认为，每次重新定义，都会产生新的闭包。新的闭包指的是，语句全新，所处环境也是全新的。 1 function outer(){ 2 var i = 9; 3 function inner(){ 4 return i++; 5 } 6 return inner; 7 } 8 var inn = outer(); //新建了一个函数，函数是inner，赋值给了变量inn 9 var inn2 = outer(); //新建了一个函数，函数是inner，赋值给了变量inn2 10 console.log(inn()); 11 console.log(inn()); 12 console.log(inn()); 13 console.log(inn2()); //新的函数，闭包是全新的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax中的GET请求和POST请求]]></title>
      <url>%2F2015%2F12%2F09%2Ftitle41%2F</url>
      <content type="text"><![CDATA[1、GET请求GET请求参数在URL中，所以参数非常好携带。GET请求没有上行报文体，所以send里面是null。 xhr.open(&quot;get&quot;,&quot;check.php?username=考拉&amp;age=12&quot;,true); xhr.send(null); 研究两个事情：字符转码的问题、用JSON来转为query string。 我们观察一个事情，此时在地址栏中输入你好： 复制出来就是： http://127.0.0.1/test.txt?%E4%BD%A0%E5%A5%BD 也就是说中文汉字就是：%AA%AA%AA 其中AA是一个两位16进制数字。 这个叫做URI转码（Uniform Resource Identifier，统一资源标识符），URI和URL差不多，只不过URL强调的是地址，URI强调的是具体的写法。 因为网址只能是英语字符和数字，不能是中文、日语、韩语、阿拉伯文等等，所以URI就想了个办法，用16进制数字来表示非英语文字。 JavaScript内置了转码的函数，各个浏览器兼容很好： 从中文 → URI编码：encodeURIComponent(“我爱你”)URL编码 → 中文：decodeURIComponent(“%E4%BD%A0%E5%A5%BD”) 此时任何后台语言都不需要再次解码就能识别标准URI编码。所以你要知道这个东西不是密码，就是在传输过程中为了防止非英语文字变形，用的临时编码。 &lt;?php $ciyu = $_GET[&quot;ciyu&quot;]; echo $ciyu; ?&gt; 为了防止传输过程中变形，所以我们的Ajax程序要： xhr.open(&quot;get&quot;,&quot;check.php?yonghuming=&quot; + encodeURIComponent(yonghuming) + &quot;&amp;age=&quot; + encodeURIComponent(12)); 再来研究一个事情，能不能写一个函数，接受一个JSON，返回query string。比如传入： { &quot;yonghuming&quot; : &quot;小明&quot;, &quot;age&quot; : 12, &quot;sex&quot; : &quot;男&quot; } 返回 &quot;?yonghuming=%E5%B0%8F%E6%98%8E&amp;age=12&amp;sex=%E7%94%B7&quot; 函数很好写，利用数组的join方法，是个神器！一旦你遇见让你返回字符串，然后字符串之间有符号，开头、结尾没有符号，就要想到join方法。 function changeJSON2QueryString(JSON){ var temp = []; for(var k in JSON){ temp.push(k + &quot;=&quot; + encodeURIComponent(JSON[k])); } return temp.join(&quot;&amp;&quot;); } 所以现在我们Ajax的open语句可以这么玩儿： var querystring = changeJSON2QueryString({ &quot;yonghuming&quot; : &quot;小明&quot;, &quot;age&quot; : 12, &quot;sex&quot; : &quot;男&quot; }); xhr.open(&quot;get&quot;,&quot;check.php?&quot; + querystring , true); 2、POST请求POST请求是通过request报文体来传输，所谓open简单，send里面有内容。PHP程序需要我们加上一个Request Header中的Content-type为普通表单，才能在后台用$_POST[]识别。 任何一个post的表单的上行报文头里面，都有这样的K-V对儿： Content-Type:application/x-www-form-urlencoded 所以我们在Ajax中也要设置（今后遇见node.js就不用设置）： xhr.open(&quot;post&quot;,&quot;dopost.php&quot;,true); xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); xhr.send(&quot;yonghuming=%E5%B0%8F%E6%98%8E&amp;age=12&amp;sex=%E7%94%B7&quot;); 3、JSON的识别JSON是一个通用信息交换格式，比如PHP工程师，可以使用json_encode()函数把别名数组转为标准JSON： &lt;?php $arr = array( &quot;result&quot; =&gt; array( array(&quot;xingming&quot; =&gt; &quot;小明&quot; , &quot;nianling&quot; =&gt; 12 , &quot;xingbie&quot; =&gt;&quot;男&quot;), array(&quot;xingming&quot; =&gt; &quot;小红&quot; , &quot;nianling&quot; =&gt; 15 , &quot;xingbie&quot; =&gt;&quot;女&quot;), array(&quot;xingming&quot; =&gt; &quot;小刚&quot; , &quot;nianling&quot; =&gt; 13 , &quot;xingbie&quot; =&gt;&quot;男&quot;) ) ); echo json_encode($arr); ?&gt; JSON显示在页面上的时候，不方便我们看JSON的结构，此时推荐安装一个浏览器插件，叫做JSONView。 Chrome应用商店打不开，并且网上下载的都不适合现在的Chrome版本。所以我们可以安装QQ浏览器，它的内核也是Chrome内核，中国人没有自己的浏览器内核。在应用中心中，安装“JSONView”。 安装完插件之后，访问JSON页面： 4、JSON识别我们使用Ajax读取一个JSON的时候，此时明明是JSON，但是读进来是String。此时就要把String变为JSON。 $.get(&quot;04_JSON.php&quot;,function(data){ console.log(data); console.log(typeof data); }); 一共有三种方法。 方法1：使用内置构造函数JSON的方法 var dataobj = JSON.parse(data); console.log(dataobj); console.log(typeof dataobj); JSON是系统内置的构造函数，和Number、String、Array一样。它IE8才开始有，IE6、7不支持JSON内置构造函数。 它一共就有两个方法： JSON.parse() 字符串 → 对象 JSON.stringify() 对象 → 字符串 JSON.parse()函数里面的字符串必须是标准JSON，必须有双引号引用所有的key。 方法2：使用eval语句 eval语句可以把字符串变为语句，是JS中的一个特色。 var str = &quot;alert(1+2+3)&quot;; //字符串 eval(str); //字符串变为了语句 弹出6。 eval()一般都是当做奇淫技巧使用，注意任何文本框都需要用正则表达式阻止eval。比如让你输出一个用户名，你叫做eval(“setInterval(function(){alert(‘哈哈’);},1)”); 极其危险！ 我们可以利用eval语句来把JSON字符串变为对象的JSON，但是此时要注意：如果直接eval一个JSON字符串，会报错： 语法要求必须用圆括号括起来： 所以： var dataobj = eval(&quot;(&quot; + data + &quot;)&quot;); console.log(dataobj); console.log(typeof dataobj); 方法3：借助Function函数 var sum = new Function(&quot;a&quot;,&quot;b&quot;,&quot;return a + b&quot;); alert(sum(3,4)); Function你仔细琢磨，也可以把字符串变为语句啊！ var dataobj = (new Function(&quot;return &quot; + data))(); console.log(dataobj); console.log(typeof dataobj); 5、复杂JSON的JS处理现在拿一个JSON举例子： 请用Ajax读取它，在HTML页面上枚举所有点击数大于1000的文章标题。 &lt;script type=&quot;text/javascript&quot;&gt; $.get(&quot;system/baijiayanshi.txt&quot;,function(data){ //把字符串转为真正的JSON var dataobj = eval(&quot;(&quot; + data + &quot;)&quot;); //如鱼得水，“JSON回家了” var arr = dataobj.data.list; for(var i = 0 ; i &lt; arr.length ; i++){ if(arr[i].hotcount &gt; 1000){ $(&quot;&lt;p&gt;&quot; + arr[i].m_title + &quot;【点击数：&quot; + arr[i].hotcount + &quot;】&lt;/p&gt;&quot;).appendTo(&quot;#box&quot;); } } }); &lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[call和apply]]></title>
      <url>%2F2015%2F11%2F01%2Ftitle22%2F</url>
      <content type="text"><![CDATA[call和apply了解普通函数内部有没有this关键，指向是谁。 1 var box = document.getElementById(&quot;box1&quot;); 2 animate(box,{&quot;left&quot;:300},1000,function(){ 3 console.log(this); 4 }); 5 function move(){ 6 console.log(this); 7 } 普通函数（事件函数除外）内部的this默认指向window对象。 call方法和apply方法能够帮我们制定函数内部this的指向。 1 fun.call(obj); 2 fun.apply(obj); obj就是内部this规定的指向元素。 1 //作用：第一个执行函数，第二个指定this。 2 move.call(box); 3 move.apply(box); 两种方法都能用。 区别：就是函数传参的方式不同。 1 fn.call(obj,参数1,参数2,参数3……); 2 fn.apply(obj,[参数1,参数2,参数3……]);3 1 // call方法直接传递 2 sum.call(box,1,2,3); 3 //apply必须将参数放在一个数组 4 sum.apply(box,[2,3,4]); 对封装的函数制定内部的回调函数的this。 1 move(box1); 2 function move(obj){ 3 animate(obj,{&quot;left&quot;:400},1000,function(){ 4 //运动执行完，回调函数内执行的语句 5 this.style.background = &quot;#0f0&quot;; 6 animate(this,{&quot;top&quot;:400},1000,function(){ 7 this.style.background = &quot;#00f&quot;; 8 //在调用运动函数 9 animate(this,{&quot;left&quot;:0},1000,function(){ 10 this.style.background = &quot;#0ff&quot;; 11 //在调用运动函数 12 animate(this,{&quot;top&quot;:100},1000,function(){ 13 this.style.background = &quot;#f00&quot;; 14 move(this); 15 }); 16 }); 17 }); 18 }); 19 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP状态码含义大全]]></title>
      <url>%2F2015%2F10%2F26%2Ftitle12%2F</url>
      <content type="text"><![CDATA[大家都知道404是木有找到东西，301是定义转向，但又有几个人知道206或者307呢？本文就给大家列出了各种HTTP状态码的含义，适合长期收藏。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端网页开发经验与心得]]></title>
      <url>%2F2015%2F09%2F19%2Ftitle3%2F</url>
      <content type="text"><![CDATA[智能手机发展确实很迅速，像今年，我的大部分工作就都在移动端网页上。 再往前些年，看到的手机版/移动版网页，限制于浏览器与手机性能，2g网络速度等 网页设计无非是蓝、黑、白，界面单调，并且要尽可能的设计简单。 现在情况就大不相同了，软件上webkit内核浏览器大行其道，硬件突飞猛进，网速来说，4g正炒得火热。 下面就和大家分享一下我的一些移动端网页设计经验与心得。 1、分辨率 这应该是移动端网页最关心的问题了，因为移动设备五花八门，各种分辨率都有。要想在这些设备上都能有良好的浏览体验，得花一番功夫。 使用viewport：这已经是移动端网页的必备了，它可以设定页面的宽度，是否允许缩放等等。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;/&gt; 一般设置width=device-width，就是设置为设备的屏幕宽度，当然也可以是具体数值 百分比与max(min)-width使用：移动端网页不仅分辨率不一，而且随时可以横竖屏切换，所以百分比宽度设定非常必要，再配合max(min)-width限制最大(小)宽度，能有效的适应各种分辨率，若为此还有特别需求，可看下一条，”使用Media Queries” 使用Media Queries，这也是响应式web设计的一部分 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style1.css&quot; media=&quot;screen and (min-width: 640px)&quot;&gt; 这里的意思就是在大于640px的屏幕宽度下，使用style1样式，也可以写在样式内部，如： @media screen and (min-width: 640px){ .d1{background:#ccc;} } 2、内容与缓存 虽才说到现在4g正炒得火热，但不可否认移动设备网络环境上的局限性，所以还是有必要对此做一些处理。 使用manifest缓存 &lt;html manifest=&quot;/mobile.manifest&quot;&gt; 在html上添加manifest，其中文件格式内容如： CACHE MANIFEST ##需要离线的内容 CACHE: Script/jquery.js Script/gameconfig.js Image/home.png Image/logo.png ##总是访问网络的内容 NETWORK: * ##访问A失败时访问B FALLBACK 浏览器将缓存chache内所有的内容，并且可以离线访问，只要文件发生任何改变都将会重新读取并刷新全部缓存，所以更改注释是个更新缓存的好方法这里要注意的是 添加了manifest的当前网页也会被缓存 所以推荐的方式是页面缓存，页面动态内容全部用ajax获取，所以在移动网站项目设计开始就要注意这个问题 页面中添加iframe 然后子页面引用manifest想达到缓存资源而不缓存当前页面内容，是无效的。 尽可能使用css样式来代替图片，由于移动端浏览器对css3的支持，使得以前很多图片可以用样式来代替]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈设计师配色技巧]]></title>
      <url>%2F2015%2F07%2F09%2Ftitle2%2F</url>
      <content type="text"><![CDATA[一、橙色 使用了高亮度橙色的站点通常都会给人一种晴朗新鲜的感觉，而通过将黄色、黄绿色等类似颜色与成色搭配使用，通常都能得到非常好的效果。同时，中等色调的橙色类似于泥土的颜色，所以也经常用来创造自然的氛围。 橙色是可以通过变换色调营造出不同氛围的典型颜色，它既能表现出青春的活力也能够实现沉稳老练的效果，所以橙色在网页配色中的使用范围是非常广泛的。 Color Point:橙色通常会给人一种朝气活泼的感觉，它通常可以是原本抑郁的心情豁然开朗。 在东方文化中，橙色象征着爱情和幸福。充满活力的橙色会给人健康的感觉，且有人说橙色可以提高厌食症患者的食欲。有些国家的僧侣主要穿着橙色的僧侣服，他们解释说橙色代表着谦逊。 二、黄绿色 黄绿色时而能够表现出自然的感觉，时而能够表现出未来虚幻的感觉。 原本这两种印象之间有很大的差异，但黄绿色就像穿越时间隧道那样能够自由自在地表现出这两种截然不同的感觉。 在网页中，黄绿色通常与蓝色搭配使用。总的来说，黄绿色主要用于表现温暖亲切的感觉或高科技神秘虚幻的感觉。 Color Point: 黄绿色和草绿色都会让人联想起大自然。黄绿色同时含有黄色和绿色两种颜色的共同特点，也就是说，黄绿色既能表现出黄色的温暖，也能表现出绿色的清新。在社会上，儿童和年轻人比较喜欢黄绿色。 三、绿色 绿色也是在网页中使用最为广泛的颜色之一。 因为它本身具有一定的与健康相关的感觉，所以也经常用于与健康相关的站点。绿色还经常用于一些公司的公关站点或教育站点。 当搭配使用绿色和白色时，可以得到自然的感觉。 当搭配使用绿色与红色时，可以得到鲜明且丰富的感觉。 同时，一些色彩专家和医疗专家们提出绿色可以适当缓解眼部疲劳。 Color Point: 人们看到绿色的时候，第一反应就会想到大自然。很多人都说绿色是大自然的颜色，绿色也代表着大自然中的每一个可贵的生命。大自然给了我们新鲜的氧气，而绿色也能使我们的心情变得格外明朗。当需要揭开心中的抑郁时，当需要找回安详与宁静的感觉时，回归大自然是最好的方法。 四、黄色 黄色是在站点配色中使用最为广泛的颜色之一，因为黄色本身具有一种明朗愉快的效果，所以能够得到大部分人的认可。 黄色在从儿童站点直至门户型网站等几乎每一个角落中都找到了自己的发挥空间，通过结合紫色、蓝色等颜色可以得到温暖愉快的积极效果。 高彩度的黄色与黑色的结合可以得到清晰整洁的效果，这种配色实例在网页设计中经常可以见到。 采用同一色调的深褐色与黄色的搭配，可以表达一种成熟的城市时尚的感觉。 Color Point: 黄色是明亮的且可以给人甜蜜幸福感觉的颜色。 在很多艺术家的作品，黄色都用来表现喜庆的气氛和富饶的景色。同时黄色还可以起到强调突出的作用，这也是使用黄色作为路口指示灯的原因。黄色因为具有诸多以上的特点，所以在我们的日常生活中随处可见。 黄色是在站点配色中使用最为广泛的颜色之一，因为黄色本身具有一种明朗愉快的效果，所以能够得到大部分人的认可。 黄色在从儿童站点直至门户型网站等几乎每一个角落中都找到了自己的发挥空间，通过结合紫色、蓝色等颜色可以得到温暖愉快的积极效果。 高彩度的黄色与黑色的结合可以得到清晰整洁的效果，这种配色实例在网页设计中经常可以见到。采用同一色调的深褐色与黄色的搭配，可以表达一种成熟的城市时尚的感觉。Color Point: 黄色是明亮的且可以给人甜蜜幸福感觉的颜色。 在很多艺术家的作品，黄色都用来表现喜庆的气氛和富饶的景色。同时黄色还可以起到强调突出的作用，这也是使用黄色作为路口指示灯的原因。黄色因为具有诸多以上的特点，所以在我们的日常生活中随处可见。 五、青绿色 青绿色会给人带来凉爽清新的感觉，且青绿色既可以使人原本兴奋的心情冷静下来，也可以使人原本沉静的心情活跃起来。 使用青绿色的站点也是随处可见。 青绿色与黄色、成色等颜色搭配可以营造出可爱亲切的氛围。 青绿色与蓝色、白色等颜色搭配可以得到清新爽朗的效果。 Color Point: 青绿色可以说是草绿色的健康和蓝色的清新感觉的结合体，但在自然界中它并不多见，会给人较强的人工制作的感觉。这也使它在保留自然颜色原有特点的同时，有为其赋予了特殊的效果。 色彩和心理学家分析说，青绿色可以给一个心情低迷的人一种特殊的信心与活力。 六、蓝色 很多站点都在使用蓝色与青绿色的搭配效果。最具代表性的蓝色物体莫过于海水和蓝天 ，而这两种物体都会让人有一种清凉的感觉。 高彩度的蓝色会营造出一种整洁轻快的印象。 低彩度的蓝色会给人一种都市化的现代派印象。 蓝色与绿色、白色的搭配在我们的现实生活中也使随处可见的，它的应用范围几乎覆盖了整个地球。 主颜色选择明亮的蓝色，配以白色的背景和灰亮的辅助色，可以使站点干净而整洁，给人庄重、充实的印象。 蓝色、青绿色、白色的搭配可以使页面看起来非常干净清澈。 Color Point: 蓝色会使人自然地联想起大海和天空，所以也会使人产生一种爽朗、开阔、清凉的感觉。作为冷色的代表颜色，蓝色会给人很强烈的安稳感，同时蓝色还能够表现出和平、淡雅、洁净、可靠等多种感觉。 低彩度的蓝色主要用于营造安稳、可靠的氛围，而高彩度的蓝色可以营造出高贵的严肃的氛围。 七、蓝紫色 蓝紫色在色相环中位于蓝色和紫色之间，所以它也蕴含着紫色的一些神秘感。 低亮度的蓝紫色显得很有分量，而高亮度的蓝紫色显得非常高雅。在网页中，蓝紫色通常与蓝色一起搭配使用。 Color Point: 蓝紫色可以用来创造出都市化的成熟美，且蓝紫色可以使心情浮躁的人冷静下来。明亮的色调直至灰亮的蓝紫色有一种与众不同的神秘美感。 八、紫红色 清澈（Pale）色调的紫红色又称粉红色，粉红色主要用于包含少女在内的女性站点。因为从明亮（Bright）到苍白（Very Pale）色调的粉红色能够表现出可爱、乖巧的感觉，所以有人也会用作背景色或在页面中大范围地使用该颜色。 紫红色并不能随意在所有的站点中使用，但使用恰当的紫红色会给人留下深刻的印象。 白色、粉红色、天蓝色的颜色搭配，是最受少女欢迎的配色方案。 高彩度的紫色和粉红色之间的搭配通常都能得到较好的效果。 Color Point: 紫红色市非常女性化的颜色，它给人的感觉通常都是浪漫、柔和、华丽、高贵优雅，特别是粉红色可以说是女性化的代表颜色。高彩度的紫红色可以表现出超凡的华丽，而低彩度的粉红色可以表现出高雅的气质。 九、黑色和白色 黑色与白色表现出了两个极端的亮度，而这两种颜色的搭配使用通常可以表现出都市化的感觉。 只要能够合理地搭配使用黑色与白色，甚至可以做到比那些彩色的搭配更生动的效果。 黑色与白色的搭配通常用于现代派站点中，通过合理地添加一些彩色还可以得到突出彩色的效果。 Color Point: 白色有很强烈的感召力，它能够表现出如白雪般的纯洁与柔和。 黑色也有很强大的感染力，它能够表现出特有的高贵，且黑色还经常用于表现死亡和神秘。 因为黑色和白色的搭配有一种特殊的严肃感，所以还经常用于如结婚典礼等庄重的场合]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见字符串算法]]></title>
      <url>%2F2015%2F01%2F14%2Ftitle28%2F</url>
      <content type="text"><![CDATA[常见字符串算法1、短横变驼峰把单词border-left-color变为borderLeftColor。 此时有两种方法： 方法1：border-left-color用字符串的split方法变为数组：[“border”,”left”,”color”]，然后遍历这个数组第1项开始的每项，把首字母toUpperCase()变为大写然后与剩余字母连接，然后join到一起，就是borderLeftColor。 // 短横变驼峰函数 function change(str){ //拆为数组 var strArr = str.split(&quot;-&quot;); &lt;!-- more --&gt; //遍历数组 for(var i = 1 ; i &lt; strArr.length ; i++){ var chars = strArr[i]; //将数组的这一项的字符串变为首字母变为大写，与剩余字母做拼接 strArr[i] = chars[0].toUpperCase() + chars.slice(1); } //拼接 return strArr.join(&quot;&quot;); } 方法2：正则表达式。border-left-color用正则表达式去replace替换，替换什么？替换所有(-字母)变为大写字母。 var str = &quot;我爱周杰伦，周杰伦很帅，我要和周杰伦生猴子&quot;; str = str.replace(/周杰伦/g,&quot;杨洋&quot;); console.log(str); var str = &quot;我买了一个手机3000元，电脑5000元，电饭锅100元。今天很热，18度。&quot;; str = str.replace(/(\d+)元/g,function(match,$1,index){ return parseInt($1 / 6) + &quot;美元&quot;; }); console.log(str); var str = &quot;border-left-color&quot;; str = str.replace(/\-(\w)/g,function(match,$1){ return $1.toUpperCase(); }); console.log(str); 2 、寻找连续三项相同字符串现在给你一个字符串，判断里面有没有连续三位或者三位以上相同，如果有，就返回下标数组。 比如： “aabbbccddddee” 返回[2,3,4,7,8,9,10]。 双指针法。在字符串的题目中，基本99%都能用双指针法，比如最大连续相同子串、最大连续重复子串等等，都能用双指针法。 &lt;script type=&quot;text/javascript&quot;&gt; var str = &quot;aabbbccddddee&quot;; //位置是0、1 var i = 0; var j = 1; //结果 var result = []; while(i &lt; str.length){ if(str[i] != str[j]){ //判断是不是到了3位 if(j - i &gt;= 3){ //为位号推入数组 for(var m = i; m &lt;= j-1 ; m++){ result.push(m); } } //i追上j，j后移一位 i = j; } //不管怎么样j都要后移 j++; } console.log(result); &lt;/script&gt; 3 给数字加上千分位符输入12345678901，返回”12,345,678,901”。 数组和字符串的相互转换方法很好用，要敏感一些！实际上就是[12,345,678,901]进行join(“,”)就是结果。所以问题就简化为把12345678901这个数字拆分为数组！数组长度11。 找找规律： 12345678901 str.slice(-3) → 很特殊，没有第二个参数 12345678901 str.slice(-6,-3) 12345678901 str.slice(-9,-6) 12345678901 str.slice(-12,-9) 程序： &lt;script type=&quot;text/javascript&quot;&gt; var num = 12433245245432; //除了null、undefined之外的任何字面量都有toString()方法，表示变为字符串 var length = num.toString().length; //循环终点 var end = -Math.ceil(length / 3) * 3; //结果数组，把特殊的末尾三位放入数组 var result = [num.toString().slice(-3)]; //遍历-6、-9、-12、-15…… //截取的是slice(-6,-3) slice(-9,-6) slice(-12,-9) for(var i = -6 ; i &gt;= end ; i-=3){ result.unshift(num.toString().slice(i,i+3)); } //把数组变为字符串 console.log(result.join(&quot;,&quot;)); &lt;/script&gt; 还可以用正则表达式，我们慢慢推导： \B是一个特殊的正则的东西，表示字母边界，非单词边界。\b表示单词边界。 &lt;script type=&quot;text/javascript&quot;&gt; var str = &quot;abc,adsf haha xixi&quot;; str = str.replace(/\B/g,&quot;★&quot;); console.log(str); &lt;/script&gt; 出现★的地方就是字母边界 然后说正则中的(?=)语法，表示定语从句，位置描述。 比如，我们想替换字符串中所有后面是“你”字的“爱”字. var str = &quot;我爱你，你却爱着他&quot;; str = str.replace(/爱(?=你)/g,&quot;★&quot;); console.log(str); 替换字符串中所有后面有“3位数字”的字母\B ： var str = &quot;12324324324&quot;; str = str.replace(/\B(?=\d{3})/g,&quot;★&quot;); console.log(str); 比较乱，因为我们没有限制边界 替换字符串中所有后面到单词结尾有“3位数字”的\B ： var str = &quot;12324324324&quot;; str = str.replace(/\B(?=\d{3}$)/g,&quot;★&quot;); console.log(str); 替换字符串中所有后面到单词结尾有一个或多个“3位数字”的\B ： var str = &quot;12324324324&quot;; str = str.replace(/\B(?=(\d{3})+$)/g,&quot;★&quot;); console.log(str); 这就是答案，只需要把★改为逗号即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【精】web前端工程师必备技能汇总]]></title>
      <url>%2F2014%2F12%2F19%2Ftitle1%2F</url>
      <content type="text"><![CDATA[项目起源 web前端知识结构图。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cookie和Session]]></title>
      <url>%2F2014%2F12%2F13%2Ftitle44%2F</url>
      <content type="text"><![CDATA[1、Cookie就是一个Response头部的一个K-V对儿。 当服务器下发了一个Set-Cookie，今后每次request浏览器都会带着相同的cookie上去。 HTTP是无连接的，当你第一次访问一个服务器的时候，第二次再来到这个服务器（可能就10s之后），服务器此时的HTTP和第一次毫无关系的。对于服务器来说，HTTP是两次，两次之间没有持久保持连续。 setcookie函数就是设置cookie的，有三个参数：k、v、过期时间 &lt;?php setcookie(&quot;xingming&quot;,&quot;kaola&quot;,time()+3600); ?&gt; 第一次访问页面的时候，我们关心的是Response Headers： 里面有一个Set-Cookie，值为 xingming=kaola; expires=Fri, 27-Jan-2017 12:38:36 GMT 表示Cookie的值，和过期时间。 今后的每一次访问同一个域名下的任何网站，都可以看见Request Header中携带了相同的Cookie： 有什么用！可以方便让： ① 浏览器记录服务器曾经给我们的信息； ② 服务器记录用户提供的信息 在本地，我们可以轻松使用document.cookie来使用cookie。 此时你会得到一个String，任何的cookie会被链接成为一个String： console.log(document.cookie); 转码： var c = decodeURIComponent(document.cookie); 此时仍然是字符串 变为数组，用;来拆分： var arr = c.split(&quot;;&quot;); 遍历这个数组，继续用=来拆分为数组： var result = {}; for(var i = 0 ; i &lt; arr.length ; i++){ var t_arr = arr[i].split(&quot;=&quot;); console.log(t_arr); } 变为对象： for(var i = 0 ; i &lt; arr.length ; i++){ var t_arr = arr[i].split(&quot;=&quot;); result[trim(t_arr[0])] = t_arr[1]; } console.log(result); 他的值不是object，所以eval： var infoobj = eval(&quot;(&quot; + result[&quot;iqianduan.cn&quot;] + &quot;)&quot;); 自动填入表单 //如果xingming和nianling不是空，则默认填入文本框 if(infoobj.xingming){ document.getElementById(&quot;xingmingTxt&quot;).value = infoobj.xingming; } if(infoobj.nianling){ document.getElementById(&quot;nianlingTxt&quot;).value = infoobj.nianling; } 总结一下： **&gt; cookie的产生仰赖服务器的一次Set-Cookie。今后每一次的访问，我们的request头部都会携带cookie这个东西。 其实如果不借助服务器，我们浏览器自己能不能发送带有cookie的头部呢，能！就是xhr.setRequestHeader()，不过这个东西没有意义！** Cookie的性质 ① Cookie不安全，可以在任何时候被浏览器的network面板被查看。所以千万不要试图让服务器下发密码等机密信息。可以被自由修改！ ② Cookie是文件格式存储。 ③ 有超时的限制，可以自由设置存活时间。 2、Session有cookie，让服务器发起Set-Cookie: username=且试天下Always;login=true; 此时我们的浏览器今后访问每一个这个网站的页面都会带着cookie上去。服务器识别cookie，一看就知道你登录了！ 但是，cookie可以被自由篡改！也就是说，我想登陆谁的号，就登录了谁的号！ 有人发明了一个机制，不要通过cookie下发明文信息，发送一个随机乱码下去！服务器同时在内存中保存这个随机数字的人的各种信息。如果有人带这个随机乱码上来，一定是这个人！ 此时我们把这种特别的cookie叫做SESSION，也叫作会话。也就是说，session就是cookie！是一种特殊的cookie，是不发送明文，而是发送随机乱码的cookie。 服务器下发： &lt;?php //开始session session_start(); $_SESSION[&quot;xingming&quot;] = &quot;小丹尼&quot;; ?&gt; 今后我的每一次访问，都会带着这个码上去。这个吗对于浏览器来说，没有任何意义！但是服务器就是通过这个码来知道你是你的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM操作方法]]></title>
      <url>%2F2014%2F12%2F01%2Ftitle14%2F</url>
      <content type="text"><![CDATA[1、DOM体验DOM（Document Object Model，文档对象模型）描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。这使得JavaScript操作HTML，不是在操作字符串，而是在操作节点，极大地降低了编程难度。编写例子整体感知一下这个事儿。 1 //获得元素 2 var oDiv = document.getElementById(&quot;box&quot;); 3 var oKaola = document.getElementById(&quot;kaola&quot;); 4 //添加点击事件，盒子变色，图片变图 5 oDiv.onclick = function(){ 6 oDiv.style.backgroundColor = &quot;yellowgreen&quot;; 7 oKaola.src = &quot;images/kaola2.jpeg&quot;; 8 } DOM规范在1998年10月制定，称为“DOM1级规范”。随着ECMAScript的升级，DOM也发展出了2级规范、3级规范。另外，早于1998年的DOM也有事实上的标准，我们称为0级规范。 DOM对很多东西做了抽象，提供了丰富的API：取得元素、css样式、事件、运动、元素尺寸位置、节点操作。每个知识体系都非常庞大，千丝万缕。我们今天的课程，把一些线头都掐出来，日后的课程深入研究每个线头。 2、获取元素JavaScript通过document对象表示文档，它表示整个页面。它有很多属性和方法，包含了绝大多数多页面的特征和操作。学习DOM，说白了就是学习document对象。例如document.title属性，就是页面的标题。 1 document.title = &quot;获取元素&quot;; 2 alert(document.title); DOM操作，往往都是从取得某个（些）HTML元素开始，然后对这个（些）元素进行一些操作。所以得到元素是非常重要的。得到元素的操作可以使用document对象的两个方法来完成： document.getElementById() document.getElementsByTagName() getElementById：get得到 element 元素 by 通过 id id属性值。通过id名字获得某一个元素。 驼峰命名法：一个标识符由多个英文单词组成，首个单词正常小写，从第二个开始每个单词首字符要大写，其他的小写。 JS的书写位置：如果要想获得某一个元素，那么获得之前，元素必须是加载过的。js的书写顺序，需要写在标签后面。 1 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; //标签写在获取元素的前面 2 &lt;script&gt; 3 // document.title = &quot;获取元素&quot;; 4 // alert(document.title); 5 6 //获取div元素 7 var box = document.getElementById(&quot;box&quot;); 8 box.onclick = function(){ 9 box.style.border = &quot;10px solid #0f0&quot;; 10 } 11 &lt;/script&gt; 获取元素语法：直接将获得的这个元素的id属性值写在参数里。名字必须加引号。跟css区别，不需要加#。 错误写法： 1 var box = document.getElementById(&quot;#box&quot;); 正确写法： 1 var box = document.getElementById(&quot;box&quot;); 获得的元素的数据类型。通过检测，得到一个对象类型。 1 console.log(typeof box); 也就是说，我们通过id获得元素本身又是一个对象类型的数据，内部还包含了一些属性和方法。可以对这些元素打点继续调用属性和方法。 注意：id名不能重复。 1 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; 2 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; 3 //id名字不能重复，如果有重复的，只得到第一个 4 var oBox = document.getElementById(&quot;box&quot;); 5 oBox.style.backgroundColor = &quot;#0f0&quot;; id大小写要严格区分，但是在IE6、7中，大小写是不区分的。 IE7及较低版本还有一个怪癖，表单元素name特性也会被当做id。为了避免这个问题，所以页面上的name最好也不要和任何id相同。 3、操作html获取一个html标签之后，得到一个对象类型变量。 可以控制html的属性：得到属性、更改属性。 有两种选择：getAttribute()和setAttribute()方法，或者使用点语法。 点语法： 获得元素属性：直接在元素对象后点语法调用，输出属性值。 1 //获得img标签的src属性 2 console.log(oImg.src); 3 console.log(oImg.id); 4 console.log(oImg.alt); 更改html标签属性：可以通过点语法调用相关属性后，通过等号给这个属性赋值，更改属性值的方法。 1 //通过点语法得到相关属性，等号赋新值 2 oImg.src = &quot;images/kaola2.jpeg&quot;; 3 //不要去更改id属性，id是只读。 第二种方法： 得到属性值getAttribute()，需要得到什么属性，直接将名字写在小括号内。 1 console.log(oImg.getAttribute(&quot;src&quot;)); //得到的就是属性值的字符串 2 console.log(oImg.getAttribute(&quot;alt&quot;)); //得到的就是属性值的字符串 设置属性值setAttribute()，设置属性的新的属性值，直接写在小括号内，用引号包裹。 1 oImg.setAttribute(&quot;src&quot;,&quot;images/kaola.jpg&quot;); 第一个参数：设置属性名，第二个参数：新的属性值，中间用逗号隔开。 区别： ①html标签可以使用自定义属性，自定义属性调用和更改都不能使用点语法实现。getAttribute（）可以获得自定义属性，setAttribute（）可以更改自定义属性。 1 //自定义属性 2 oImg.setAttribute(&quot;kaola&quot;,&quot;yuanxing&quot;); 3 console.log(oImg.kaola); 4 console.log(oImg.getAttribute(&quot;kaola&quot;)); ②点语法调用html属性时，有一些属性名需要进行更改，这些属性名可能是其他的关键字，规避这些名字。getAttribute方法不用规避，直接写原属性名。 class 改为className for 改为htmlFor rowspan 改为rowSpan colspan 改为colSpan 1 //更改一些属性名的写法，只限于点语法 2 console.log(oImg.class); 3 console.log(oImg.className); getAttribute方法不需要改变写法，如果改了反而错。 1 console.log(oImg.getAttribute(&quot;className&quot;)); 2 console.log(oImg.getAttribute(&quot;class&quot;)); ③如果调用style属性得到的还是一个css对象，可以继续打点调用css的样式，遇到复合属性的单一写法，点语法需要些驼峰命名，另外一种方法不需要。 text- font- line- background- border- margin- padding- 1 //console.log(oImg.style.border-color); 2 console.log(oImg.style.borderColor); getAttribute方法直接写css内的命名就行。 ④点语法得到的style属性是一个对象，可以继续打点调用内部的属性。getAttribute方法得到style属性，是一个字符串，不能再继续打点调用。 1 //console.log(oImg.style.border-color); 2 console.log(typeof oImg.style); 3 console.log(typeof oImg.getAttribute(&quot;style&quot;)); 点语法才能继续打点调用css样式属性。 总结：除了自定义属性用getAttribute和setAttribute之外，其他情况都用点语法。 4、操作css通过对一个元素对象打点调用style属性，得到的是css样式的一个对象。可以通过得到css样式的对象，进行css属性的读取和更改。 通过点语法读取和更改的css样式都是行内样式。 1 &lt;img src=&quot;images/kaola.jpg&quot; alt=&quot;这是一只考拉&quot; style=&quot;border:2px solid #f00;&quot; class=&quot;tupian&quot; id=&quot;image&quot; kaola=&quot;bianxing&quot; /&gt; 2 //点语法得到样式都是行内样式，更改的也是行内样式 3 console.log(oImg.style.width); 4 console.log(oImg.style.border); 通过点语法改的css样式属性都是在行内式进行更改的。 1 //更改样式 2 oImg.style.height = &quot;400px&quot;; 语法注意：点语法直接调用。如果给属性赋新值，通过等号赋值，右侧的值必须写在一对儿引号里，css里面怎么写属性值，引号里直接就这么些。 1 oImg.style.height = &quot;400px&quot;; 2 oImg.style.borderColor = &quot;#00f&quot;; innerHTML表示标签内的文本。 input标签有自己的获得方法，点语法直接调用value属性。 1 console.log(oBox.innerHTML); 2 console.log(oTxt.value); 5、事件 DOM0级事件： onclick 单击事件 ondblclick 双击事件 onmouseover 鼠标移上事件 onmouseout 鼠标移出事件 onmousedown 鼠标按下事件 onmouseup 鼠标弹起事件 onfocus 获得焦点事件 onblur 失去焦点事件 onload 加载事件 事件监听：给一个元素去添加事件，如果触发事件就会执行相应的功能。JS在加载的时候，先去整个页面去查看，看谁绑定了事件，引擎就会给这个元素进行监控（监听），监控我们的元素有没有被触发这个事件的动作，如果触发动作，在瞬间执行相应的功能。 语法：给哪个元素绑定事件，就给这个元素对象打点添加对应的事件，用等号给这个事件添加事件函数。 2 box.onmouseover = function(){ 3 事件触发之后要做的事。 4 }; 如果事件被触发，立即执行后面的事件函数，不需要加()调用函数。 6 //获取元素 7 var oImg = document.getElementById(&quot;image&quot;); 8 // 绑定鼠标移上的效果，变图片 9 oImg.onmouseover = function(){ 10 oImg.src = &quot;images/kaola2.jpeg&quot;; 11 }; 调用函数方法：用小括号调用，触发事件执行事件函数。 onclick：单击事件,鼠标单击事件元素触发事件。 5 //鼠标单击事件 6 oImg.onclick = function(){ 7 oImg.style.width = &quot;300px&quot;; 8 }; 4 //鼠标双击事件 5 oImg.ondblclick = function(){ 6 oImg.style.width = &quot;300px&quot;; 7 }; 3 //绑定鼠标移上的效果，变图片 4 oImg.onmouseover = function(){ 5 oImg.src = &quot;images/kaola2.jpeg&quot;; 6 }; 7 //鼠标移出效果，一般与鼠标移上成对出现 8 oImg.onmouseout = function(){ 9 oImg.src = &quot;images/kaola.jpg&quot;; 10 }; 2 //获取元素 3 var oBox = document.getElementById(&quot;box&quot;); 4 //添加鼠标移上和移出事件 5 oBox.onmouseover = function(){ 6 oBox.style.backgroundImage = &quot;url(images/jd2.png)&quot;; 7 }; 8 oBox.onmouseout = function(){ 9 oBox.style.backgroundImage = &quot;url(images/jd1.png)&quot;; 10 }; 5 //添加鼠标按下和弹起事件 6 oBtn.onmousedown = function(){ 7 oBtn.style.backgroundColor = &quot;pink&quot;; 8 }; 9 oBtn.onmouseup = function(){ 10 oBtn.style.backgroundColor = &quot;skyblue&quot;; 11 }; 点击： 松开： 4 //获得焦点事件，输入框清空 5 oTxt.onfocus = function(){ 6 oTxt.value = &quot;&quot;; 7 }; 8 oTxt.onblur = function(){ 9 oImg.src = &quot;images/kaola2.jpeg&quot;; 10 }; onload事件：表示元素加载完之后执行某一个事件函数。 3 //onload加载，图片加载完之后，弹出一句话，加载完了 4 oImg.onload = function(){ 5 alert(&quot;加载完毕&quot;); 6 }; 页面整体加载事件： window.onload:表示页面的所有html标签、css样式都加载完。JS就可以随意书写加载位置。 3 // 只有页面全部加载完了才会触发window.onload 4 window.onload = function(){ 5 //获取元素 6 var oImg = document.getElementById(&quot;image&quot;); 7 var oTxt = document.getElementById(&quot;txt&quot;); 8 //绑定鼠标移上的效果，变图片 9 oImg.onmouseover = function(){ 10 oImg.src = &quot;images/kaola2.jpeg&quot;; 11 }; 12 //鼠标移出效果，一般与鼠标移上成对出现 13 oImg.onmouseout = function(){ 14 oImg.src = &quot;images/kaola.jpg&quot;; 15 }; 16 }； window浏览器对象，alert就是window对象里面的一个方法。window可以省略。 window.alert(&quot;yes&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2014年中国IE6浏览器状况]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle25%2F</url>
      <content type="text"><![CDATA[IE6在4月9日停止更新了，与数日前XP退役引起的唏嘘与争论不同，IE6走得很悄然。我想，这是因为在许多人的电脑里，它早已被搁置了多年，取代它的有Chrome、Opera、Safari、搜狗和360等诸多后辈，老大哥寿终正寝，是历史的必然。 可是，IE6真的被完全取代了吗，抱着谨慎的态度，我查询了一些资料： 根据NetApplications的数据显示，就在IE6停止更新的4月9日，它在全球的市场占有率是4.4%。对于一款在美国本土的市场占有率只有0.2%的浏览器来说，退休或许是唯一的归宿。但是，令人惊奇的是，IE6在中国的市场占有率竟然是22.2%，这意味着，在其4.4%的全球市场份额中，仅中国大陆就占据了3.4%的份额。 再来看看CNZZ的数据，数据显示在中国4月8日PC端浏览器的使用率中，IE以39.05%遥遥领先，其中IE6贡献了其中的10.19%。 一句话总结：IE6没死，至少在中国，它活得好好的。 一个在全世界范围内行将就木的产品，唯独在中国生机勃勃。这不禁让我们产生一个问题：是什么人还在使用IE6?一个主要的数据源，我认为是中国大量的网吧。中国文化部于2012年发布的《2012年中国网吧市场年度报告》显示，2012年中国的网吧关闭了一万家左右，值得注意的是，这是2004年以来，网吧数量的首次下滑。网吧的电脑多数配置不高，因此占用内存较小的XP系统目前仍旧是主流的网吧系统，其自带的IE6浏览器尽管漏洞颇多，但网吧用户的安全威胁远不止这一个。虱子多了，就不痒了。 另一个主要的数据源，我认为是中国大量的中老年网民。普遍中老年网民对互联网的依赖性非常低，对互联网功能的熟练程度远远不如年轻人，在使用和需求上也有很大区别。在一项调查中显示78%的中老年人上网只是浏览资讯，互联网强大的力量并没有传递到他们的周围。 因此，IE6在中国“看上去很美”的境况，事实上也是一种虚假的繁荣。知乎上曾经有这样一段问答，戏谑间解释了很多事情： 多年前，有这样一份关于使用浏览器与IQ高低的调查，当年的结论是，IE浏览器用户的IQ全线偏低，2011年IE6用户的平均智商只有83，IE9的用户也不过90而已。Opera以128的平均智商遥遥领先。 一个慵懒庞大的体系占据着40%的市场份额，这是严重违背互联网精神的事情。今日得到UC浏览器要发布桌面浏览器的消息，其目的是想将PC端和移动端打通;360几日前开始从百度的hao123导航抢用户，也说明PC端浏览器的用户争夺还在持续着。在中国市场，十多款浏览器竞争着IE家族之外的60%的市场份额，战斗已经持续多年，空间已经颇为狭小。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css position的正确用法]]></title>
      <url>%2F2014%2F10%2F27%2Ftitle%2F</url>
      <content type="text"><![CDATA[本文向大家描述一下DIV CSS布局中的position属性的用法，position属性主要有四种属性值，任何元素的默认position的属性值均是static,静态。这节课主要讲讲relative（相对）以及absolute（绝对）。 【如何学习DIV+CSS布局之position属性】 如果用position属性来布局页面，父级元素的position属性必须为relative，而定位于父级内部某个位置的元素，最好用absolute。定位(position)布局页面说容易非常容易，只需要记住这节课最后一句话就可以了，说困难，那是相当的难理解，需要一定的耐心，不过还好，KwooJan给大家总结的已经很通俗易懂了。 如果下面的文字实在是无法理解透，那就记住这节课最后总结的一句话“如果用position来布局页面，父级元素的position属性必须为relative，而定位于父级内部某个位置的元素，最好用absolute，因为它不受父级元素的padding的属性影响，当然你也可以用position，不过到时候计算的时候不要忘记padding的值。” 任何元素的默认position的属性值均是static,静态。这节课主要讲讲relative（相对）以及absolute（绝对）。 【DIV+CSS布局之position属性:absolute】 意思是：他的意思是绝对定位，他默认参照浏览器的左上角，配合TOP、RIGHT、BOTTOM、LEFT(下面简称TRBL)进行定位，有以下属性： 1)如果没有TRBL，以父级的左上角，在没有父级的时候，他是参照浏览器左上角,如果在没有父级元素的情况下，存在文本，则以它前面的最后一个文字的右上角为原点进行定位但是不断开文字，覆盖于上方。 2)如果设定TRBL，并且父级没有设定position属性，那么当前的absolute则以浏览器左上角为原始点进行定位，位置将由TRBL决定。 3)如果设定TRBL，并且父级设定position属性(无论是absolute还是relative)，则以父级的左上角为原点进行定位，位置由TRBL决定。即使父级有Padding属性，对其也不起作用，说简单点就是：它只坚持一点，就以父级左上角为原点进行定位，父级的padding对其根本没有影响。 以上三点可以总结出，若想把一个定位属性为absolute的元素定位于其父级元素内，只有满足两个条件： 第一：设定TRBL 第二：父级设定Position属性 上面的这个总结非常重要，可以保证你在用absolue布局页面的时候，不会错位，并且随着浏览器的大小或者显示器分辨率的大小，而不发生改变。 只要有一点不满足，元素就会以浏览器左上角为原点，这就是初学者容易犯错的一点，已经定位好的板块，当浏览器的大小改变，父级元素会随之改变，但是设定Position属性为absolute的板块和父级元素的位置发生改变，错位了，这就是因为此时元素以浏览器的右上角为原点的原因。 初学者很容易犯错的是，不清楚Position属性为absolute的板块，若想定位到父级板块中，并且当浏览器的大小改变或显示器的分辨率改变，布局不发生改变，是需要满足两个条件的，只要有一点不满足，元素就会以浏览器左上角为原点，从而导致页面布局错位。 【DIV+CSS布局之position属性:relative】 意思是相对定位，他是默认参照父级的原始点为原始点，无父级则以文本流的顺序在上一个元素的底部为原始点，配合TRBL进行定位，当父级内有padding等CSS属性时，当前级的原始点则参照父级内容区的原始点进行定位，有以下属性： 1)如果没有TRBL，以父级的左上角，在没有父级的时候，他是参照浏览器左上角(到这里和absolute第一条一样)，如果在没有父级元素的情况下，存在文本，则以文本的底部为原始点进行定位并将文字断开(和absolut不同)。 2)如果设定TRBL，并且父级没有设定position属性，仍旧以父级的左上角为原点进行定位(和absolut不同) 3)如果设定TRBL，并且父级设定position属性(无论是absolute还是relative)，则以父级的左上角为原点进行定位，位置由TRBL决定(前半段和absolut一样)。如果父级有Padding属性，那么就以内容区域的左上角为原点，进行定位(后半段和absolut不同)。 以上三点可以总结出，无论父级存在不存在，无论有没有TRBL，均是以父级的左上角进行定位，但是父级的Padding属性会对其影响。 综合上面对relative的叙述，我们就可以将position属性为relative的DIV视成可以用TRBL进行定位的的普通DIV，或者说只要将我们平时布局页面的div的CSS属性中加上position:relative后，就不只是用float布局页面了，还可以用TRBL进行布局页面了，或者说加上position:relative的DIV也可以像普通的DIV进行布局页面了，只不过还可以用TRBL进行布局页面。但是position属性为absolute不可以用来布局页面，因为如果用来布局的话，所有的DIV都相对于浏览器的左上角定位了，所以只能用于将某个元素定位于属性为absolute的元素的内部某个位置。 总结： 如果用position来布局页面，父级元素的position属性必须为relative，而定位于父级内部某个位置的元素，最好用absolute，因为它不受父级元素的padding的属性影响，当然你也可以用position，不过到时候计算的时候不要忘记padding的值。]]></content>
    </entry>

    
  
  
</search>
