<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JSONP跨域详解]]></title>
      <url>%2F2016%2F12%2F12%2Ftitle42%2F</url>
      <content type="text"><![CDATA[1、Ajax因为安全限制不允许跨域Ajax不能跨域，指的是如果你的HTML页面在127.0.0.1上，此时将不能访问127.0.0.2上的文件。如果你的文件在www.iqianduan.cn上，也不能访问www.163.com上的文件。有些浏览器甚至不允许你访问news.58gsl.cn。这是浏览器的安全限制，不允许你随随便便的访问其他服务器上的JSON。 2、JSONP跨域JSONP就是JSON with Padding ( JSON和 赘语），指的就是把函数的执行放到外部文件，HTML用script标签引用这个js文件，实际上引用的是对一个函数的执行。此时函数定义在HTML文件里面，数据就通过实参、形参的结合就进入了HTML数据。 &lt;script type=&quot;text/javascript&quot;&gt; function fun(data){ alert(data.xingming); } &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;haha.txt&quot;&gt;&lt;/script&gt; → 这个文件执行了fun函数 haha.txt文件里面： fun({&quot;xingming&quot;:&quot;小明&quot;,&quot;nianling&quot;:12,&quot;xingbie&quot;:&quot;男&quot;}); 红色部分是执行一个函数，就是所谓的“P”。 京东数据的请求： &lt;script type=&quot;text/javascript&quot;&gt; function yuanye(data){ for(var i = 0 ; i &lt; data.comments.length ; i++){ alert(data.comments[i].content); } } &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://sclub.jd.com/comment/productPageComments.action?productId=4048938&amp;score=0&amp;sortType=3&amp;page=1&amp;pageSize=10&amp;callback=yuanye&quot;&gt;&lt;/script&gt; JSONP的缺点： 1） 太不安全，什么时候章泽天和刘强东吵架，刘强东很生气，把JSONP接口换成了 for(var i = 0 ; i &lt; 1000000 ; i++){ alert(&quot;你好&quot;); } 此时你又在用script引用它，此时你的用户也被连带遭殃了。 所以JSONP的提供者，一定要可靠！ 2） 没有明显的异步的特点。页面虽然不会假死，但是没有提供回调函数。不过也没关系，页面不假死是重点。 3） 很难控制请求的发出。比如我想点击一个按钮，然后发出请求。不过也很快被解决了，我们可以动态的创建一个script标签，设置了src，一旦上树，上行请求将发出，此时函数将执行！ &lt;script type=&quot;text/javascript&quot;&gt; var btn = document.getElementById(&quot;btn&quot;); //准备一个函数，一会儿外部文件将执行这个函数 function fun(data){ alert(data.xingming); } //事件监听 btn.onclick = function(){ var oscript = document.createElement(&quot;script&quot;); oscript.src = &quot;haha.txt&quot;; document.head.appendChild(oscript); document.head.removeChild(oscript); } &lt;/script&gt; 甚至我们可以封装一个函数，就不用显式的创建fun函数了，可以把用户传输进来的函数，当做fun函数： &lt;script type=&quot;text/javascript&quot;&gt; var btn = document.getElementById(&quot;btn&quot;); function qingqiu(URL,callback){ //你第二个传入的参数就是哈哈函数 window.fun= callback; var oscript = document.createElement(&quot;script&quot;); oscript.src = URL; document.head.appendChild(oscript); document.head.removeChild(oscript); } qingqiu(&quot;haha.txt&quot;,function(data){ alert(data.nianling); }); &lt;/script&gt; jQuery中使用JSONP和使用正经Ajax一样一样的，你完全看不出来，只是些许有些语法不一样。 3、JSONP的jQuery使用首先： $.get(URL,function(data){ }); $.post(URL,function(data){ }); jQuery中最全活的API是： $.ajax(); 比如： $.ajax({ &quot;url&quot; : &quot;php/job.php&quot;, &quot;data&quot; : { &quot;page&quot; : 2 }, &quot;type&quot; : &quot;get&quot;, &quot;success&quot; : function(data){ alert(data); } }); 等价于： $.get(&quot;php/job.php?page=2&quot;,function(data){ alert(data); }) 此时jQuery实现JSONP跨域： &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.12.3.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $.ajax({ //请求的地址，下面是一个域外的地址 &quot;url&quot; : &quot;http://127.0.0.2/haha.txt&quot;, //请求类型是jsonp类型，注意是dataType属性而不是type属性 &quot;dataType&quot; : &quot;jsonp&quot;, //定义我们传进来的success函数叫什么名字 &quot;jsonpCallback&quot; : &quot;fun&quot;, //定义一个函数，这个函数马上会成为window.fun &quot;success&quot; : function(data){ alert(data.xingming); alert(data.nianling); alert(data.xingbie); } }); &lt;/script&gt; 特别的，如果后台哥哥给你写了callback GET请求参数，可以任意设置调用的函数名字，此时jQuery中可以用？代替这个部分，jQuery会自动帮你填入随机乱码： $.ajax({ &quot;url&quot; : &quot;https://sclub.jd.com/comment/productPageComments.action?productId=4048938&amp;score=0&amp;sortType=3&amp;page=1&amp;pageSize=10&amp;callback=?&quot;, &quot;dataType&quot; : &quot;jsonp&quot;, &quot;success&quot; : function(data){ alert(data.comments.length); } }); 此时jQuery就会把请求发往： https://sclub.jd.com/comment/productPageComments.action?productId=4048938&amp;score=0&amp;sortType=3&amp;page=1&amp;pageSize=10&amp;callback=jQuery112306426957034965071_1480068166765 工作中这种模式最最常用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax中的GET请求和POST请求]]></title>
      <url>%2F2016%2F12%2F09%2Ftitle41%2F</url>
      <content type="text"><![CDATA[1、GET请求GET请求参数在URL中，所以参数非常好携带。GET请求没有上行报文体，所以send里面是null。 xhr.open(&quot;get&quot;,&quot;check.php?username=考拉&amp;age=12&quot;,true); xhr.send(null); 研究两个事情：字符转码的问题、用JSON来转为query string。 我们观察一个事情，此时在地址栏中输入你好： 复制出来就是： http://127.0.0.1/test.txt?%E4%BD%A0%E5%A5%BD 也就是说中文汉字就是：%AA%AA%AA 其中AA是一个两位16进制数字。 这个叫做URI转码（Uniform Resource Identifier，统一资源标识符），URI和URL差不多，只不过URL强调的是地址，URI强调的是具体的写法。 因为网址只能是英语字符和数字，不能是中文、日语、韩语、阿拉伯文等等，所以URI就想了个办法，用16进制数字来表示非英语文字。 JavaScript内置了转码的函数，各个浏览器兼容很好： 从中文 → URI编码：encodeURIComponent(“我爱你”)URL编码 → 中文：decodeURIComponent(“%E4%BD%A0%E5%A5%BD”) 此时任何后台语言都不需要再次解码就能识别标准URI编码。所以你要知道这个东西不是密码，就是在传输过程中为了防止非英语文字变形，用的临时编码。 &lt;?php $ciyu = $_GET[&quot;ciyu&quot;]; echo $ciyu; ?&gt; 为了防止传输过程中变形，所以我们的Ajax程序要： xhr.open(&quot;get&quot;,&quot;check.php?yonghuming=&quot; + encodeURIComponent(yonghuming) + &quot;&amp;age=&quot; + encodeURIComponent(12)); 再来研究一个事情，能不能写一个函数，接受一个JSON，返回query string。比如传入： { &quot;yonghuming&quot; : &quot;小明&quot;, &quot;age&quot; : 12, &quot;sex&quot; : &quot;男&quot; } 返回 &quot;?yonghuming=%E5%B0%8F%E6%98%8E&amp;age=12&amp;sex=%E7%94%B7&quot; 函数很好写，利用数组的join方法，是个神器！一旦你遇见让你返回字符串，然后字符串之间有符号，开头、结尾没有符号，就要想到join方法。 function changeJSON2QueryString(JSON){ var temp = []; for(var k in JSON){ temp.push(k + &quot;=&quot; + encodeURIComponent(JSON[k])); } return temp.join(&quot;&amp;&quot;); } 所以现在我们Ajax的open语句可以这么玩儿： var querystring = changeJSON2QueryString({ &quot;yonghuming&quot; : &quot;小明&quot;, &quot;age&quot; : 12, &quot;sex&quot; : &quot;男&quot; }); xhr.open(&quot;get&quot;,&quot;check.php?&quot; + querystring , true); 2、POST请求POST请求是通过request报文体来传输，所谓open简单，send里面有内容。PHP程序需要我们加上一个Request Header中的Content-type为普通表单，才能在后台用$_POST[]识别。 任何一个post的表单的上行报文头里面，都有这样的K-V对儿： Content-Type:application/x-www-form-urlencoded 所以我们在Ajax中也要设置（今后遇见node.js就不用设置）： xhr.open(&quot;post&quot;,&quot;dopost.php&quot;,true); xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); xhr.send(&quot;yonghuming=%E5%B0%8F%E6%98%8E&amp;age=12&amp;sex=%E7%94%B7&quot;); 3、JSON的识别JSON是一个通用信息交换格式，比如PHP工程师，可以使用json_encode()函数把别名数组转为标准JSON： &lt;?php $arr = array( &quot;result&quot; =&gt; array( array(&quot;xingming&quot; =&gt; &quot;小明&quot; , &quot;nianling&quot; =&gt; 12 , &quot;xingbie&quot; =&gt;&quot;男&quot;), array(&quot;xingming&quot; =&gt; &quot;小红&quot; , &quot;nianling&quot; =&gt; 15 , &quot;xingbie&quot; =&gt;&quot;女&quot;), array(&quot;xingming&quot; =&gt; &quot;小刚&quot; , &quot;nianling&quot; =&gt; 13 , &quot;xingbie&quot; =&gt;&quot;男&quot;) ) ); echo json_encode($arr); ?&gt; JSON显示在页面上的时候，不方便我们看JSON的结构，此时推荐安装一个浏览器插件，叫做JSONView。 Chrome应用商店打不开，并且网上下载的都不适合现在的Chrome版本。所以我们可以安装QQ浏览器，它的内核也是Chrome内核，中国人没有自己的浏览器内核。在应用中心中，安装“JSONView”。 安装完插件之后，访问JSON页面： 4、JSON识别我们使用Ajax读取一个JSON的时候，此时明明是JSON，但是读进来是String。此时就要把String变为JSON。 $.get(&quot;04_JSON.php&quot;,function(data){ console.log(data); console.log(typeof data); }); 一共有三种方法。 方法1：使用内置构造函数JSON的方法 var dataobj = JSON.parse(data); console.log(dataobj); console.log(typeof dataobj); JSON是系统内置的构造函数，和Number、String、Array一样。它IE8才开始有，IE6、7不支持JSON内置构造函数。 它一共就有两个方法： JSON.parse() 字符串 → 对象 JSON.stringify() 对象 → 字符串 JSON.parse()函数里面的字符串必须是标准JSON，必须有双引号引用所有的key。 方法2：使用eval语句 eval语句可以把字符串变为语句，是JS中的一个特色。 var str = &quot;alert(1+2+3)&quot;; //字符串 eval(str); //字符串变为了语句 弹出6。 eval()一般都是当做奇淫技巧使用，注意任何文本框都需要用正则表达式阻止eval。比如让你输出一个用户名，你叫做eval(“setInterval(function(){alert(‘哈哈’);},1)”); 极其危险！ 我们可以利用eval语句来把JSON字符串变为对象的JSON，但是此时要注意：如果直接eval一个JSON字符串，会报错： 语法要求必须用圆括号括起来： 所以： var dataobj = eval(&quot;(&quot; + data + &quot;)&quot;); console.log(dataobj); console.log(typeof dataobj); 方法3：借助Function函数 var sum = new Function(&quot;a&quot;,&quot;b&quot;,&quot;return a + b&quot;); alert(sum(3,4)); Function你仔细琢磨，也可以把字符串变为语句啊！ var dataobj = (new Function(&quot;return &quot; + data))(); console.log(dataobj); console.log(typeof dataobj); 5、复杂JSON的JS处理现在拿一个JSON举例子： 请用Ajax读取它，在HTML页面上枚举所有点击数大于1000的文章标题。 &lt;script type=&quot;text/javascript&quot;&gt; $.get(&quot;system/baijiayanshi.txt&quot;,function(data){ //把字符串转为真正的JSON var dataobj = eval(&quot;(&quot; + data + &quot;)&quot;); //如鱼得水，“JSON回家了” var arr = dataobj.data.list; for(var i = 0 ; i &lt; arr.length ; i++){ if(arr[i].hotcount &gt; 1000){ $(&quot;&lt;p&gt;&quot; + arr[i].m_title + &quot;【点击数：&quot; + arr[i].hotcount + &quot;】&lt;/p&gt;&quot;).appendTo(&quot;#box&quot;); } } }); &lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[原生Ajax的实现]]></title>
      <url>%2F2016%2F12%2F08%2Ftitle40%2F</url>
      <content type="text"><![CDATA[原生Ajax的实现原生Ajax要依赖一个内置构造函数，XMLHttpRequest()，字面理解“XML HTTP 请求者”。这个对象的实例有能力异步发出HTTP请求的能力。 要实例化这个对象： var xhr = new XMLHttpRequest(); 此时IE6不兼容这个对象： //实例化XMLHttpRequest对象，有兼容问题 if(window.XMLHttpRequest){ //高级浏览器 var xhr = new XMLHttpRequest(); }else{ //IE6 var xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); } 我们可以配置它的发送请求： xhr.open(&quot;get&quot;,&quot;test.txt&quot;,true); 三个参数分别是请求的类型、URL、是否是异步。第三个参数一定是true，否则就不是异步读取了。请求没有真正发出，仅仅是配置了打开了发送“窗口”。 此时用send方法发出请求。send就是发送请求，参数是上行请求的报文体。get请求不需要报文体，就是null。 xhr.send(null); 原生JS中没有提供给一个明显的回调函数，此时需要监听一个事件，就绪状态改变事件： xhr.onreadystatechange = function(){ console.log(&quot;就绪状态改变了&quot; + xhr.readyState); } 对我们有用的两个readyState就是3、4。当readyState为3的时候，已经可以得到服务器的信息，因为header已经回来了，做倒计时秒杀的收，就用3这个状态。4表示所有内容已经成功返回，更有用，因为只有状态是4的时候才能得到完整的文件信息。 接受到的信息是xhr.responesText。 xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ info.innerHTML = xhr.responseText; } } 有规定，onreadystatechange必须写在open和send前。所以至此代码： //① 实例化XMLHttpRequest对象，有兼容问题 if(window.XMLHttpRequest){ //高级浏览器 var xhr = new XMLHttpRequest(); }else{ //IE6 var xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); } //② 监听一个事件，叫做“就绪状态”改变的事件 xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ info.innerHTML = xhr.responseText; } } // ③ 配置一个请求，open可以理解为打开一个请求“窗口” xhr.open(&quot;get&quot;,&quot;test.txt&quot;,true); // ④ 发送请求，send就是发送请求，参数是上行请求的报文体。get请求不需要报文体，就是null。 xhr.send(null); 此时我们需要让程序更加鲁棒，当文件不存在的时候，整个页面的错误信息也读到本页面来了： 所以就要用HTTP状态码来验证文件是否已经成功发送。 HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。这个代码是后台哥哥可以随便设置的，阿帕奇服务器也会帮我们自动生成状态码。 重要的状态码是： 200-成功 302-临时移动 304-没有更改 400-错误的请求 401-没有权限 403-禁止 404-页面丢失，没有找到 500-服务器错误 502-错误的网关 503-服务无效 504-访问超时 xhr对象的status属性可以得到状态码。从而可以用来验证页面是不是真的发过来了，此时验证字头是2开头的或者是304。 xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status.toString().charAt(0) == &quot;2&quot; || xhr.status == &quot;304&quot;){ info.innerHTML = xhr.responseText; } } } 也可以： if(xhr.status == &quot;200&quot; || xhr.status == &quot;304&quot;){ } 也可以： if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){ } Ajax的缓存比较严重，此时可以通过每次访问的时候带一个不同的参数即可。此时可以挂一个随机数，或者时间戳： xhr.open(&quot;get&quot;,&quot;test.txt?&quot; + Date.parse(new Date()),true); xhr.open(&quot;get&quot;,&quot;test.txt?&quot; + Math.random(),true); 至此，已经学习了xhr的： ● 一个事件 xhr.onreadystatechange 就绪状态改变事件 ● 两个方法 xhr.open()方法 打开一个发射窗口xhr.send()方法 发送请求 ● 三个属性 xhr.responseText 返回的文本xhr.readyState 就绪状态xhr.status 3位数字的状态码number类型]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[游戏开发中canvas常见要点]]></title>
      <url>%2F2016%2F12%2F05%2Ftitle39%2F</url>
      <content type="text"><![CDATA[1 游戏图片、音乐资源的管理不管游戏中有多少元素在运动，游戏仅仅有1个定时器，这1个定时器让所有的演员更新、渲染。实际上，一个游戏需要大量的图片，只有当所有图片都load了，游戏才能开始。换句话说，只有当所有图片都load了，主循环setInterval()才能启动。 所以我们的思路就是用JSON imagesObj 存放所有的资源图片的名字，用循环语句for..in…去创建他们的Image对象，然后监听他们的load事件，load一个计数器加1，当load完一个图片的时候，计数器正好等于了数组总长度，此时表示所有图片加载完毕。比较巧妙的是，我们创建了一个R对象，这个对象和imagesObj 的key是一样的，但是v是图片的Image实体，用图片的时候，要通过R打点来找到图片。 &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //如果要使用图片，必须要创建一个Image的实例，然后监听这个img的load事件 //只有load的图片才能上画布 var imagesObj = { &quot;shibing&quot; : &quot;images/shibing.png&quot;, &quot;baozha&quot; : &quot;images/baozha.png&quot; }; //图片资源对象，k和imagesObj是一样的，v是真正的图片Image对象 var R = {}; //已经加载好的图片个数 var count = 0; var cutx = 0; var baozhaxuhao = 0; for(var k in imagesObj){ //创建图片节点 R[k] = new Image(); //设置src R[k].src = imagesObj[k]; //监听是否load R[k].onload = function(){ count++; if(count === 2){ //全部都加载完毕 setInterval(function(){ cutx ++; baozhaxuhao++; if(cutx &gt; 7){ cutx = 0; } if(baozhaxuhao &gt; 11){ baozhaxuhao = 0; } //清屏 ctx.clearRect(0, 0, 800, 600); ctx.drawImage(R.shibing,120 * cutx,150 * 3,120,150,100,100,120,150); ctx.drawImage(R.baozha,192 * (baozhaxuhao % 5),192 * parseInt(baozhaxuhao / 5),192,192,100,100,192,192); },20); } } } &lt;/script&gt; 2、Game类Game类就是中介者模式中的中介者 ##。中介者就是全局变量！比如我们以前 var idx = 10; 信号量，就是全局变量，现在把这个量放入一个类的实例身上，此时这个类就是中介者。 信号量在中介者身上： var game = new Game(); game.idx = 10; 以后所有的元素都是Game类new出来的，我们只需要new出中介者，其他元素都是Game帮我们new出来的。 其他元素如果要互相通信，要通过Game类： game.bird.y 在HTML5游戏中，Game类还将有：主循环、游戏资源管理两个任务。 图片资源管理利用两个对象，RObj和R对象。Robj就是Ajax请求来的文本转为的对象，v是路径； R对象的拥有Robj相同的k，但是v是真实对象： 3 背景类背景类的实例化在Game的start函数里面。而start函数的调用的前提是所有资源已经加载完毕了。说白了，背景类里面可以直接使用图片资源。 canvas里面也有猫腻，也有模式。渲染三张，目的是无缝连续滚动，当猫腻图的左边框到达0点，就拉回来。 4、cancas变形canvas中，提供了变形属性，需要注意的是，所有的变形都是针对画布上下文ctx对象的，而不是某一个要绘制的元素的。 var mycanvas = document.getElementById(“mycanvas”); var ctx = mycanvas.getContext(&quot;2d&quot;); //保存当前的上下文状态 ctx.save(); //移动坐标系 ctx.translate(100,100); //画圆 ctx.fillStyle = &quot;blue&quot;; ctx.beginPath(); ctx.arc(0,0,50,0,Math.PI * 2,true); ctx.fill(); //恢复上下文存档状态 ctx.restore(); //画方块 ctx.fillRect(100, 100, 100, 100); &lt;/script&gt; 坐标系还可以通过 ctx.rotate(1);渲染1弧度。同样的，旋转的是整个坐标系，而不是某一个元素。 &lt;script type=&quot;text/javascript&quot;&gt; var mycanvas = document.getElementById(&quot;mycanvas&quot;); var ctx = mycanvas.getContext(&quot;2d&quot;); ctx.rotate(1); //1弧度，顺时针 ctx.fillStyle = &quot;orange&quot;; ctx.fillRect(100, 100, 100, 100); &lt;/script&gt; 如果想要让一个元素以自己的几何中心点旋转，此时需要： ① 先让坐标系的原点移动到它的中心点，此时盒子的渲染位置就是负的自己的宽度的一半，负的自己的高度的一半。 ② 旋转 公式： t指的是开始下落后的时间，此时小鸟就要维护自己的小帧号birdF。 //物理公式：s = 1/2gt^2 //掉 birdF++; birdY = 100 + 1.3 * birdF * birdF; birdRotate+=0.08; 5、碰撞检测但是游戏中我们一般使用AABB盒检测。 AABB盒是英语Axis Aligned Bounding Box 轴对齐包围盒。 鸟是一个不规则形状，判断碰撞的时候取一个大概，用矩形盒子来判断： //更新自己的碰撞检测盒 this.A = this.y + 7; this.B = this.x + 41; this.C = this.y + 41; this.D = this.x + 7; 鸟这个图片本身是48宽度，碰撞盒是34，所以两边有误差7。 所谓的ABCD都是边的x或者y，横边就取y值，纵边就取x值。碰撞检测： if( game.bird.A &lt; this.C1 &amp;&amp; game.bird.B &gt; this.D1 &amp;&amp; game.bird.D &lt; this.B1 || game.bird.C &gt; this.A2 &amp;&amp; game.bird.B &gt; this.D2 &amp;&amp; game.bird.D &lt; this.B2 ){ console.log(&quot;撞！&quot;); clearInterval(game.timer); } 6、合成canvasctx.globalCompositeOperation = type 一共有12种值，表示新画的图形和老图形的关系，称为“合成”。 比如： ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(100,100,100,100); ctx.globalCompositeOperation = &quot;source-in&quot;; ctx.beginPath(); ctx.arc(180,180,50,0,7,false); ctx.fillStyle = &quot;red&quot;; ctx.fill(); 像素操作到目前为止，我们尚未深入了解Canvas画布真实像素的原理，事实上，你可以直接通过ImageData对象操纵像素数据，直接读取或将数据数组写入该对象中。稍后我们也将深入了解如何控制图像使其平滑（反锯齿）以及如何从Canvas画布中保存图像。 得到像素： var myImageData = ctx.getImageData(0,0,560,300); 0,0表示起点位置，560是宽度，300是高度。 得到的值可以被使用作为查看初始像素数据。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是”RGBA”格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。 7、事件监听canvas上必须检测范围，因为得不到元素。 贝塞尔曲线： ctx.moveTo(100,100); ctx.bezierCurveTo(200, 50, 400, 50, 400, 100); ctx.stroke(); 点击鼠标的时候，要遍历每个元素，看看点击到了谁，点击到的这个元素，就存入变量。然后让变量中的元素x、用、跟随你的鼠标变化即可。 if(x &gt; ctrl1.x - 5 &amp;&amp; x &lt; ctrl1.x + 5 &amp;&amp; y &gt; ctrl1.y - 5 &amp;&amp; y &lt; ctrl1.y + 5){ diandaodedian = ctrl1; } if(x &gt; ctrl2.x - 5 &amp;&amp; x &lt; ctrl2.x + 5 &amp;&amp; y &gt; ctrl2.y - 5 &amp;&amp; y &lt; ctrl2.y + 5){ diandaodedian = ctrl2; } if(x &gt; start.x - 5 &amp;&amp; x &lt; start.x + 5 &amp;&amp; y &gt; start.y - 5 &amp;&amp; y &lt; start.y + 5){ diandaodedian = start; } if(x &gt; end.x - 5 &amp;&amp; x &lt; end.x + 5 &amp;&amp; y &gt; end.y - 5 &amp;&amp; y &lt; end.y + 5){ diandaodedian = end; } 8、场景Scene管理开始画面、游戏过程、结束画面。 场景现在开始接手管理自己的演员！！但是，场景还是应该把演员注册到game身上，但是管理的权限、谁上台、谁下台，是场景管理器的任务。 监听都是场景管理器负责注册！！ http://squishybird.com/ http://so2.4399.com/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端缓冲ease事件]]></title>
      <url>%2F2016%2F12%2F03%2Ftitle38%2F</url>
      <content type="text"><![CDATA[Canvas概述 是HTML5非常重要的更新！目的就是革命，革Flash的命！一统游戏江湖！一统动画江湖！一统网页广告江湖！以前在网页中播放Flash需要安装Adobe Flash Player的插件，不装不行，看不了Flash。现在canvas是集成在浏览器里面的。Canvas和Flash的思路完全不一样，Flash是上屏幕之后还是对象，编程语言叫做Action Script也是ECMAScript范畴。Canvas上屏幕之后像素化了，再也不能得到这个对象了，所以要想让这个元素运动，必须擦除整个屏幕、重绘这个元素。Canvas更流畅，手机端也嗷嗷流畅。 canvas是一个双标签，里面的内容是不支持canvas浏览器显示的内容： 对不起，你的浏览器不支持画布，请升级浏览器！宽度、高度写在标签里面，如果写在css中，就变形、扭曲了。 编程： //得到画布标签 var myCanvas = document.querySelector(“#myCanvas”); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(“2d”); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 ctx.fillStyle = “lightseagreen”; ctx.fillRect(100,100,300,200); 坐标系： API：ctx.fillStyle = “red”; //设置填充颜色ctx.fillRect(100,100,300,200); //绘制一个填充矩形 二、笔触、填充笔触也叫作“描边”，Canvas中的任何形状都是由这两个部分组成的。笔触在canvas中视为一个“Path”的实例，必须stroke之后才能上屏幕；填充用fill才能上屏幕。 制作一个笔触需要用到的API：ctx.beginPath(); //开始绘制路径ctx.closePath(); //自动封闭路径ctx.moveTo(100,200); //将画笔移动到某一个点ctx.lineTo(200,200); //用画笔划线，此时的参数是终点位置，起点就是画笔此时的位置ctx.stroke(); //划线比如： //得到画布标签 var myCanvas = document.querySelector(“#myCanvas”); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(“2d”); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.moveTo(100,100); ctx.lineTo(300,300); ctx.lineTo(600,300); ctx.moveTo(600,400); ctx.lineTo(700,400); ctx.stroke(); 在划线之前可以设置线的宽度和颜色： ctx.lineWidth = “10”; ctx.strokeStyle = “red”; ctx.stroke(); 当ctx上已经有一些path之后，此时调用fill()将自动填充。 //得到画布标签 var myCanvas = document.querySelector(“#myCanvas”); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(“2d”); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.moveTo(100,100); ctx.lineTo(300,300); ctx.lineTo(600,300); ctx.closePath(); ctx.lineWidth = “10”; ctx.strokeStyle = “red”; ctx.stroke(); ctx.fillStyle = “lightseagreen”; ctx.fill(); 绘制新的形状的时候，要重新beginPath() //得到画布标签 var myCanvas = document.querySelector(“#myCanvas”); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(“2d”); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.moveTo(100,100); ctx.lineTo(300,300); ctx.lineTo(600,300); ctx.closePath(); ctx.lineWidth = “10”; ctx.strokeStyle = “red”; ctx.stroke(); ctx.fillStyle = “lightseagreen”; ctx.fill(); ctx.beginPath(); ctx.moveTo(600,100); ctx.lineTo(600,200); ctx.lineTo(750,200); ctx.lineTo(790,40); ctx.closePath(); ctx.fillStyle = &quot;orange&quot; ctx.fill(); ctx.stroke(); &lt;/script&gt; fillRect()是一个快捷方法，让你省略了beginPath、moveTo、lineTo。所以fillRect(100,100,300,200)等价于：ctx.move(100,100);ctx.lineTo(400,100);ctx.lineTo(400,300);ctx.lineTo(100,300);ctx.closePath();ctx.fill(); 三、弧和圆形画弧线，用arc方法，它属于Path。所以画弧之前要beginPath()一下。 //得到画布标签 var myCanvas = document.querySelector(“#myCanvas”); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(“2d”); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.arc(200,200,100,0,1,true); //圆心坐标200,200。100是半径。0开始角度，1终止角度，true表示逆时针 ctx.stroke(); 坐标系，Canvas中的角度都是弧度制，1弧度等于57.3度： 这是true 这是false 完整的圆终止角度就是Mathi.PI 2ctx.arc(200,200,200,0,Math.PI2,false); 画20个同心圆。for(var i = 10 ; i &lt;= 400 ; i+=5){ ctx.beginPath(); ctx.arc(200,200,i,0,Math.PI * 2,true); ctx.strokeStyle = “rgb(“ + i + “,” + i + “,” + i + “)”; ctx.stroke();} 这里省略线型、虚线的绘制，可以自己参考MDN学习。https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors 四、文字fillText函数用来写字，参数是：文字内容、坐标位置ctx.fillText(“文字内容”,100,100); 可以使用font属性来调整字号和字形：ctx.font = “50px 微软雅黑”;ctx.fillText(“你好”,100,100); 五、使用图片使用图片有一个固定的语法，必须new Image()然后设置src，监听load事件，使用ctx.drawImage()函数上画布。var img = new Image();img.src = “images/0.jpg”; img.onload = function(){ ctx.drawImage(img,100,100);}ctx.drawImage()里面的参数是图片对象、左上角的坐标。 ctx.drawImage()里面可以有四个数字参数，增加了宽度、高度的设置，此时图片会被扭曲： var img = new Image(); img.src = “images/0.jpg”; img.onload = function(){ ctx.drawImage(img,100,100,250,80); } 如果要使用切片，就是9个参数：var img = new Image();img.src = “images/0.jpg”; img.onload = function(){ ctx.drawImage(img,168,150,126,141,100,100,300,300);}红色部分描述的是切片的事儿： 蓝色部分是上屏幕之后的事儿： 公式：ctx.drawImage(img,切片x,切片y,切片w,切片h,上屏x,上屏y,上屏w,上屏h); 六、运动canvas中元素不能运动的，因为上屏幕之后就再也得不到它了，没有任何变量能够持有一个:var box = ctx.fillRect(100,100,200,200); 必须重绘一个新的矩形！利用视觉暂留，形成运动！清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 →…… 清屏：ctx.clearRect(0,0,800,600);实际上是清除一个矩形区域，我们一般清除整个画布。 面向对象制作运动，结构：function Circle(){ }Circle.prototype.render = function(){ }Circle.prototype.update = function(){ } var yuan = new Circle(); setInterval(function(){ ctx.clearRect(0,0,800,600); yuan.update(); yuan.render();},20);每一帧都要更新演员、渲染演员。只要这个东西是演员，它必须提供update、render方法。 面向接口编程，接口就是具有一定方法的类的集合。说白了，就比如说很多类都有render、update方法，此时Actor（演员）就是一个接口，Circle和Fang类都是这个接口的实现。“接口就是类的类”。Java中有明确的Interface(接口)的概念，还有implement实现接口的关键字，当然这是Java的概念。JS中没有明确的接口的关键字，但是可以用继承表示这个“接口”的概念。 说白了：我们要制作Actor类，Actor类提供update、render方法，并且会把自己放入总数组中。所有演员类，都必须继承这个类，重写Actor和render方法。 实现继承：function B(){ } function A(){ } A.prototype = new B();太麻烦，所以我们使用John Resig（jQuery的第一作者）的Simple Inheritance那个小库。Prototype.js也能完成同样的操作。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端缓冲ease事件]]></title>
      <url>%2F2016%2F11%2F30%2Ftitle37%2F</url>
      <content type="text"><![CDATA[1、缓冲easeCSS中的transition第三个参数就是缓冲描述： transition:all 1s linear 0s; transition:all 1s ease 0s; JS也有，但是要自己推理： 让div用100帧，从left100变化到left800。匀速的话，非常好计算： 总变化量就是700，所以每帧的变化量应该是7。 帧编号t 距起点的增量tc/d 绝对位置b + tc/d 假设帧编号为t（本例中t自增），t就是time的意思 起点成为b（本例中b为100），b就是begin起点的意思 总变化量c（本例中c为700），c就是change变化量的意思 总帧数d（本例中d为100），d就是duration持续时间的意思 所以刚才的推理就变为了一个函数： function linear(t,b,c,d){ return b + t * c / d; } 此时这个函数接受四个参数的意义，上面已经说明了，返回的是绝对位置。此时观察这个函数， t=0的时候，返回值是b （运动没有开始） ； t= d的时候，返回值就是b+c （运动结束）。 所以我们就可以自己写一些函数，比如二次的： function haha(t,b,c,d){ return b + t * t * c / (d *d); } Excel中做图： 上网能下载到很多t、b、c、d的函数 jQuery中实现缓冲，下载jQuery.easing.js的包 $().animate({},1000,&quot;easeInOut&quot;); 2、手指滚滚屏手机滚滚屏中，希望有一个loading界面，当所有图片都加载好支持，再从容给用户观看。所以我们要管理好资源，我们的想法就是使用一个JSON列出所有的图片资源： { &quot;tu1&quot; : &quot;images/1.jpg&quot;, &quot;tu2&quot; : &quot;images/2.jpg&quot;, &quot;tu3&quot; : &quot;images/3.jpg&quot; } 用JS写程序创建一个个孤儿节点，图片对象存储在和这个JSON相同的另一个对象中： { &quot;tu1&quot; : Image(), &quot;tu2&quot; : Image(), &quot;tu3&quot; : Image() } 此时HTML页面上，仅仅用img标签的“模板”来占位，用JS的真实图片孤儿节点，替换这个节点。 &lt;img data-name=&quot;tu1&quot; /&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端JS事件]]></title>
      <url>%2F2016%2F11%2F30%2Ftitle36%2F</url>
      <content type="text"><![CDATA[##1、触摸事件 ##移动端JS事件，重要就是触摸事件。触摸事件和鼠标事件完全不一样，因为鼠标不可能离开屏幕，鼠标在屏幕上可以点击可以不点击；但是手指可以离开屏幕，手指一旦碰到屏幕，就被视为点击了。所以，JS设计了一套完整的触摸事件系列，适应移动端web开发。 touchstart 开始触摸 touchmove 手指移动 touchend 结束触摸 touchstart 在手指触摸的一瞬间发生，如果有多个手指触摸，每个手指触摸的时候都会发生。 touchend 在手指离开屏幕的一瞬间发生，如果有多个手指离开，每个手指离开的时候都是触发这个事件。 绑定他们的时候，只能用DOM2级来绑定，不能用window.on*来绑定。 &lt;script type=&quot;text/javascript&quot;&gt; var box = document.querySelector(&quot;#box&quot;); box.addEventListener(&quot;touchstart&quot;, function(){ box.innerHTML = &quot;你触摸了我&quot;; }, true); box.addEventListener(&quot;touchend&quot;, function(){ box.innerHTML = &quot;你结束触摸了我&quot;; }, true); &lt;/script&gt; 注意，touchstouch事件和touchmove事件中event事件对象中有一个属性叫做touches是一个数组，里面封装了每个手指的信息，包括手指的位置、手指的粗细、力度（仅仅iPhone7提供）都有： 手指的数量： var fingers = event.touches.length; 每根手指的位置信息： //触摸移动 box.addEventListener(&quot;touchmove&quot;, function(event){ //阻止默认事件 event.preventDefault(); //得到每个手指的信息 var fingers = event.touches; //清空 box.innerHTML = &quot;&quot;; //遍历每个手指，显示信息 for(var i = 0 ; i &lt; fingers.length ; i++){ box.innerHTML += &quot;第&quot; + i + &quot;根手指位置&quot; + fingers[i].clientX + &quot;,&quot; + fingers[i].clientY + &quot;&lt;br /&gt;&quot;; } }, true); touchend事件中比较特殊，touches属性是一个数组，表示现在仍然在屏幕上的手指；而changedTouches属性也是一个数组，表示离开的手指的信息。先离开屏幕的手指，先被push进入数组。 事件比较简单就是三个事件，和里面的event.touches属性。难点在于程序，在于三个事件的配合。手机端，要注意几个模型：拖拽、轮播图、抛掷、滑动拖出。 最后说一个问题，就是手机中也有click事件，但是click事件比touchstart要晚触发200ms到300ms左右，因为浏览器有默认的一些手指快捷操作，比如双击两次放大视口。如果你用click写了一个div的单击事件，此时点击之后浏览器会等待200~300ms时间看看你有没有第二次点击，如果200~300ms以内没有点击，此时触发你的click事件，如果有点击，则你的click事件业务不发生，而是放大视口。但是touchstart不会等待，只要你碰到了屏幕一定会执行touchstart事件。 注意，a标签执行的是类似click事件，等于说a标签被延迟了200~300触发，所以手机web中越来越不使用a标签跳转了，而是touchstart事件跳转。方法就是让元素携带data-href属性，然后用js批量给他们绑定的touchstart事件，让window.location切换为自己携带的data-href属性的值。 &lt;div id=&quot;box&quot; data-herf=&quot;http://m.taobao.com&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box&quot; data-herf=&quot;http://m.dangdang.com&quot;&gt;&lt;/div&gt; var herfBoxs = document.querySelectorAll(&quot;[data-herf]&quot;); for(var i = 0 ; i &lt; herfBoxs.length ; i++){ herfBoxs[i].index = i; herfBoxs[i].addEventListener(&quot;touchstart&quot;, function(){ window.location = this.getAttribute(&quot;data-herf&quot;); }, true); } 2、拖拽拖拽是一切的基础，我们之前在鼠标的事件中已经学习过，但是你会发现： box.onmousedown = function(){ document.onmousemove = function(){ } } document.onmouseup = function(){ document.onmousemove = null; } 鼠标事件和触摸事件不一样，因为手指移动一定是在屏幕上的。所以touchmove事件不需要写在touchstart事件里面。其他的原理完全一致。 三个事件各自有各自的用处： &lt;script type=&quot;text/javascript&quot;&gt; var img = document.querySelector(&quot;#yangyang&quot;); //信号量 var x = 100; var y = 100; var startX,startY,dx,dy; //触摸开始 img.addEventListener(&quot;touchstart&quot;, function(event){ //阻止页面有默认事件 event.preventDefault(); //拿到这个手指 var thefinger = event.touches[0]; //记录开始触摸的位置 startX = thefinger.clientX; startY = thefinger.clientY; console.log(startX,startY); }, true); //触摸移动 img.addEventListener(&quot;touchmove&quot;, function(event){ //阻止页面有默认事件 event.preventDefault(); //拿到这个手指 var thefinger = event.touches[0]; //记录开始触摸的位置 dx = thefinger.clientX - startX; dy = thefinger.clientY - startY; img.style.left = x + dx + &quot;px&quot;; img.style.top = y + dy + &quot;px&quot;; }, true); //触摸结束 img.addEventListener(&quot;touchend&quot;, function(event){ //阻止页面有默认事件 event.preventDefault(); //改变信号量 x += dx; y += dy; }, true); &lt;/script&gt; 3、指滑轮播图有人研究过，top、left属性的效率，不如transform属性的效率。所以要进行移动什么东西，多考虑transform属性。 屏幕旋转的时候触发window的onresize事件，HTML5也提供了事件onorientationchange，但是这个事件不好用，有些浏览器不支持。所以onresize还是不错的。 4、惯性抛掷拖拽，但是停不下来，有惯性，会慢慢停下来。主要制作方法有两大种： 方法1：overflow:auto; 很智能的就把移除的内容就变成可以滑动、抛掷、惯性的了。 触摸的时候的颜色： -webkit-tap-highlight-color: rgba(0,0,0,0); 方法2：自己写函数，自己模拟 比如新浪首页：https://sina.cn/: 比如我们现在按住了图片，拖拽，松手的地方是-500px，此时它应该根据我们的速度继续让这个盒子运动到终点，每一次都有衰减。 难点就是在获得用户的抛掷速度上面，我们都是使用touchmove事件的最后两个点的距离间隔。 touchmove事件不是移动1px就触发一次！不是！而是CPU有一个时钟周期，3.5GHz，每秒钟再玩命的检测你的鼠标位置，所以你的鼠标的位置值，不是连续的。 很快的抛掷的最后几个点的横坐标： 很慢的抛掷的最后几个点的横坐标： 取最后两个点的间隔，间隔越大表示用户抛掷的速度越快，间隔越小，就是抛掷的慢。 就是用定时器去模拟几次滑动即可，模拟几帧？衰减多快？ 模拟几帧：50帧以上，跟速度成正比 衰减多块：速]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动web百分比布局]]></title>
      <url>%2F2016%2F11%2F28%2Ftitle35%2F</url>
      <content type="text"><![CDATA[1 百分比布局手机web页面都没有版心，都是撑满的，这是因为： 手机本身就小，你再留白边，寸土寸金的地方都浪费了； APP一般都是撑满的，大家手机上网的时候，也希望撑满。 此时就会给制作带来难度，因为尺寸不能写px单位了，比如版心设置为360px，此时iPhone6plus的414视口会看见白色边： 2 百分比布局基础用百分比设置宽度、高度（绝大多数高度可以写为px）、padding、margin的布局方式，叫做流式布局，页面有弹性，所以也叫弹性布局。 &lt;body&gt; &lt;div&gt;&lt;/div&gt; → div是body的亲儿子，60%指的是窗口宽度的60% &lt;/body&gt; &lt;body&gt; &lt;div&gt; &lt;main&gt; → 60%指的是div的width的60%，无视div的padding。 &lt;p&gt;&lt;/p&gt; → 60%指的是main的width的60%，无视div的padding。 &lt;/main&gt; &lt;/div&gt; &lt;/body&gt; 看看padding，都参考父亲的width。注意，竖直方向上的padding也是看父亲的width，而不是height。 &lt;div&gt; &lt;main&gt;&lt;/main&gt; → padding-left:10%;指的是父亲的width的10%，而不是父亲的padding。 padding-top:10%;指的是父亲的width的10%，而不是父亲的height。 &lt;/div&gt; 再来看border，不能用百分比写。 border: 10% solid #000; 再来看margin，一律参考父亲width，不参考父亲的margin和height。 &lt;style type=&quot;text/css&quot;&gt; *{ margin: 0; padding: 0; } div{ width: 200px; height: 600px; border: 10% solid #000; } p{ margin: 10%; } &lt;/style&gt; 总结： 无论margin、padding、width、height，无论竖直方向还是水平方向，参考的都是父亲的width。 3 边框带来的麻烦因为边框不能用百分比来写，所以会带来麻烦： &lt;div&gt; &lt;p&gt;1&lt;/p&gt; → float: left;width:50%; border:1px solid red; &lt;p&gt;2&lt;/p&gt; → float: left;width:50%; border:1px solid red; &lt;/div&gt; p就不能浮动成功，因为总宽度已经是100%多了4个px。 此时边框不能写成百分比，所以就不好减！ div{ width: 80%; height: 200px; margin: 0 auto; background-color: #eee; } p{ float: left; width: 50%; → 这里不能轻松减去2px height: 200px; background: orange; border: 1px solid #000; } 谁说不能？！CSS3中增加了calc函数： div{ width: 80%; height: 200px; margin: 0 auto; background-color: #eee; } p{ float: left; width: calc(50% - 2px); → 谁说不能？！CSS3中增加了calc函数 height: 200px; background: orange; border: 1px solid #000; } 使用的时候一定要在运算符前后加上空格： calc(50%-2px); 应该是 calc(50% - 2px); 兼容性不好，至少安卓4.4还不是特别兼容。 4 CSS3新的盒模型我们之前的盒模型padding、border、margin都是外扩的， div{ width : 200px; height : 200px; padding:10px 20px 30px 40px; } 此时真实面积： 260 × 240 此时加上： div{ width : 200px; height : 200px; padding:10px 20px 30px 40px; box-sizing:border-box; } box表示“盒子”，sizing“尺寸”，“border-box”表示border这一圈的宽度、高度。 此时padding就是内减的，而不是外扩的了： 但是border还是在外面： div{ width : 200px; height : 200px; box-sizing:border-box; padding:10px 20px 30px 40px; border-top:10px solid red; border-left:20px solid red; border-right:30px solid red; border-bottom:40px solid red; margin: 10px; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Less语法的使用简介]]></title>
      <url>%2F2016%2F11%2F27%2Ftitle32%2F</url>
      <content type="text"><![CDATA[1 概述PHP和HTML的关系就是LESS和CSS的关系。 PHP是超文本预处理器 &lt;h1&gt;好高兴啊，我买了一个iPhone&lt;?php echo 3+4; ?&gt;&lt;/h1&gt; 编译为： &lt;h1&gt;好高兴啊，我买了一个iPhone7&lt;/h1&gt; LESS也是CSS预处理器： @a : 100px; div{ width:@a; } 编译为： div{ width:100px; } 用的时候还是用CSS！浏览器不能直接渲染PHP、不能直接渲染Less，必须转为HTML、CSS之后才能渲染。但是写的时候PHP就是比HTML厉害，Less就是比CSS厉害。 2 浏览器编译试着写一个a.less文件： @a : 200px; div{ width:@a; } @a表示定义一个变量。 Less现在先解决编译的问题，然后再学习语法！ 编译有两种，浏览器编译是最简单的： &lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;a.less&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/less.js&quot;&gt;&lt;/script&gt; 此时这个js文件就会发出Ajax请求，去请求a.less文件，此时会把返回的文本，用正则表达式进行编译。编译好的内容，直接内嵌到当前HTML文件中。 3、服务器端编译使用nodejs编译less。 nodejs是一个js的运行环境，可以让js运行在服务器端。原来js运行在浏览器中，JS现在开始可以和PHP、ASP、JSP平起平坐！ 4 less编译工具的安装（手动编译）所以有很多人发明了一些工具，发布出去了，发布到了npm的世界中，nodejs package management，nodejs包管理器。安装完node之后，npm已经被自动安装了。我们可以使用npm命令，轻松的从互联网上下载各式各样的nodejs程序。 npm install命令表示通过连接互联网，从网上下载工具，我们下载的就是less工具。 npm install表示安装，-g表示安装到全局，每个人的全局地址都不一样，请通过 npm root -g来查看 装好less处理器之后，就能通过lessc命令来编译less文件了。 5 利用Grunt自动监控less文件自动编译 Grunt是一个自动化构建工具，依赖NodeJS，说白了就是NodeJS程序而已。要使用Grunt必须现在系统的全局安装grunt-cli程序，cli就是命令行界面的意思。 需要先安装grunt-cli程序，打开系统CMD，输入下面的命令（保证计算机已经联网）： npm install -g grunt-cli 不要忘记-g，必须装在全局。 此时，你的神秘全局文件夹中就有了，此时你就可以在CMD中输入grunt命令而不会报错了。 现在，我们要安装grunt，刚才安装的是grunt-cli，此时来到你的项目文件夹中，注意这句话，来到你的项目文件夹中。 cd 你的项目路径 然后在这个文件夹中安装grunt，不要加-g。 npm install grunt 此时你的项目文件夹中就会出node_modules文件夹： 接下来我们就要告诉Grunt你要做什么，所以我们建立一个Gruntfile.js的文件，告诉Grunt你的任务。注意这个文件的名字不能换！ 下面就是这个Gruntfile.js的代码清单： 配置任务，列出了三个任务：pkg、less、watch。pkg任务是必须写的；less任务就是编译less的任务，watch任务就是监控任务。 部分在罗列插件。grunt-contrib-less、grunt-contrib-watch。 部分是事务队列、清单。 module.exports = function (grunt) { //任务配置,所有插件的配置信息 grunt.initConfig({ pkg: grunt.file.readJSON(&apos;package.json&apos;), //less插件配置 less: { main: { expand: true, src: [&apos;less/*.less&apos;], //核心语句，编译less dest: &apos;desc&apos;, ext: &apos;.css&apos; }, dev: { options: { compress: true, yuicompress:false } } }, watch: { scripts: { files: [&apos;less/*.less&apos;], tasks: [&apos;less&apos;] } } }); //告诉grunt我们将使用插件 grunt.loadNpmTasks(&apos;grunt-contrib-less&apos;); grunt.loadNpmTasks(&apos;grunt-contrib-watch&apos;); //告诉grunt当我们在终端中输入grunt时需要做些什么(注意先后顺序) grunt.registerTask(&apos;default&apos;, [&apos;less&apos;,&apos;watch&apos;]); }; 在项目文件夹里面再次放入一个package.json的文件： { &quot;name&quot;: &quot;text&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;devDependencies&quot;: { &quot;grunt&quot;: &quot;~0.4.5&quot;, &quot;grunt-contrib-less&quot;: &quot;~0.10.0&quot; } } 插件还没有装呢！所以要在项目文件夹中， npm install grunt-contrib-less npm install grunt-contrib-watch 如果全部操作都正确的话，此时你可以在项目文件的CMD中，输入grunt一个单词，可以实时监控你的less文件夹中的less文件。实时编译到dest文件夹中。 6、Less语法http://less.bootcss.com/ 变量： @hong : rgb(252,0,0); div{ background: @hong; border-top: 1px solid @hong; box-shadow: 1px 1px 1px 1px @hong; } 选择器也可以用变量： @dahezideleiming : container; .@{dahezideleiming}{ width:100px; } 文件路径： @imagesURL : &quot;../images&quot;; background: url(&quot;@{imagesURL}/1.jpg no-repeat center center&quot;); 导入文件： @import &quot;01.less&quot;; @import &quot;02.less&quot;; 属性也能用变量： @property: color; .widget { @{property}: #0ee; background-@{property}: #999; } 混合： .xiao{ width: 200px; height: 200px; } .cu{ font-weight: 500; } .xian{ text-decoration: underline; } .zhongyao{ .cu(); .xian(); } 嵌套： nav{ width:100px; height:100px; ul{ float:left; } } 可以接受参数，类似一个函数： .yuanjiao(@dushu){ -webkit-border-radius: @dushu; -moz-border-radius: @dushu; -ms-border-radius: @dushu; -o-border-radius: @dushu; border-radius: @dushu; } when逻辑判断： .haha(@a) when (@a &gt; 100){ width:300px; height: 300px; } .haha(@a) when (@a &lt; 100){ width:200px; height: 200px; } div{ .haha(900); } 编译之后： div { width: 300px; height: 300px; } 循环语句： .zihao(@n) when (@n =&lt; 60) { .fs@{n}{ font-size:1px * @n; } .zihao(@n + 1); } .zihao(10);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP后台语言介绍]]></title>
      <url>%2F2016%2F11%2F25%2Ftitle31%2F</url>
      <content type="text"><![CDATA[1 从一个实验说开去我们做一个实验，新建一个php文件（就是由txt变的）： &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;好高兴啊，我买了一个iPhone&lt;?php echo 1+2+3+1;?&gt;啊，真开心！&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 我们直接在本地拖到浏览器里面查看，我么你发现红色部分浏览器没有渲染： 这是因为浏览器把&lt;?php ?&gt;当做注释了： 此时把1.php上传到服务器上，然后通过浏览器输入网址访问发现这个7被算出来了。此时我们查看源代码： 你会发现之前的&lt;?php ?&gt;里面的内容，变成了7，此时你根本察觉不到这个7从何而来。 2 后台语言后台语言就是执行在服务器上的语言，以php为例，在服务器上执行&lt;?php ?&gt;里面的语句，这个操作我们称为“预处理”。当php执行完毕之后，会发回给浏览器纯的、平的HTML文件。 PHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。它是一个后台语言，后台语言：● 在服务器上运行● 运行之后，发给浏览器就是不带任何后台标记的纯HTML了● 可以操作数据库 常见后台语言：PHP、JSP、ASP、.net、python、scala、node.js等等。 3、在自己的电脑上运行PHPPHP是后台语言，必须运行在服务器上，所以我们不便于调试，只能让自己的电脑也变为服务器。 Apache是世界上第一名的服务器软件，如果你安装了Apache你的电脑就是服务器了。 光安装Apache没有用，还要安装PHP的语言解析引擎。 MySQL是著名的数据库之一，免费开源。 中国人发明了三合一的安装包，叫做phpnow或者WampServer。我们学习phpnow，如果你电脑装不上phpnow，此时就安装wampserver。 4 运行php所有的php文件必须放到根目录运行，一定要通过127.0.0.1来运行，而不能直接把php拖入浏览器。 4.1 壳子所有的php程序要写在： &lt;?php ?&gt; 的壳子里面。 4.1 echo输出 &lt;h1&gt;我买了一个iPhone&lt;?php echo 3.5 * 2; ?&gt;我很开心&lt;/h1&gt; 注意echo是一个关键字，不是函数，所以不要加圆括号： echo(); 注意，php要求所有语句必须有分号结尾，没有分号致命。和JS一样，所有的字符串都要有引号包裹。 &lt;p&gt;&lt;?php echo &quot;你好&quot;; ?&gt;&lt;/p&gt; 4.3 变量PHP中的变量不需要定义，可以直接使用，变量必须以$开头，剩余部分的命名规范和JS一样。 &lt;?php $a = 100; echo $a; ?&gt; 注释和js一样。 &lt;?php // $a = 100; // $b = 200; // echo $a + $b; ?&gt; 连字符是.而不是加号。 &lt;?php $year = 2016; echo “今年是” . $year . “年”; ?&gt; 而在双引号中，用{$}的形式，可以不用连字符，来拼接变量和字符串： echo &quot;今年是{$year}年&quot;; 4.4 for语句、if语句、switch语句、while、do while语句 和js一样一样的,讲讲壳子： &lt;?php for($i = 0 ; $i &lt; 100 ; $i++){ ?&gt; &lt;p&gt;★&lt;/p&gt; &lt;?php } ?&gt; 页面上出现100个星星 4.5 函数和js一样一样。php中的函数不是构造函数，不能被new调用。 编写函数，检查一个数字是不是质数，并且用数字88来测试： &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php function checkZhishu($num){ $count = 0; for($j = 1 ; $j &lt;= $num ; $j++){ if($num % $j == 0){ $count ++; } } if($count == 2){ return true; }else{ return false; } } if(checkZhishu(88)){ echo &quot;是&quot;; }else{ echo &quot;不是&quot;; } ?&gt; &lt;/body&gt; &lt;/html&gt; 4.6 数组array()函数创建数组： &lt;?php $arr = array(&quot;东风&quot;,&quot;二条&quot;,&quot;大饼&quot;,&quot;幺鸡&quot;,&quot;六万&quot;); echo $arr[3]; ?&gt; php是所有语言中，方法第一多的语言！ 数组可以有别名，和js的json很像： &lt;?php $arr = array(&quot;xingming&quot; =&gt; &quot;小明&quot; , &quot;age&quot; =&gt; 12 , &quot;sex&quot; =&gt; &quot;男&quot;); echo $arr[&quot;sex&quot;]; ?&gt; 输出男。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[游戏开发中canvas常见要点]]></title>
      <url>%2F2016%2F11%2F24%2Ftitle30%2F</url>
      <content type="text"><![CDATA[1 游戏图片、音乐资源的管理不管游戏中有多少元素在运动，游戏仅仅有1个定时器，这1个定时器让所有的演员更新、渲染。实际上，一个游戏需要大量的图片，只有当所有图片都load了，游戏才能开始。换句话说，只有当所有图片都load了，主循环setInterval()才能启动。 所以我们的思路就是用JSON imagesObj 存放所有的资源图片的名字，用循环语句for..in…去创建他们的Image对象，然后监听他们的load事件，load一个计数器加1，当load完一个图片的时候，计数器正好等于了数组总长度，此时表示所有图片加载完毕。比较巧妙的是，我们创建了一个R对象，这个对象和imagesObj 的key是一样的，但是v是图片的Image实体，用图片的时候，要通过R打点来找到图片。 &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //如果要使用图片，必须要创建一个Image的实例，然后监听这个img的load事件 //只有load的图片才能上画布 var imagesObj = { &quot;shibing&quot; : &quot;images/shibing.png&quot;, &quot;baozha&quot; : &quot;images/baozha.png&quot; }; //图片资源对象，k和imagesObj是一样的，v是真正的图片Image对象 var R = {}; //已经加载好的图片个数 var count = 0; var cutx = 0; var baozhaxuhao = 0; for(var k in imagesObj){ //创建图片节点 R[k] = new Image(); //设置src R[k].src = imagesObj[k]; //监听是否load R[k].onload = function(){ count++; if(count === 2){ //全部都加载完毕 setInterval(function(){ cutx ++; baozhaxuhao++; if(cutx &gt; 7){ cutx = 0; } if(baozhaxuhao &gt; 11){ baozhaxuhao = 0; } //清屏 ctx.clearRect(0, 0, 800, 600); ctx.drawImage(R.shibing,120 * cutx,150 * 3,120,150,100,100,120,150); ctx.drawImage(R.baozha,192 * (baozhaxuhao % 5),192 * parseInt(baozhaxuhao / 5),192,192,100,100,192,192); },20); } } } &lt;/script&gt; 2、Game类Game类就是中介者模式中的中介者 ##。中介者就是全局变量！比如我们以前 var idx = 10; 信号量，就是全局变量，现在把这个量放入一个类的实例身上，此时这个类就是中介者。 信号量在中介者身上： var game = new Game(); game.idx = 10; 以后所有的元素都是Game类new出来的，我们只需要new出中介者，其他元素都是Game帮我们new出来的。 其他元素如果要互相通信，要通过Game类： game.bird.y 在HTML5游戏中，Game类还将有：主循环、游戏资源管理两个任务。 图片资源管理利用两个对象，RObj和R对象。Robj就是Ajax请求来的文本转为的对象，v是路径； R对象的拥有Robj相同的k，但是v是真实对象： 3 背景类背景类的实例化在Game的start函数里面。而start函数的调用的前提是所有资源已经加载完毕了。说白了，背景类里面可以直接使用图片资源。 canvas里面也有猫腻，也有模式。渲染三张，目的是无缝连续滚动，当猫腻图的左边框到达0点，就拉回来。 4、cancas变形canvas中，提供了变形属性，需要注意的是，所有的变形都是针对画布上下文ctx对象的，而不是某一个要绘制的元素的。 &lt;script type=&quot;text/javascript&quot;&gt; var mycanvas = document.getElementById(&quot;mycanvas&quot;); var ctx = mycanvas.getContext(&quot;2d&quot;); //保存当前的上下文状态 ctx.save(); //移动坐标系 ctx.translate(100,100); //画圆 ctx.fillStyle = &quot;blue&quot;; ctx.beginPath(); ctx.arc(0,0,50,0,Math.PI * 2,true); ctx.fill(); //恢复上下文存档状态 ctx.restore(); //画方块 ctx.fillRect(100, 100, 100, 100); &lt;/script&gt; 坐标系还可以通过 ctx.rotate(1); 渲染1弧度。同样的，旋转的是整个坐标系，而不是某一个元素。 &lt;script type=&quot;text/javascript&quot;&gt; var mycanvas = document.getElementById(&quot;mycanvas&quot;); var ctx = mycanvas.getContext(&quot;2d&quot;); ctx.rotate(1); //1弧度，顺时针 ctx.fillStyle = &quot;orange&quot;; ctx.fillRect(100, 100, 100, 100); &lt;/script&gt; 如果想要让一个元素以自己的几何中心点旋转，此时需要： ① 先让坐标系的原点移动到它的中心点，此时盒子的渲染位置就是负的自己的宽度的一半，负的自己的高度的一半。 ② 旋转 公式： t指的是开始下落后的时间，此时小鸟就要维护自己的小帧号birdF。 //物理公式：s = 1/2gt^2 //掉 birdF++; birdY = 100 + 1.3 * birdF * birdF; birdRotate+=0.08; 5、碰撞检测AABB盒是英语Axis Aligned Bounding Box 轴对齐包围盒。 //更新自己的碰撞检测盒 this.A = this.y + 7; this.B = this.x + 41; this.C = this.y + 41; this.D = this.x + 7; 所谓的ABCD都是边的x或者y，横边就取y值，纵边就取x值。碰撞检测： if( game.bird.A &lt; this.C1 &amp;&amp; game.bird.B &gt; this.D1 &amp;&amp; game.bird.D &lt; this.B1 || game.bird.C &gt; this.A2 &amp;&amp; game.bird.B &gt; this.D2 &amp;&amp; game.bird.D &lt; this.B2 ){ console.log(&quot;撞！&quot;); clearInterval(game.timer); } 6、合成canvasctx.globalCompositeOperation = type 一共有12种值，表示新画的图形和老图形的关系，称为“合成”。 比如： ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(100,100,100,100); ctx.globalCompositeOperation = &quot;source-in&quot;; ctx.beginPath(); ctx.arc(180,180,50,0,7,false); ctx.fillStyle = &quot;red&quot;; ctx.fill(); 像素操作到目前为止，我们尚未深入了解Canvas画布真实像素的原理，事实上，你可以直接通过ImageData对象操纵像素数据，直接读取或将数据数组写入该对象中。稍后我们也将深入了解如何控制图像使其平滑（反锯齿）以及如何从Canvas画布中保存图像。 得到像素： var myImageData = ctx.getImageData(0,0,560,300); 0,0表示起点位置，560是宽度，300是高度。 得到的值可以被使用作为查看初始像素数据。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是”RGBA”格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。 7、事件监听canvas上必须检测范围，因为得不到元素。 贝塞尔曲线： ctx.moveTo(100,100); ctx.bezierCurveTo(200, 50, 400, 50, 400, 100); ctx.stroke(); 点击鼠标的时候，要遍历每个元素，看看点击到了谁，点击到的这个元素，就存入变量。然后让变量中的元素x、用、跟随你的鼠标变化即可。 if(x &gt; ctrl1.x - 5 &amp;&amp; x &lt; ctrl1.x + 5 &amp;&amp; y &gt; ctrl1.y - 5 &amp;&amp; y &lt; ctrl1.y + 5){ diandaodedian = ctrl1; } if(x &gt; ctrl2.x - 5 &amp;&amp; x &lt; ctrl2.x + 5 &amp;&amp; y &gt; ctrl2.y - 5 &amp;&amp; y &lt; ctrl2.y + 5){ diandaodedian = ctrl2; } if(x &gt; start.x - 5 &amp;&amp; x &lt; start.x + 5 &amp;&amp; y &gt; start.y - 5 &amp;&amp; y &lt; start.y + 5){ diandaodedian = start; } if(x &gt; end.x - 5 &amp;&amp; x &lt; end.x + 5 &amp;&amp; y &gt; end.y - 5 &amp;&amp; y &lt; end.y + 5){ diandaodedian = end; } 8、场景Scene管理开始画面、游戏过程、结束画面。 场景现在开始接手管理自己的演员！！但是，场景还是应该把演员注册到game身上，但是管理的权限、谁上台、谁下台，是场景管理器的任务。 监听都是场景管理器负责注册！！ http://squishybird.com/ http://so2.4399.com/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas基本用法]]></title>
      <url>%2F2016%2F11%2F24%2Ftitle29%2F</url>
      <content type="text"><![CDATA[1、Canvas概述 Canvas和Flash的思路完全不一样，Flash是上屏幕之后还是对象，编程语言叫做Action Script也是ECMAScript范畴。Canvas上屏幕之后像素化了，再也不能得到这个对象了，所以要想让这个元素运动，必须擦除整个屏幕、重绘这个元素。Canvas更流畅，手机端也嗷嗷流畅。 canvas是一个双标签，里面的内容是不支持canvas浏览器显示的内容： &lt;canvas width=&quot;800&quot; height=&quot;600&quot;&gt;对不起，你的浏览器不支持画布，请升级浏览器！&lt;/canvas&gt; 宽度、高度写在标签里面，如果写在css中，就变形、扭曲了。 编程： &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 ctx.fillStyle = &quot;lightseagreen&quot;; ctx.fillRect(100,100,300,200); &lt;/script&gt; 坐标系： API： ctx.fillStyle = &quot;red&quot;; //设置填充颜色 ctx.fillRect(100,100,300,200); //绘制一个填充矩形 2、笔触填充笔触也叫作“描边”，Canvas中的任何形状都是由这两个部分组成的。 笔触在canvas中视为一个“Path”的实例，必须stroke之后才能上屏幕；填充用fill才能上屏幕。 制作一个笔触需要用到的API： ctx.beginPath(); //开始绘制路径 ctx.closePath(); //自动封闭路径 ctx.moveTo(100,200); //将画笔移动到某一个点 ctx.lineTo(200,200); //用画笔划线，此时的参数是终点位置，起点就是画笔此时的位置 ctx.stroke(); //划线 比如： //得到画布标签 var myCanvas = document.querySelector(“#myCanvas”); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(“2d”); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.moveTo(100,100); ctx.lineTo(300,300); ctx.lineTo(600,300); ctx.moveTo(600,400); ctx.lineTo(700,400); ctx.stroke(); 在划线之前可以设置线的宽度和颜色： ctx.lineWidth = &quot;10&quot;; ctx.strokeStyle = &quot;red&quot;; ctx.stroke(); 当ctx上已经有一些path之后，此时调用fill()将自动填充。 &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.moveTo(100,100); ctx.lineTo(300,300); ctx.lineTo(600,300); ctx.closePath(); ctx.lineWidth = &quot;10&quot;; ctx.strokeStyle = &quot;red&quot;; ctx.stroke(); ctx.fillStyle = &quot;lightseagreen&quot;; ctx.fill(); &lt;/script&gt; 绘制新的形状的时候，要重新beginPath() &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.moveTo(100,100); ctx.lineTo(300,300); ctx.lineTo(600,300); ctx.closePath(); ctx.lineWidth = &quot;10&quot;; ctx.strokeStyle = &quot;red&quot;; ctx.stroke(); ctx.fillStyle = &quot;lightseagreen&quot;; ctx.fill(); ctx.beginPath(); ctx.moveTo(600,100); ctx.lineTo(600,200); ctx.lineTo(750,200); ctx.lineTo(790,40); ctx.closePath(); ctx.fillStyle = &quot;orange&quot; ctx.fill(); ctx.stroke(); &lt;/script&gt; fillRect()是一个快捷方法，让你省略了beginPath、moveTo、lineTo。所以fillRect (100,100,300,200)等价于： ctx.move(100,100); ctx.lineTo(400,100); ctx.lineTo(400,300); ctx.lineTo(100,300); ctx.closePath(); ctx.fill(); 3、弧和圆形画弧线用arc方法，它属于Path。所以画弧之前要beginPath()一下。 &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.arc(200,200,100,0,1,true); //圆心坐标200,200。100是半径。0开始角度，1终止角度，true表示逆时针 ctx.stroke(); &lt;/script&gt; 坐标系，Canvas中的角度都是弧度制，1弧度等于57.3度： 完整的圆终止角度就是Mathi.PI * 2 ctx.arc(200,200,200,0,Math.PI*2,false); 画20个同心圆。 for(var i = 10 ; i &lt;= 400 ; i+=5){ ctx.beginPath(); ctx.arc(200,200,i,0,Math.PI * 2,true); ctx.strokeStyle = &quot;rgb(&quot; + i + &quot;,&quot; + i + &quot;,&quot; + i + &quot;)&quot;; ctx.stroke(); } https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors 4、文字fillText函数用来写字，参数是：文字内容、坐标位置 ctx.fillText(&quot;文字内容&quot;,100,100); 可以使用font属性来调整字号和字形： ctx.font = &quot;50px 微软雅黑&quot;; ctx.fillText(&quot;你好&quot;,100,100); 5、new Image()使用图片使用图片有一个固定的语法，必须new Image()然后设置src，监听load事件，使用ctx.drawImage()函数上画布。 var img = new Image(); img.src = &quot;images/0.jpg&quot;; img.onload = function(){ ctx.drawImage(img,100,100); } ctx.drawImage()里面的参数是图片对象、左上角的坐标。 ctx.drawImage()里面可以有四个数字参数，增加了宽度、高度的设置，此时图片会被扭曲： var img = new Image(); img.src = &quot;images/0.jpg&quot;; img.onload = function(){ ctx.drawImage(img,100,100,250,80); } 如果要使用切片，就是9个参数： var img = new Image(); img.src = &quot;images/0.jpg&quot;; img.onload = function(){ ctx.drawImage(img,168,150,126,141,100,100,300,300); } 红色部分描述的是切片的事儿： 蓝色部分是上屏幕之后的事儿： 公式： ctx.drawImage(img,切片x,切片y,切片w,切片h,上屏x,上屏y,上屏w,上屏h); 6、运动canvas中元素不能运动的，因为上屏幕之后就再也得不到它了，没有任何变量能够持有一个: var box = ctx.fillRect(100,100,200,200); 必须重绘一个新的矩形！利用视觉暂留，形成运动！ 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 →清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 →…… 清屏： ctx.clearRect(0,0,800,600); 实际上是清除一个矩形区域，我们一般清除整个画布。 面向对象制作运动，结构： function Circle(){ } Circle.prototype.render = function(){ } Circle.prototype.update = function(){ } var yuan = new Circle(); setInterval(function(){ ctx.clearRect(0,0,800,600); yuan.update(); yuan.render(); },20); 每一帧都要更新演员、渲染演员。只要这个东西是演员，它必须提供update、render方法。 面向接口编程，接口就是具有一定方法的类的集合。说白了，就比如说很多类都有render、update方法，此时Actor（演员）就是一个接口，Circle和Fang类都是这个接口的实现。“接口就是类的类”。 说白了：我们要制作Actor类，Actor类提供update、render方法，并且会把自己放入总数组中。所有演员类，都必须继承这个类，重写Actor和render方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见字符串、数组算法]]></title>
      <url>%2F2016%2F11%2F22%2Ftitle28%2F</url>
      <content type="text"><![CDATA[常见字符串算法1、短横变驼峰把单词border-left-color变为borderLeftColor。 此时有两种方法： 方法1：border-left-color用字符串的split方法变为数组：[“border”,”left”,”color”]，然后遍历这个数组第1项开始的每项，把首字母toUpperCase()变为大写然后与剩余字母连接，然后join到一起，就是borderLeftColor。 // 短横变驼峰函数 function change(str){ //拆为数组 var strArr = str.split(&quot;-&quot;); //遍历数组 for(var i = 1 ; i &lt; strArr.length ; i++){ var chars = strArr[i]; //将数组的这一项的字符串变为首字母变为大写，与剩余字母做拼接 strArr[i] = chars[0].toUpperCase() + chars.slice(1); } //拼接 return strArr.join(&quot;&quot;); } 方法2：正则表达式。border-left-color用正则表达式去replace替换，替换什么？替换所有(-字母)变为大写字母。 var str = &quot;我爱周杰伦，周杰伦很帅，我要和周杰伦生猴子&quot;; str = str.replace(/周杰伦/g,&quot;杨洋&quot;); console.log(str); var str = &quot;我买了一个手机3000元，电脑5000元，电饭锅100元。今天很热，18度。&quot;; str = str.replace(/(\d+)元/g,function(match,$1,index){ return parseInt($1 / 6) + &quot;美元&quot;; }); console.log(str); var str = &quot;border-left-color&quot;; str = str.replace(/\-(\w)/g,function(match,$1){ return $1.toUpperCase(); }); console.log(str); 2 、寻找连续三项相同字符串现在给你一个字符串，判断里面有没有连续三位或者三位以上相同，如果有，就返回下标数组。 比如： “aabbbccddddee” 返回[2,3,4,7,8,9,10]。 双指针法。在字符串的题目中，基本99%都能用双指针法，比如最大连续相同子串、最大连续重复子串等等，都能用双指针法。 &lt;script type=&quot;text/javascript&quot;&gt; var str = &quot;aabbbccddddee&quot;; //位置是0、1 var i = 0; var j = 1; //结果 var result = []; while(i &lt; str.length){ if(str[i] != str[j]){ //判断是不是到了3位 if(j - i &gt;= 3){ //为位号推入数组 for(var m = i; m &lt;= j-1 ; m++){ result.push(m); } } //i追上j，j后移一位 i = j; } //不管怎么样j都要后移 j++; } console.log(result); &lt;/script&gt; 3 给数字加上千分位符输入12345678901，返回”12,345,678,901”。 数组和字符串的相互转换方法很好用，要敏感一些！实际上就是[12,345,678,901]进行join(“,”)就是结果。所以问题就简化为把12345678901这个数字拆分为数组！数组长度11。 找找规律： 12345678901 str.slice(-3) → 很特殊，没有第二个参数 12345678901 str.slice(-6,-3) 12345678901 str.slice(-9,-6) 12345678901 str.slice(-12,-9) 程序： &lt;script type=&quot;text/javascript&quot;&gt; var num = 12433245245432; //除了null、undefined之外的任何字面量都有toString()方法，表示变为字符串 var length = num.toString().length; //循环终点 var end = -Math.ceil(length / 3) * 3; //结果数组，把特殊的末尾三位放入数组 var result = [num.toString().slice(-3)]; //遍历-6、-9、-12、-15…… //截取的是slice(-6,-3) slice(-9,-6) slice(-12,-9) for(var i = -6 ; i &gt;= end ; i-=3){ result.unshift(num.toString().slice(i,i+3)); } //把数组变为字符串 console.log(result.join(&quot;,&quot;)); &lt;/script&gt; 还可以用正则表达式，我们慢慢推导： \B是一个特殊的正则的东西，表示字母边界，非单词边界。\b表示单词边界。 &lt;script type=&quot;text/javascript&quot;&gt; var str = &quot;abc,adsf haha xixi&quot;; str = str.replace(/\B/g,&quot;★&quot;); console.log(str); &lt;/script&gt; 出现★的地方就是字母边界 然后说正则中的(?=)语法，表示定语从句，位置描述。 比如，我们想替换字符串中所有后面是“你”字的“爱”字. var str = &quot;我爱你，你却爱着他&quot;; str = str.replace(/爱(?=你)/g,&quot;★&quot;); console.log(str); 替换字符串中所有后面有“3位数字”的字母\B ： var str = &quot;12324324324&quot;; str = str.replace(/\B(?=\d{3})/g,&quot;★&quot;); console.log(str); 比较乱，因为我们没有限制边界 替换字符串中所有后面到单词结尾有“3位数字”的\B ： var str = &quot;12324324324&quot;; str = str.replace(/\B(?=\d{3}$)/g,&quot;★&quot;); console.log(str); 替换字符串中所有后面到单词结尾有一个或多个“3位数字”的\B ： var str = &quot;12324324324&quot;; str = str.replace(/\B(?=(\d{3})+$)/g,&quot;★&quot;); console.log(str); 这就是答案，只需要把★改为逗号即可。 常见数组算法数组没有indexOf方法，也就是说我给你一个数组，问你这个数组中没有一个项是数字6，你必须遍历所有项目，一个项目一个项目的比对，是不是数字6。 1 数组的去重给你一个数组[3,4,6,32,2,3,4,57,6] 返回去掉重复项的数组[3,4,6,32,2,57]。难点就是验证数字是不是已经在数组中了，而如果要遍历，产生的时间复杂度是很高的。 大家的普遍算法就是，创建一个新的空数组[]，然后遍历原数组，遍历到原数组的每一项的时候，再遍历新的这个数组依次比对，如果新数组中没有这个项，就push进去。 var arr = [3,4,6,32,2,3,4,57,57,6]; var result = []; for(var i = 0 ; i &lt; arr.length ; i++){ for(var j = 0 ; j &lt; result.length ; j++){ //如果遇见相同的数字，立即终止内层循环 if(arr[i] == result[j]) break; } //验收，看看是不是result中的每一项都不等于arr[i] if(j == result.length){ result.push(arr[i]); } } console.log(result); 我们可以升级，升级为可以对原来的数组排序，把[3,4,6,32,2,3,4,57,6] 先排序，变为[2, 3, 3, 4, 4, 6, 6, 32, 57]。 再次做一个结果空数组[]，把数组中的每一项和结果数组中的最后一项进行比较，如果不同就说明真的不同了。 方法3是我们要着重介绍的，就是给数组简历一个索引对象。我们创建一个空对象，{}。每次验证对象中有没有这个项，如果没有就push进入result数组，同时把对象中创建一个属性就是你这个数字，值设为1。 {&quot;3&quot; : 1 , &quot;4&quot; : 1 , &quot;6&quot; :1 , &quot;32&quot;:1 , &quot;2&quot;:1 , &quot;57&quot;:1} 哲学就是用对象弥补数组没有indexOf的缺陷！ var arr = [3,4,6,32,2,3,4,57,6]; var temp = {}; var result = []; for(var i = 0 ; i &lt; arr.length ; i++){ //检查对象中有没有这个属性，如果没有这个属性，那么推入结果数组，并且让对象添加这个属性。属性值设置为1。 if(!temp[arr[i]]){ result.push(arr[i]); temp[arr[i]] = 1; } } console.log(result); console.log(temp); 2 数组的差集返回在arr1里面但是不在arr2里面的项，比如： arr1是[1,2,3,4,5,3] arr2是[3,4,5,6,7] 返回[1,2] 根据我们刚才数组去重的经验，我们可以先遍历arr2，设置一个空对象，把arr2的所有值作为这个对象的属性添加上。然后遍历arr1的时候，只需要看对象身上有没有这个属性即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery排序常见方法]]></title>
      <url>%2F2016%2F11%2F20%2Ftitle26%2F</url>
      <content type="text"><![CDATA[jQuery排序1、eq（）整体排序通过$()得到jQuery对象，可以继续通过eq()获得某一个元素。 下标问题：jQuery对象得到的原生对象会进行一个自己的排列，组成一个队列。eq()方法是从这个队列里去进行排序。与原来页面的结构无关。 1 //不能用一个下标1全部选中，选中的仅仅是所有被选中的p组成的队列里的第一个 2 // $(&quot;div p&quot;).eq(1).css(&quot;background&quot;,&quot;red&quot;); 3 // $(&quot;div p&quot;).eq(5).css(&quot;background&quot;,&quot;red&quot;); 4 // $(&quot;div p&quot;).eq(9).css(&quot;background&quot;,&quot;red&quot;); 5 // $(&quot;div p&quot;).eq(13).css(&quot;background&quot;,&quot;red&quot;); 上面的排序：将所有的p选出来之后，进行新的排序，新顺序是eq方法的下标。 1 $(&quot;div p.cur&quot;).eq(1).css(&quot;background&quot;,&quot;red&quot;); 上面的排序：将所有类名叫做cur的元素全部选取出来，进行排序，新顺序是我们的eq的下标顺序，与原来节点关系的排序没关系。 2、index()在兄弟关系中的排序Index()这个方法获得的是元素在html结构中，在自己的同级元素中的位置，与获得的jQuery新队列没关系。 1 //给p标签绑定事件，点击输出自己的index（） 2 $(&quot;div p&quot;).click(function(){ 3 console.log($(this).index()); 4 }); 1 //给p标签绑定事件，点击输出自己的index（） 2 $(&quot;div p.cur&quot;).click(function(){ 3 console.log($(this).index()); 4 }); 与新队列无关，与兄弟中的排行有关。 3、对应和排他tab栏效果：给上面的元素添加事件，对应的下面的新闻显示。 可以通过相同的index（）得到的兄弟之间的排序，找到对应关系。 排他：将不是与我对应的内容设置成默认，与我对应的元素设置特殊。 1 $(&quot;.top span&quot;).mouseenter(function(){ 2 //自己的排他 3 $(this).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;); 4 //具体信息的排他 5 $(&quot;.bottom ul&quot;).eq($(this).index()).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;); 6 }); 出现一个问题：就是我们所有的ul元素的一个大排队，我们选中的永远是第一个tab栏的ul。 解决方法：不要拆开去选择元素，所有的元素都是通过节点关系，从自身出发。 1 //避免所有的tab栏大排序，所有的代码都是从事件元素自身出发去找关系 $(this).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;).parent().siblings().children().eq($(this).index()).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;); 4、each()遍历jQuery对象each()遍历我们jQuery对象里的元素队列。 有一个参数：function，函数参数，规定了遍历过程中对每一个元素做的工作。 1 $(“p”).each(function(){ 2 对每一个元素的操作。 3 }); function函数内部有一个默认的参数：i，指的就是这一次遍历的元素在整体队列里的下标。 1 $(&quot;div&quot;).each(function(i){ 2 //i就是每次进来遍历的元素的下标 3 //this指向的就是每次进来的那个元素 4 $(this).children().eq(1).css(&quot;background&quot;,&quot;red&quot;); 5 }); 如果遇到：每一个元素内怎么样，一定要用each方法。 1 $(&quot;div&quot;).each(function(i){ 2 //i就是每次进来遍历的元素的下标 3 //this指向的就是每次进来的那个元素 4 $(this).children().eq(1).css(&quot;background&quot;,&quot;red&quot;); 5 }); 制作：折叠选项卡的效果 1 //获取h2元素，每一个添加点击事件 2 // ＋号和-号切换，兄弟元素展开或收起 3 $(&quot;.box h2&quot;).each(function(){ 4 var $h2 = $(this).parent().siblings().children(&quot;h2&quot;); 5 $(this).click(function(){ 6 //自己的兄弟展开 7 var $span = $(this).children(&quot;span&quot;); 8 $span.html($span.html() == &quot;+&quot; ? &quot;-&quot; : &quot;+&quot;); 9 $(this).siblings().slideToggle(300); 10 //其他h2的兄弟隐藏 11 $h2.children(&quot;span&quot;).html(&quot;+&quot;); 12 $h2.siblings().slideUp(300); 13 }) 14 })]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[animate常见知识]]></title>
      <url>%2F2016%2F11%2F20%2Ftitle27%2F</url>
      <content type="text"><![CDATA[1、概述animate是动画的意思。是jQuery自己的一个运动方法。非常好用的方法。 原生js动画必须依靠setInterval，根据步长和间隔时间来操作运动。 animate动画方法内部给我们用setInterval已经封装好了。不用自己去计算步长。 方法通过两个参数决定运动的结束位置和总时间。 语法： 1 .animate(结束位置JSON，运动总时间) 第一个参数必须是JSON对象：即便只有一个属性变化也需要写在JSON。 第二个参数是总时间：经过多长时间运动停止，习惯给一个变量during。 原来JS的代码： 1 var demo = document.getElementById(&quot;demo&quot;); 2 var now = 100; 3 var timer = setInterval(function(){ 4 now += 10; 5 if(now &gt;= 400){ 6 now = 400; 7 clearInterval(timer); 8 } 9 demo.style.width = now + &quot;px&quot;; 10 },50); jQuery的方法： 1 $(&quot;.demo&quot;).animate({&quot;width&quot;:400},1500); 什么样的css属性能够做animate动画。 很多属性值为数值的属性可以参与运动。css3里面也有一部分可以参与，大部分不能参与的。 不能参与的： “background-color” : “red” //css3的过渡动画可以完成 “background-position”:”0 0” 1 //jQuery的运动函数方法 2 $(“.demo”).animate({ 3 “width”:200, 4 “height”:200, 5 “opacity”:0.5, 6 “border-width”:20, 7 “left”:200, 8 “top”:200, 9 “padding”:50, 10 “border-radius”:”50%”, 11 //不能参与动画 12 //“background-color” : “red”//css3的过渡动画可以完成 13 //“background-position”:”0 0” 14 },400); 2、动画排序①同一个元素身上的运动有一个叫做“动画排队”的现象。 如果同一个元素，身上加了多个运动函数，会进行排队，谁先写的，谁先动。 1 $(&quot;.demo&quot;).animate({&quot;left&quot;:600},during); 2 $(&quot;.demo&quot;).animate({&quot;top&quot;:400},during); 3 $(&quot;.demo&quot;).animate({&quot;left&quot;:0},during); 4 $(&quot;.demo&quot;).animate({&quot;top&quot;:0},during); 给一个元素添加事件中有运动函数，多次触发事件也会造成动画排队。知道最后一个事件动画结束。 1 $(&quot;.demo&quot;).mouseenter(function(){ 2 $(this).children(&quot;p&quot;).slideDown(during); 3 }); 4 $(&quot;.demo&quot;).mouseleave(function(){ 5 $(this).children(&quot;p&quot;).slideUp(during); 6 }); ②不同元素之间都有动画，不会排队。 原理：animate函数封装时，用的是setInterval异步语句。同一个元素的动画有一个函数节流操作。 animate就是一个异步语句，异步语句在执行的时候，不会影响后面语句的执行。 1 $(&quot;.demo1&quot;).animate({&quot;left&quot;:600},during); 2 $(&quot;.demo1&quot;).animate({&quot;top&quot;:400},during); 3 $(&quot;.demo1&quot;).animate({&quot;left&quot;:0},during); 4 $(&quot;.demo1&quot;).animate({&quot;top&quot;:0},during); 5 $(&quot;.demo2&quot;).animate({&quot;left&quot;:600,&quot;top&quot;:400},during); ③不是动画的语句，也不会等待。 1 $(&quot;div p&quot;).css(&quot;display&quot;,&quot;block&quot;); 3、异步语句和回调函数animate运动方法就是一个异步语句，我们也可以给它一个回调函数，告诉我们运动结束之后我可以做什么事。 animate方法有一个回调函数的参数，第三个参数可以传递一个回调函数。 1 $(&quot;.demo1&quot;).animate({&quot;top&quot;:0},during,function(){ 2 $(&quot;.demo1 p&quot;).css(&quot;display&quot;,&quot;block&quot;); 3 }); 4 $(&quot;.demo2&quot;).animate({&quot;left&quot;:600,&quot;top&quot;:400},during,function(){ 5 $(&quot;.demo2 p&quot;).css(&quot;display&quot;,&quot;block&quot;); 6 }); 其他的运动方法也有回调函数： slideDown()、slideUp()、fadeIn()、fadeOut()、show(1000)、hide(1000)这几个方法也是运动的方法，都有一个回调函数。 1 $(&quot;.demo1 p&quot;).slideDown(500,function(){ 2 alert(&quot;出现啦&quot;); 3 }); 4、delay()延迟动画所有的动画语句都可以在前面有一个延迟语句。表示这条语句执行之后，动画不是立即执行，要等待一段时间再执行。 书写位置：在动画语句之前。 参数：规定的是延迟时间。 1 $(&quot;.demo2&quot;).delay(2000).animate({&quot;left&quot;:600,&quot;top&quot;:400},during,function(){ 2 $(&quot;.demo2 p&quot;).css(&quot;display&quot;,&quot;block&quot;); 3 }); 只要是动画方法都可以写delay延迟。 slideDown()、slideUp()、fadeIn()、fadeOut()、show(1000)、hide(1000)都可以进行延迟。 1 $(&quot;.demo2 p&quot;).delay(1000).slideDown(1000); 2 $(&quot;.demo2 p&quot;).delay(1000).slideUp(1000); 要想延迟一个运动，前面必须每次都加delay。 写法等价于： 1 $(&quot;.demo2 p&quot;).delay(1000).slideDown(1000).delay(1000).slideUp(1000); 5、stop()停止动画可以停止我们的动画。 两个参数：都是布尔值。 第一个参数：表示是否清空排队的动画。true表示清空，false表示不清。 第二个参数：表示是否立即完成当前动画。true表示立即完成，false表示立即停止不动。 默认不写：两个参数都是false。 1 //如果参数都是false，不清空动画队列，立即停止当前动画，进入下一个排队的动画 2 $(&quot;#ff&quot;).click(function(){ 3 $(&quot;.demo1&quot;).stop(); 4 }); 5 //第一个是true，第二个是false，清空后面的动画，立即停止当前动画 6 $(&quot;#tf&quot;).click(function(){ 7 $(&quot;.demo1&quot;).stop(true); 8 }); 9 //第一个是true，第二个是true，清空后面的动画，立即走完当前动画 10 $(&quot;#tt&quot;).click(function(){ 11 $(&quot;.demo1&quot;).stop(true,true); 12 }); 13 //第一个是false，第二个是true，不清空后面的动画，立即走完当前动画，并且进入下一个排队的动画 14 $(&quot;#ft&quot;).click(function(){ 15 $(&quot;.demo1&quot;).stop(false,true); 16 }); 6、解决动画排队问题我希望新的动画被触发时，希望前面的这个元素动画全部清空，立即停止。 防止用户频繁触发事件，动画等待。 方法1： 用stop()。清空前面所有动画队列，立即停止当前。参数值需要传第一个true。 1 $(&quot;.demo&quot;).mouseenter(function(){ 2 $(this).children(&quot;p&quot;).stop(true).slideDown(during); 3 }); 4 $(&quot;.demo&quot;).mouseleave(function(){ 5 $(this).children(&quot;p&quot;).stop(true).slideUp(during); 6 }); 为了防止频繁流氓操作，只要添加一个运动动画，前面都必须加一个stop(true)。 方法2： 节流方法：判断元素是否在运动过程中，如果是，就不执行后面的其他操作，如果不是，就执行后面的动画。 元素都有一个方法叫做is（）,判断是否处于某种状态。 1 $(“p”).is(“:animated”); 返回true和false。 1 var during = 500; 2 $(&quot;.demo&quot;).mouseenter(function(){ 3 if($(this).children(&quot;p&quot;).is(&quot;:animated&quot;)){ 4 return; 5 } 6 $(this).children(&quot;p&quot;).slideDown(during); 7 }); 8 $(&quot;.demo&quot;).mouseleave(function(){ 9 if($(this).children(&quot;p&quot;).is(&quot;:animated&quot;)){ 10 return; 11 } 12 $(this).children(&quot;p&quot;).slideUp(during); 13 });]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery节点关系]]></title>
      <url>%2F2016%2F11%2F20%2Ftitle25%2F</url>
      <content type="text"><![CDATA[节点关系jQuery控制元素时，都是批量控制。 添加事件，元素本身运动、或者其他元素运动，都想跟事件元素找一些关系。 jQuery帮我们简化了这个找关系的过程，封装了一系列的方法可以帮我们找到父亲、儿子、兄弟、祖先、孙子等元素。 1、$(this)自己事件内部有一个$(this)的对象，指向的就是触发事件的这个元素本身。 就是原生js里的事件函数内的那个this，用$()将this转成jQuery对象，就能调用jQuery的方法。this不要加引号。 1 // 谁触发事件谁动 2 $(&quot;p&quot;).click(function(){ 3 $(this).animate({&quot;left&quot;:1000},1000); 4 }); 2、parent()父亲寻找元素父级的方法：必须加小括号，找到的也是亲生的父亲。爷爷和叔叔都不能。 案例：点击一个元素，让他的父亲背景变色。 1 $(&quot;p&quot;).click(function(){ 2 $(this).parent().css(&quot;background&quot;,&quot;lightblue&quot;); 3 }); 说明：方法返回的是某一个元素的父亲的jQuery对象，继续打点调用jQuery方法。 3、children()儿子寻找子级元素的方法：必须加小括号，选中的是元素的所有儿子级元素。孙子级的元素选不中。 案例：点击一个元素，让他的子级全部消失。 1 //让点击元素的子级全部消失 2 $(&quot;div&quot;).click(function(){ 3 $(this).children().hide(300); 4 }); 方法可以传递参数：还是一个选择器，指的是我要选择儿子级里面还要满足选择器要求的那些元素。 1 //要选择儿子级元素中符合选择器要求的部分 2 $(&quot;div&quot;).click(function(){ 3 $(this).children(&quot;.cur&quot;).hide(300); 4 }); 4、siblings()兄弟 寻找的是同级的兄弟元素：方法必须加小括号，找到的是亲兄弟元素。 案例：点击一个元素，让他的兄弟都变色，自身不变色。 1 $(&quot;div&quot;).children().click(function(){ 2 $(this).siblings().css(&quot;background&quot;,&quot;red&quot;); 3 }); 可以通过参数进行选择器筛选. 1 //筛选h2的兄弟元素 2 $(&quot;div&quot;).children().click(function(){ 3 $(this).siblings(&quot;h2&quot;).css(&quot;background&quot;,&quot;red&quot;); 4 }); 指的是选中的是兄弟元素中的h2标签。 5、连续打点调用案例：点击一个元素，让他自己变红，让他的兄弟编绿，父亲变蓝，父亲的兄弟变紫色，兄弟的儿子变金色。 1 $(&quot;div&quot;).children().click(function(){ 2 $(this).css(&quot;background&quot;,&quot;red&quot;) //自己 3 .siblings().css(&quot;background&quot;,&quot;green&quot;) //自己的兄弟 4 .parent().css(&quot;background&quot;,&quot;blue&quot;)//自己和兄弟的父亲 5 .siblings().css(&quot;background&quot;,&quot;purple&quot;) //父亲的兄弟 6 .children().css(&quot;background&quot;,&quot;gold&quot;); //父亲兄弟的儿子 7 }); 原理：一个jQuery对象打点调用完自己的任何方法，都会return一个对象，就是jQuery对象本身。 1 $(&quot;p&quot;).html(&quot;哈哈&quot;).css(&quot;background&quot;,&quot;skyblue&quot;); 6、其他节点关系find()：找的是元素的后代的一些元素，根据参数的选择器去选择。 1 $(&quot;div&quot;).find(&quot;span&quot;).css(&quot;background&quot;,&quot;#00f&quot;) next()：选中的是当前元素的下一个元素，必须是同级的。 1 $(&quot;div&quot;).children().click(function(){ 2 $(this).next().css(&quot;background&quot;,&quot;#f00&quot;); 3 }) nextAll()：选中的是当前元素后面的所有兄弟元素。内部可以传参数，选择符合选择器的后面的兄弟。 1 $(&quot;div&quot;).children().click(function(){ 2 $(this).nextAll().css(&quot;background&quot;,&quot;#f00&quot;); 3 }) prev()：选中的是当前元素的上一个元素，必须是同级的。 1 $(&quot;div&quot;).children().click(function(){ 2 $(this).prev().css(&quot;background&quot;,&quot;#f00&quot;); 3 }) prevAll()：选中的是当前元素前面的所有兄弟元素。内部可以传参数，选择符合选择器的后面的兄弟 1 $(&quot;div&quot;).children().click(function(){ 2 $(this).prevAll().css(&quot;background&quot;,&quot;#f00&quot;); 3 }) parents()：选择的是包含html标签在内的所有祖先元素。内部可以传参数，选择符合选择器的祖先元素。 1 $(&quot;p&quot;).parents(&quot;div&quot;).css(&quot;background&quot;,&quot;pink&quot;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery常用方法]]></title>
      <url>%2F2016%2F11%2F18%2Ftitle24%2F</url>
      <content type="text"><![CDATA[jQuery常用方法1、html()相当于我们原生js里面的innerHTML方法。给元素内部添加内容。 参数必须是字符串。 1 $(&quot;div&quot;).html(&quot;你好，这是一个div&quot;); 手动的给标签内部加其他标签。 1 $(&quot;div&quot;).html(&quot;&lt;p&gt;&lt;a href=\&quot;#\&quot;&gt;你好&lt;/a&gt;&lt;/p&gt;&quot;); 读取内容：只能读取第一个元素内的内容。 1 console.log($(&quot;div&quot;).html()); 2、addClass()和removeClass()增加类名：addClass 移除类名：removeClass 要添加或移除的类名作为参数传入小括号内。 1 $(&quot;.ad&quot;).click(function(){ 2 $(&quot;.box&quot;).addClass(&quot;demo&quot;); 3 }); 4 $(&quot;.re&quot;).click(function(){ 5 $(&quot;.box&quot;).removeClass(&quot;demo&quot;); 6 }); 操作过程中，不会影响元素原有的类名或其他类名。 3、attr()调用或更改html元素的属性和属性值。 1 //获取某一个属性值 2 // console.log($(&quot;.ad&quot;).attr(&quot;type&quot;)); 3 //添加属性，传两个参数，第一个属性名，第二个属性值 4 // $(&quot;.box&quot;).attr(&quot;id&quot;,&quot;demo&quot;); 修改属性值。 1 $(&quot;input&quot;).click(function(){ 2 $(&quot;img&quot;).attr(&quot;src&quot;,&quot;images/cat2.jpg&quot;); 3 }); 4、常用的事件jQuery的事件不需要写on。 单击事件：click()； 1 $(&quot;input&quot;).click(function(){ 2 $(&quot;img&quot;).attr(&quot;src&quot;,&quot;images/cat2.jpg&quot;); 3 }); 鼠标移上：mouseenter鼠标进入 1 //鼠标移上元素添加类名 2 $(&quot;.box&quot;).mouseenter(function(){ 3 $(&quot;.box&quot;).addClass(&apos;demo&apos;); 4 }); 鼠标移出：mouseleave鼠标离开方法 1 //鼠标移出元素移除类名 2 $(&quot;.box&quot;).mouseleave(function(){ 3 $(&quot;.box&quot;).removeClass(&apos;demo&apos;); 4 }); 还有一种on的写法：本身也是一个方法，有两个参数，第一个参数是事件类型，第二个参数是事件函数。 1 //on方法添加事件 2 $(&quot;input&quot;).on(&quot;click&quot;,function(){ 3 $(&quot;img&quot;).attr(&quot;src&quot;,&quot;images/cat2.jpg&quot;); 4 }); 5、css()作用：调用和更改css 样式。 css()方法可以传递两个参数：如果只传一个参数，调用属性计算后的样式，如果传递两个参数，就是修改这个样式。 1 语法：jQuery.css(属性名，属性值); 传递一个参数，表示调用属性值： 得到的值是一个字符串形式的数据，不能直接参与运算。 1 console.log($(&quot;.box&quot;).css(&quot;width&quot;)); 传递两个参数，表示赋值： 1 $(&quot;img&quot;).css(&quot;width&quot;,&quot;200px&quot;); 属性名既可以写驼峰也可以写css写法： 1 //既可以写驼峰也可以写css写法 2 // $(&quot;div&quot;).css(&quot;background-color&quot;,&quot;yellowgreen&quot;); 3 $(&quot;div&quot;).css(&quot;backgroundColor&quot;,&quot;skyblue&quot;); 属性值很灵活，可以直接写数字不带单位，还可以写带单位或不带单位的字符串。 1 $(&quot;div&quot;).css(&quot;width&quot;,200); 2 $(&quot;div&quot;).css(&quot;height&quot;,&quot;200px&quot;); 3 $(&quot;div&quot;).css(&quot;border-width&quot;,&quot;5&quot;); 数值甚至可以写成加等的形式： 1 $(&quot;div&quot;).click(function(){ 2 $(&quot;div&quot;).css(&quot;width&quot;,&quot;+=20px&quot;); 3 }); 如果我们设置多个属性，将多个属性写在JSON对象。 1 //同时设置多个属性 2 $(&quot;div&quot;).css({ 3 &quot;width&quot; : 200, 4 &quot;height&quot; : 200, 5 &quot;border-width&quot; : 5 6 }); 6、hide()和show()就是隐藏和显示某一个元素。 1 $(&quot;.hide&quot;).click(function(){ 2 $(&quot;img&quot;).hide(); 隐藏 3 }) 4 $(&quot;.show&quot;).click(function(){ 5 $(&quot;img&quot;).show(); 显示 6 }) 可以传递一个时间参数，控制隐藏和显示的中间时间。 1 $(&quot;.hide&quot;).click(function(){ 2 $(&quot;img&quot;).hide(1000); 3 }) 4 $(&quot;.show&quot;).click(function(){ 5 $(&quot;img&quot;).show(1000); 6 }) 隐藏：伴随着透明度从设置透明度到0的变化，还有宽高从设置值到0的动画。 方法可以在显示和隐藏之间进行切换：toggle()； 1 $(&quot;.toggle&quot;).click(function(){ 2 $(&quot;img&quot;).toggle(1000); 3 }); 7、slideDown和slideUpslideDown()：滑动显示（方向不一定）； slideUp()：滑动隐藏； 本身就有运动过程。默认运动时间400毫秒。 1 $(&quot;.up&quot;).click(function(){ 2 $(&quot;img&quot;).slideUp(); 3 }); 4 $(&quot;.down&quot;).click(function(){ 5 $(&quot;img&quot;).slideDown(); 6 }); 隐藏的前提：必须是display:block; 显示的前提：必须是display:none; 中间有自己定义的动画：内部的结构，说明我们以什么方式隐藏和显示。 切换：slideToggle()。可以自定义运动时间： 1 $(&quot;.up&quot;).click(function(){ 2 $(&quot;img&quot;).slideUp(1000); 3 }); 4 $(&quot;.down&quot;).click(function(){ 5 $(&quot;img&quot;).slideDown(1000); 6 }); 7 $(&quot;.toggle&quot;).click(function(){ 8 $(&quot;img&quot;).slideToggle(1000); 9 }); 8、fadeIn和fadeOut表示淡入和淡出：透明度发生的变化。 fadeIn：透明度变大，显示元素，淡入。 fadeOut：透明度变到0，隐藏元素，淡出。 默认运动时间是400毫秒，可以自定义时间。 1 $(&quot;.out&quot;).click(function(){ 2 $(&quot;img&quot;).fadeOut(1000); 3 }); 4 $(&quot;.in&quot;).click(function(){ 5 $(&quot;img&quot;).fadeIn(1000); 6 }); 7 $(&quot;.toggle&quot;).click(function(){ 8 $(&quot;img&quot;).fadeToggle(1000); 9 }); 淡入淡出到某一个透明度：fadeTo（）。有两个参数，第一个叫做速度参数。第二个透明度的终点。 1 $(&quot;.to&quot;).click(function(){ 2 $(&quot;img&quot;).fadeTo(&quot;slow&quot;,0.5); 3 }); 1 $(&quot;.out&quot;).click(function(){ 2 $(&quot;img:first&quot;).fadeOut(3000); 3 $(&quot;img:last&quot;).fadeIn(3000); 4 });]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[延时器setTimeout讲解]]></title>
      <url>%2F2016%2F11%2F18%2Ftitle23%2F</url>
      <content type="text"><![CDATA[1、延时器延时器：setTimeout()。在指定时间之后，执行1次函数。 window方法，可以省略书写。 比喻定时炸弹：在多少时间之后，炸弹爆炸。 1 语法：setTimeout(函数，等待时间); 1 console.log(1); 2 console.log(2); 3 console.log(3); 4 setTimeout(function(){ 5 console.log(&quot;booom shakalaka&quot;); 6 },1000); 7 console.log(4) 使用情况：setTimeout，如果需要在一段时间之后才执行某一个函数。只执行一次。setInterval，如果需要每隔一段时间执行函数一次，反复执行。 2、函数节流函数被调用的时候，最好有一个时间间隔，现在函数不具备这个功能。 事件被频繁触发，事件函数就会频繁调用。 解决方法：函数节流。用一个变量限制函数后面的语句到底能不能走到。定义一个延时器，将变量的限制解开。 1 //给函数上一把锁，锁开的时候，执行函数的语句，锁关上之后，不能执行函数 2 var lock = true ; //表示锁是开的能够执行事件函数 3 btn.onclick = function(){ 4 //如果锁开着可以执行后面的语句，如果关闭，直接return返回，不执行后面的代码 5 if(lock == false){ 6 return; 7 } 8 //给函数上一把锁 9 lock = false; 10 //隔一段时间打开锁 11 setTimeout(function(){ 12 lock = true; 13 },2000); 14 console.log(Math.random()); 15 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[call和apply]]></title>
      <url>%2F2016%2F11%2F18%2Ftitle22%2F</url>
      <content type="text"><![CDATA[call和apply了解普通函数内部有没有this关键，指向是谁。 1 var box = document.getElementById(&quot;box1&quot;); 2 animate(box,{&quot;left&quot;:300},1000,function(){ 3 console.log(this); 4 }); 5 function move(){ 6 console.log(this); 7 } 普通函数（事件函数除外）内部的this默认指向window对象。 call方法和apply方法能够帮我们制定函数内部this的指向。 1 fun.call(obj); 2 fun.apply(obj); obj就是内部this规定的指向元素。 1 //作用：第一个执行函数，第二个指定this。 2 move.call(box); 3 move.apply(box); 两种方法都能用。 区别：就是函数传参的方式不同。 1 fn.call(obj,参数1,参数2,参数3……); 2 fn.apply(obj,[参数1,参数2,参数3……]);3 1 // call方法直接传递 2 sum.call(box,1,2,3); 3 //apply必须将参数放在一个数组 4 sum.apply(box,[2,3,4]); 对封装的函数制定内部的回调函数的this。 1 move(box1); 2 function move(obj){ 3 animate(obj,{&quot;left&quot;:400},1000,function(){ 4 //运动执行完，回调函数内执行的语句 5 this.style.background = &quot;#0f0&quot;; 6 animate(this,{&quot;top&quot;:400},1000,function(){ 7 this.style.background = &quot;#00f&quot;; 8 //在调用运动函数 9 animate(this,{&quot;left&quot;:0},1000,function(){ 10 this.style.background = &quot;#0ff&quot;; 11 //在调用运动函数 12 animate(this,{&quot;top&quot;:100},1000,function(){ 13 this.style.background = &quot;#f00&quot;; 14 move(this); 15 }); 16 }); 17 }); 18 }); 19 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[异步和回调函数]]></title>
      <url>%2F2016%2F11%2F16%2Ftitle21%2F</url>
      <content type="text"><![CDATA[1、异步异步（Asynchronous），是计算机多线程的异步处理。与同步处理相对，异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。 js如果没有特殊语句：都是单线程，必须等到前面语句执行完之后，才能执行下面的语句。 同步： 1 console.log(1); 2 console.log(2); 3 console.log(3); 4 console.log(4); 5 //for循环，必须跳出循环才能走后面的语句 6 for(var i = 0 ; i &lt;= 100000 ; i++){ 7 console.log(1); 8 } 9 //后面的语句必须等到前面执行完才嫩执行，否则，只能排队等待。 10 console.log(5); 同步：工作中，完成一个demo，拿给项目经理去看，你就在旁边站着等，经理看完之后，告诉你这个可以了，继续下一个工作。 异步：工作中，完成一个demo，拿给项目经理去看，在经理看的过程，你回工位做下一个demo，经理同时也在检查你的原demo，他做完了之后告诉你，你这个可以了，继续工作。 如果要做异步：必须有异步语句的参与，setInterval、setTimeout、Ajax、node.js。 1 //定时器做异步 2 console.log(1); 3 console.log(2); 4 console.log(3); 5 console.log(4); 6 setInterval(function(){ 7 console.log(1); 8 },30) 9 console.log(5); 2、回调函数回调函数：定时器走完，可以利用一个回调函数告诉我的程序，某一个线程走完了，可以做什么工作了。 1 var timer; 2 var sum = 0; 3 timer = setInterval(function(){ 4 sum++; 5 console.log(1); 6 if(sum == 100){ 7 //清除定时器 8 clearInterval(timer); 9 //可以告诉程序下一步做什么 10 //回调函数，告诉我们定时器结束之后要做的工作 11 end(); 12 } 13 },30); 14 function end(){ 15 alert(&quot;定时器走完了&quot;); 16 } 一般有一个固定的写法：将结束后的回调函数作为一个参数。每次执行可以传递函数参数。 1 function yundong(callback){ 2 var timer; 3 var sum = 0; 4 timer = setInterval(function(){ 5 sum++; 6 console.log(1); 7 if(sum == 100){ 8 //清除定时器 9 clearInterval(timer); 10 //可以告诉程序下一步做什么 11 //回调函数，告诉我们定时器结束之后要做的工作 12 callback(); //必须写函数的调用 13 } 14 },30); 15 } 某一段代码结束后，继续执行的下一个内容。 1 animate(box1,{&quot;left&quot;:400},1000,function(){ 2 //运动执行完，回调函数内执行的语句 3 box1.style.background = &quot;#0f0&quot;; 4 animate(box1,{&quot;top&quot;:400},800,function(){ 5 box1.style.background = &quot;#00f&quot;; 6 }); 7 });]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS封装简单运动框架]]></title>
      <url>%2F2016%2F11%2F14%2Ftitle20%2F</url>
      <content type="text"><![CDATA[##1 封装简单运动框架 ## 两个属性要变动：left从0变到400，width从100变到300，间隔时间50毫秒。 可以随意定义left的步长，可以计算次数，同样可以计算宽度的步长 1 △left = 20； 2 次数 = （400 - 0） / 20 = 20 3 △width = (300 - 100) / 20 = 10 傻瓜版程序：给固定的值进行运动，耦合性太强。 1 //两个属性要变动：left从0变到400，width从100变到300，间隔时间50毫秒。 2// 全局信号量 3var nowleft = box.offsetLeft; 4var nowwidth = box.offsetWidth; 5var interval = 50; 6var timer; 7start.onclick = function(){ 8 timer = setInterval(function(){ 9 //全局信号量变动 10 nowleft += 20; 11 nowwidth += (300 - 100) / ((400 - 0) / 20 ); 12 //判断 13 if(nowleft &gt;= 400){ 14 //同时拉到终点 15 nowleft = 400; 16 nowwidth = 300; 17 clearInterval(timer); 18 } 19 //赋值 20 box.style.left = nowleft + &quot;px&quot;; 21 box.style.width = nowwidth + &quot;px&quot;; 22 },interval); 23 }; 封装一个运动框架：运动：运动元素，运动的结束位置以及运动的属性，运动总时间，间隔时间可以在内部定义一个具体值。 多个属性变动结束位置，可以一个JSON对象。 1 var jieshujson = { 2 “width” : 300, 3 “left” : 400 4 } 封装一个函数：animate(obj,jieshuJson,time); 1 // 封装运动函数 2 function animate(obj,jieshuJson,time){ 3 //准备三个数据，开始的JSON，结束的JSON，还有步长JSON 4 //开始JSON有多少个属性，由jieshuJson决定 5 //给开始JSON添加新属性，来源于jieshuJson。 6 var kaishiJson = {}; 7 for(var k in jieshuJson){ 8 //通过赋初始值，用到计算后样式，将字符串转数字 9 //结束后的样式名k 10 kaishiJson[k] = parseFloat(getStyle(obj,k)); 11 } 12 //console.log(kaishiJson); 13 //步长JSON = （jieshuJson - kaishiJson） / 总次数 14 //总次数 = 总时间 / 间隔时间 15 var interval = 50; 16 var zongcishu = time / interval; 17 //获得步长JSON 18 var buchangJson = {}; 19 for(var k in jieshuJson){ 20 //避免输入的是字符串，先转数字 21 jieshuJson[k] = parseFloat(jieshuJson[k]); 22 buchangJson[k] = (jieshuJson[k] - kaishiJson[k]) / zongcishu; 23 } 24 // console.log(buchangJson); 25 //============三个JSON都准备完了=============== 26 //程序部分 27 //全局信号量接收初始值，每次的步长 28 //定义信号量JSON 29 var xinhaoliangJson = {}; 30 for(var k in kaishiJson){ 31 xinhaoliangJson[k] = kaishiJson[k]; 32 } 33 //执行次数等于总次数，停止运动 34 //累加器 35 var cishu = 0; 36 var timer ; 37 timer = setInterval(function(){ 38 //每执行一次，次数增加 39 cishu++; 40 //信号量JSON每次加一个步长 41 for(var k in xinhaoliangJson){ 42 xinhaoliangJson[k] += buchangJson[k]; 43 } 44 //验收，停止定时器 45 if(cishu &gt;= zongcishu){ 46 //拉终停表 47 for(var k in xinhaoliangJson){ 48 xinhaoliangJson[k] = jieshuJson[k]; 49 } 50 clearInterval(timer); 51 } 52 //赋值,如果是透明度属性，需要单独设置 53 for(var k in xinhaoliangJson){ 54 if(k == &quot;opacity&quot;){ 55 obj.style.opacity = xinhaoliangJson[k]; 56 obj.style.filter = &quot;alpha(opacity=&quot; + xinhaoliangJson[k] * 100 +&quot;)&quot;; 57 }else{ 58 obj.style[k] = xinhaoliangJson[k] + &quot;px&quot;; 59 } 60 } 61 },interval); 62 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON对象使用方法]]></title>
      <url>%2F2016%2F11%2F12%2Ftitle19%2F</url>
      <content type="text"><![CDATA[概述 数组：存储的是一组数据，可以操作每一项内容，有自己的局限性，通过具体下标才能获得某一项。 数据多的时候，数组的使用效率变低。 JSON对象可以解决这个问题。也可以存多个数据，每个数据都有自己的名字。可以通过数据的名字得到数据的值。 JSON叫做JavaScript Object Notation， JavaScript对象表示法。 JSON对象创建的最简单的方式，就是字面量，一对大括号{}。 语法：{}内部包括多个数据，每个数据之间用逗号隔开，最后一个数据后不能写逗号。每一项数据都包含属性名和属性值，属性名必须用引号包括，属性值根据数据类型单独设置，键值对写法”k”:v。 1 语法：{“k”: v, “k”: v} 创建一个最简单的JSON对象。 1 var json = { 2 &quot;name&quot; : &quot;kaola&quot;, 3 &quot;age&quot; : 18, 4 &quot;sex&quot; : &quot;男&quot;, 5 &quot;tall&quot; : 100, 6 &quot;weight&quot; : 178 7 }; 8 console.log(typeof json); 数据类型：对象型。引用类型数据，变量存的是地址。 调用每一项数据的方法：JSON对象点语法调用属性名即可，或者用[属性名]。 1 //调用 2 console.log(json.name); 3 console.log(json.age); 4 console.log(json.sex); 5 console.log(json.tall); 6 console.log(json[&quot;weight&quot;]); JSON对象内部还能嵌套JSON对象。 1 var json = { 2 &quot;name&quot; : &quot;kaola&quot;, 3 &quot;age&quot; : 18, 4 &quot;sex&quot; : &quot;男&quot;, 5 &quot;tall&quot; : 100, 6 &quot;weight&quot; : 178, 7 &quot;couple&quot; : { 8 &quot;name&quot; : &quot;daishu&quot;, 9 &quot;age&quot; : 17, 10 &quot;sex&quot; : &quot;女&quot;, 11 &quot;tall&quot; : 160, 12 &quot;weight&quot; : 90 13 } 14 }; 如果想调用内部JSON的属性，继续打点调用即可。 1 console.log(json.couple.tall); 修改某一个属性：给调用的属性名去直接赋值。 1 json.tall = 170; 2 console.log(json); 删除：用到一个delete关键字，后面必须加空格，书写他的属性。 1 //删除 2 delete json.couple; 3 console.log(json); 添加：直接给JSON对象打点添加属性，属性值同时赋值。 1 //添加 2 json.hobby = &quot;台球&quot;; 3 console.log(json); 2、JSON的遍历for……in语法：通过属性名去遍历所有属性，从前到后依次去遍历，直到最后一个数据被遍历完。循环结束。 1 for(var k in json){ 2 语句3 } k：表示属性名 json：你要遍历的那个JSON对象。输出每一个属性值： 1 //输出每一个属性值，需要遍历JSON对象 2 for(var k in json){ 3 console.log(json[k]); 4 } 复制一个JSON对象： 属性名都一样，属性值也一样。 过程：新的JSON对象接收复制来的数据。给新对象添加新属性，新属性等于原对象属性，再给新属性赋值，值等于原对象属性的值。 1 var newJson = {}; //必须是空的JSON对象 2 for(var k in json){ 3 //定义新属性并赋值 4 newJson[k] = json[k]; //红色是添加属性，绿色是调用原JSON的属性值 5 } 6 //循环完之后得到一个新的JSON 7 console.log(newJson);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[setInterval定时器]]></title>
      <url>%2F2016%2F11%2F10%2Ftitle18%2F</url>
      <content type="text"><![CDATA[1、概念window给我们提供的一个方法，setInterval定时器。 1 window.setInterval(函数,间隔时间); 1 //获得div标签 2 var box = document.getElementsByTagName(&quot;div&quot;)[0]; 3 //全局变量累加 4 var nowleft = 0; 5 window.setInterval(function(){ 6 //每次执行函数都让nowleft递加 7 nowleft += 20; 8 //赋值给left属性值 9 box.style.left = nowleft + &quot;px&quot;; 10 },100) 定时器执行的功能由第一个参数，函数来决定： 1 window.setInterval(function(){ 2 console.log(1); 3 },100); 第一个参数可以是一个匿名函数，也可以是一个函数的函数名。 1 window.setInterval(shuchu,100); 2 function shuchu(){ 3 console.log(1);4 } 第二种方法是工作中常用的。 定时器第二个参数：间隔时间。单位：毫秒，1000毫秒等于1秒。规定的是我们函数执行间隔。 1 window.setInterval(function(){ 2 //每次执行函数都让nowleft递加 3 nowleft += 20; 4 //赋值给left属性值 5 box.style.left = nowleft + &quot;px&quot;; 6 },10); 时间间隔可以决定运动的速度。间隔时间越短，函数在一秒钟内执行的次数越多，变量变动的越快。 运动内：时间越短，速度越快。 定时器的启动是不需要其他条件，只要遇到setInterval语句就会立即开启一个定时器。 常用的形式：会省略window对象。 1 setInterval(move,50); 2、简单运动原理：利用定时器，每个多长时间，走多少步。 不需要知道要走多远，只要知道每隔多长时间走多长。 视觉暂留：视觉残留。人的视觉有一个残留时间０.１秒－０.４秒。 1 //定义定时器，让宽度每隔100毫秒变宽一点 2 setInterval(move,100); 3 function move(){ 4 now += 10; 5 //给元素宽度赋值 6 box.style.width = now + &quot;px&quot;; 7 } 间隔时间在一秒钟内让函数执行几次，次数可以叫做帧频，frame percent second，每秒执行几帧，简称fps。一个运动的帧频是24fps，指的是一秒钟动24次。 控制运动速度：帧频越大，1秒运动的次数越多。间隔时间变短，帧频变大。 第一种方法：缩短间隔时间。 1 setInterval(move,20); 第二种方法：增大步长。 1 now += 30; 3、清除定时器clearInterval又叫停止定时器。 clearInterval：清空一个定时器的作用。 方法：将定时器setInterval给一个变量，要停止的时候，将变量传给clearInterval的参数。 1 var timer; 2 start.onclick = function(){ 3 timer = setInterval(move,100); 4 }; 5 end.onclick = function(){ 6 //关闭定时器 7 clearInterval(timer); 8 }; 4、存在的问题第一个问题： 如果多次点击一个运动开始的按钮，会开启多个定时器，在一个时间内有多个定时器都在隔一段时间执行函数。造成一个现象，运动的变量每一个间隔时间变动的值是多个定时器累加的效果。运动速度回越来越快。 防骚扰操作：每开启一个定时器之前，先停止一次定时器。设表先关。 1 var timer; 2 start.onclick = function(){ 3 //设表先关 4 clearInterval(timer); 5 timer = setInterval(move,100); 6 }; 7 end.onclick = function(){ 8 //关闭定时器 9 clearInterval(timer); 10 }; 第二个问题： 有时需要元素停在一个固定位置，如果步长给的不合理，不会正好停在这个位置，有误差。解决方法：先将变量判断，if语句的后验收，如果大于终点值，强制给变量赋值，再停止定时器。拉终停表。 1 start.onclick = function(){ 2 timer = setInterval(function(){ 3 //设置步长 4 now += 13; 5 // 给元素属性赋值 6 //后验收 7 if(now &gt; 500){ 8 //拉回到终点，然后停止定时器 9 now = 500; 10 clearInterval(timer); 11 } 12 box.style.left = now + &quot;px&quot;; 13 console.log(now); 14 15 }, 50);16 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取尺寸和位置的方法]]></title>
      <url>%2F2016%2F11%2F08%2Ftitle17%2F</url>
      <content type="text"><![CDATA[前面封装的函数得到的值都是字符串，使用的时候，一部分需要转成数字取计算。JS提供了几个常用的快捷尺寸，得到的就是数字类型的数据。 offsetLeft offsetTop offsetWidth offsetHeight clientWidth clientHeight 1、offsetLeft和offsetTop严重的兼容性问题。以offsetLeft为例。offset具有偏移量的含义。元素天生具有一个属性，认识一个叫做offsetParent的元素，偏移参考元素。 调用方法：打点调用offsetLeft。 兼容IE9以上及高级浏览器 1 &lt;div class=&quot;box1&quot;&gt; 2 &lt;div class=&quot;box2&quot;&gt; 3 &lt;div class=&quot;box3&quot;&gt; 4 &lt;p&gt;&lt;/p&gt; //本身不管有没有定位，祖先元素都没有定位，偏移参考元素就是body 5 &lt;/div&gt; 6 &lt;/div&gt; 7 &lt;/div&gt; 8 &lt;div class=&quot;box1&quot;&gt;//有定位 9 &lt;div class=&quot;box2&quot;&gt; //有定位 距离p元素最近且有定位，是offsetParent 10 &lt;div class=&quot;box3&quot;&gt; //无定位 11 &lt;p&gt;&lt;/p&gt; //本身不管有没有定位，祖先元素有定位，偏移参考元素就是距离最近的box2 12 &lt;/div&gt; 13 &lt;/div&gt; 1 &lt;/div&gt; offsetParent：不管元素自身有没有定位，如果祖先元素有定位，偏移参考元素就是距离该元素最近的有定位的祖先元素。如果祖先元素都没有定位，偏移参考元素变成body。 offsetLeft：就是自身元素的左边框外到offsetParent的左边框内部的距离。 offsetTop与offsetLeft一样：自身元素的上边框外到offsetParent的上边框内部的距离。 IE6/7浏览器： 区分两种情况，元素自身有没有定位： 第一种：元素自身没有定位。 offsetParent：距离最近的有宽高的祖先元素，如果都没有宽高，参考body。 offsetLeft：与高级浏览器一样，元素左边框外到offsetParent的左边框内部的距离。 1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[getComputedStyle使用方法]]></title>
      <url>%2F2016%2F11%2F05%2Ftitle16%2F</url>
      <content type="text"><![CDATA[计算后样式点语法不能得到计算后样式，只能得到和更改行内样式。计算后样式：其实是多个选择器叠加的最终样式。 1、高级浏览器1 var box = document.getElementById(&quot;box&quot;); 2 console.log(box.style.width); W3C制定的标准API，所有现代浏览器（包括IE9，但不包括之前的版本）都window.getComputedStyle()，该方法接收一个要进行样式计算的元素，并返回一个可以进行属性查询的接口。返回接口提供了一个名为getPropertyValue()的方法，用于检索特定样式属性的计算样式。getPropertyValue方法接收css属性名称，而不是驼峰式的名称。getPropertyValue()可以不写，直接用方括号来检索属性也可以。 兼容问题：在高级浏览器和IE9以上才能使用。 window.getComputedStyle：window指的是浏览器对象，可以省略window。内部有一个获得计算后样式的方法。 传入一个元素对象，返回时这个元素的所有计算后样式。直接写在参数位置，不需要加引号，因为我是传的是元素对象的变量。 1 console.log(window.getComputedStyle(box)); 进一步可以打点调用getPropertyValue：获得属性值。 第一种方法：小括号内的参数直接写css属性名，直接在小括号内的引号内书写，必须写css内的名字格式，不能用驼峰。 1 //var a = window.getComputedStyle(box).getPropertyValue(&quot;width&quot;); 2 var a = window.getComputedStyle(box).getPropertyValue(&quot;backgroundColor&quot;); 必须使用css的写法。 第二种方法：不用小括号调用，用中括号调用，将属性名写在中括号内部。不需要getPropertyValue。属性名必须用引号包裹。这种方法可以用驼峰命名法。 1 var a = window.getComputedStyle(box)[&quot;width&quot;]; 复合属性既能用css写法，也能用驼峰。 1 var a = window.getComputedStyle(box)[&quot;backgroundColor&quot;]; 2、低版本浏览器IE6/7/8IE9之前的版本提供了一个专有API访问计算后样式：附加在元素身上的currentStyle属性，它表现和style点语法一样，使用驼峰式访问。 使用方法与点语法调用style一模一样。点语法继续调用属性。 1 //低版本浏览器 2 var a = box.currentStyle.width; 1 //var b = box.currentStyle.backgroundColor; 3 4 box.innerHTML = a; 也可以用中括号的方式调用：只能用驼峰，不能用css写法。 2 var a = box.currentStyle[&quot;width&quot;]; 3 var b = box.currentStyle[&quot;background-color&quot;]; 3、兼容写法 ## 不是去测试浏览器版本，检测浏览器能力。如果浏览器具备调用某一个方法的能力，就使用。 能力检测：将方法作为判断条件。 1 var box = document.getElementById(&quot;box&quot;); 2 //通过能力检测写兼容 3 if(window.getComputedStyle){ 4 //高级浏览器 5 var a = window.getComputedStyle(box)[&quot;background-color&quot;]; 6 }else if(box.currentStyle){ 7 var a = box.currentStyle[&quot;backgroundColor&quot;] 8 } 9 box.innerHTML = a; 去封装一个函数，输入一个属性名，输出一个兼容后的属性值。 1 //封装一个函数，兼容高级浏览器和低版本浏览器 2 function fetchComputedStyle(ele,property){ 3 //判断是高级浏览器还是低版本 4 //能力测试判断 5 if(window.getComputedStyle){ 6 //针对用户输入的属性名进行兼容写法，不管是不是驼峰，都改成横线写法 7 property = property.replace(/([A-Z])/g,function(match,$1){ 8 return &quot;-&quot; + $1.toLowerCase(); 9 }); 10 return window.getComputedStyle(ele)[property]; 11 }else if(ele.currentStyle){ 12 //针对用户输入的属性名进行兼容写法，不管是不是驼峰，都改成驼峰 13 property = property.replace(/\-([a-z])/gi,function(match,$1){ 14 return $1.toUpperCase(); 15 }); 16 return ele.currentStyle[property]; 17 } 18 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[getElementsByTagName使用方法]]></title>
      <url>%2F2016%2F11%2F03%2Ftitle15%2F</url>
      <content type="text"><![CDATA[1、概述getElementsByTagName：get获取 elements多个元素 by 通过 tagname标签名字。 参数：引号包裹标签名。 通过p标签获得元素：查找所有页面上的p标签，得到的是所有标签元素对象组成的数组。 1 &lt;p&gt;1&lt;/p&gt; 2 &lt;p&gt;2&lt;/p&gt; 3 &lt;p&gt;3&lt;/p&gt; 4 &lt;p&gt;4&lt;/p&gt; 5 &lt;p&gt;5&lt;/p&gt; 6 &lt;p&gt;6&lt;/p&gt; 7 &lt;script&gt; 8 //通过p标签获取元素 9 var ps = document.getElementsByTagName(&quot;p&quot;); 10 console.log(ps); 11 console.log(typeof ps); 12 &lt;/script&gt; 1 //得到的是数组，得到一个具体的p元素 2 console.log(ps[0]); 3 console.log(ps.innerHTML); 4 console.log(ps[0].innerHTML); 通过数组下标得到的数据才是我们的具体的元素对象，才有控制元素的属性和方法。 操作内部的每个元素对象，必须遍历元素 1 //我要看得到的元素内部的html内容 2 //遍历对象数组，得到每一个元素对象，打点调用属性和方法 3 for(var i = 0 ; i &lt; ps.length ; i++){ 4 console.log(ps[i].innerHTML); 5 } 通过标签名获得元素，是页面内所有的这个名的元素，不论嵌套多深。 1 &lt;div&gt; 2 &lt;div&gt; 3 &lt;p&gt;7&lt;/p&gt; 4 &lt;/div&gt; 5 &lt;/div&gt; 数组有下标，下标顺序按照什么来排序：按照元素出现的顺序排序，首标签出现靠前，在数组里位置靠前。跟嵌套关系无关。 1 &lt;div class=&quot;box1&quot;&gt; 2 &lt;div class=&quot;box2&quot;&gt; 3 &lt;div class=&quot;box3&quot;&gt; 4 &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; 5 &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt; 6 &lt;/div&gt; 7 &lt;div class=&quot;box6&quot;&gt;&lt;/div&gt; 8 &lt;/div&gt; 9 &lt;/div&gt; 10 //遍历得到的div数组的单个元素的class。 11 for(var i = 0 ; i &lt; divs.length ; i++){ 12 console.log(divs[i].className); 13 } 如果得到元素在页面内只有一个，使用元素对象时也必须用数组的方法得到这个对象。 1 //选中的如果只有一个p元素 2 console.log(ps); 3 ps[0].style.background = &quot;yellowgreen&quot;; 连续打点调用：不仅仅document可以使用这个方法， 任何HTML元素也能调用这个方法。可以连续打点调用get系列方法。 1 //连续打点调用方法 2 //将范围缩小到id为box1的标签内部 3 var ps = document.getElementById(&quot;box1&quot;).getElementsByTagName(&quot;p&quot;); 4 for(var i = 0 ; i &lt; ps.length ; i++){ 5 ps[i].style.background = &quot;#f00&quot;; 6 } 等价写法： 1 var box1 = document.getElementById(&quot;box1&quot;); 2 //在box1里去找p 元素 3 var ps = box1.getElementsByTagName(&quot;p&quot;); 还可以对getElementsByTagName连续打点调用。 1 //连续使用getElementsByTagName获得元素，不用id。 2 var spans = document.getElementsByTagName(&quot;div&quot;)[1].getElementsByTagName(&quot;p&quot;)[2].getElementsByTagName(&quot;span&quot;); 3 spans[2].style.color = &quot;#f00&quot;; 错误写法： 1 var spans = document.getElementsByTagName(&quot;div&quot;)[1].document.getElementsByTagName(&quot;p&quot;)[2].getElementsByTagName(&quot;span&quot;); 更加好用的方法：先用id限制范围，用标签选元素。 1 var spans = document.getElementById(&quot;p1&quot;).getElementsByTagName(&quot;span&quot;); 2、批量控制①批量添加事件 通过标签名得到的是一个元素对象的数组，对数组遍历，里面每一项分别添加事件。批量添加过程。过程中注意闭包影响： 第一种解决方法：IIFE 1 // 选取第一个盒子的所有p 2 var box1 = document.getElementById(&quot;box1&quot;); 3 var ps = box1.getElementsByTagName(&quot;p&quot;); 4 5 //批量添加，for循环 6 //闭包对函数内部语句的影响 7 for(var i = 0 ; i &lt; ps.length ; i++){ 8 //用IIFE解决闭包问题 9 (function(a){ 10 ps[a].onclick = function(){ 11 ps[a].style.background = &quot;yellowgreen&quot;; 12 // console.log(ps[i].innerHTML); 13 }; 14 })(i); 15 } 第二种方法：我们可以给一个对象自定义属性，用这个属性存储每次循环是传进来的变量的值。事件函数内部有一个关键字叫做this，它本身就是指代的触发事件的对象本身。 1 //用自定义属性和事件函数内部的this来解决闭包问题 2 for(var i = 0 ; i &lt; ps.length ; i++){ 3 //自定义一个属性存储下标 4 ps[i].index = i; 5 //绑定事件 6 ps[i].onclick = function(){ 7 //谁触发事件，它就有一个this指向他自身，this本身就是这个对象 8 //this.index的值就是触发的这个对象的index。 9 ps[this.index].style.background = &quot;yellowgreen&quot;; 10 } 11 } 第二种方法较为常用。 ②批量控制 第一种：用两个按钮控制 1 //选中所有input标签 2 var checks = document.getElementById(&quot;box&quot;).getElementsByTagName(&quot;input&quot;); 3 var all = document.getElementById(&quot;all&quot;); 4 var none = document.getElementById(&quot;none&quot;); 5 6 //批量全选 7 all.onclick = function(){ 8 //遍历每一个多选框，添加checked属性 9 for(var i = 0 ; i &lt; checks.length ; i++ ){ 10 checks[i].checked = &quot;checked&quot;; 11 } 12 }; 13 none.onclick = function(){ 14 //遍历每一个多选框，更改checked属性 15 for(var i = 0 ; i &lt; checks.length ; i++ ){ 16 checks[i].checked = &quot;&quot;; 17 } 18 } 第二种方法：一个按钮控制。 1 //给all这个元素添加点击事件 2 all.onclick = function(){ 3 //判断all的value值如果是全选，将前面全部选中，将自己的value改成全不选 4 // 如果是全不选，将前面全部取消选择，将自己改成全选 5 if(all.value == &quot;全选&quot;){ 6 //全部选中 7 for(var i = 0 ; i &lt; checks.length ; i++ ){ 8 checks[i].checked = &quot;checked&quot;; 9 } 10 // value改为全不选 11 all.value = &quot;全不选&quot;; 12 }else{ 13 //全部不选中 14 for(var i = 0 ; i &lt; checks.length ; i++ ){ 15 checks[i].checked = &quot;&quot;; 16 } 17 // value改为全选 18 all.value = &quot;全选&quot;; 19 } 20 }; 第三种：一个按钮。用一个全局信号量当做一个中间值。全选和全不选作为两种状态。 1 //信号量方法 2 //如果信号量为1，表示我要全选，0表示全不选 3 var sema = 1; 4 var str = &quot;&quot;; 5 //添加点击事件 6 all.onclick = function(){ 7 //判断信号量是谁，如果是1，表示全选，str变成checked选中，信号量要改为0，value要变成全不选 8 //如果是1，str变成checked选中，如果不是变成“” 9 str = sema == 1 ? &quot;checked&quot; : &quot;&quot;; 10 //信号量更改 11 sema = sema == 1 ? 0 : 1; 12 //改按钮的value 13 all.value = sema == 0 ? &quot;全不选&quot; : &quot;全选&quot;; 14 //调用变动函数 15 choose(); 16 } 17 //变动函数 18 function choose(){ 19 for(var i = 0 ; i &lt; checks.length ; i++ ){ 20 checks[i].checked = str; 21 } 22 } 3、对应控制用一个元素去控制另外一个元素的变动。需要找到之间的关系。一般找数组下标。 1 //获取所有元素 2 var ps1 = document.getElementById(&quot;box1&quot;).getElementsByTagName(&quot;p&quot;); 3 var ps2 = document.getElementById(&quot;box2&quot;).getElementsByTagName(&quot;p&quot;); 4 5 //批量给PS1里的元素加事件 6 for(var i = 0 ; i &lt; ps1.length ; i++){ 7 //自定义属性存储下标 8 ps1[i].index = i; 9 ps1[i].onclick = function(){ 10 ps2[this.index].style.background = &quot;yellowgreen&quot;; 11 } 12 } 4、排他控制保留自己，排除别人。 排他控制方法：在点击事件函数内部多做一步工作，先将所有元素回归默认样式，给对应的元素再添加单独样式。 1 //获取所有元素 2 var ps1 = document.getElementById(&quot;box1&quot;).getElementsByTagName(&quot;p&quot;); 3 var ps2 = document.getElementById(&quot;box2&quot;).getElementsByTagName(&quot;p&quot;); 4 5 //批量给PS1里的元素加事件 6 for(var i = 0 ; i &lt; ps1.length ; i++){ 7 //自定义属性存储下标 8 ps1[i].index = i; 9 ps1[i].onclick = function(){ 10 //先将所有元素回归默认样式，给对应的元素再添加单独样式 11 //排他操作 12 for(var j = 0 ; j &lt; ps1.length ; j++){ 13 ps1[j].style.background = &quot;skyblue&quot;; 14 ps2[j].style.background = &quot;skyblue&quot;; 15 } 16 17 //给这个元素和对应的p加特殊样式 18 ps1[this.index].style.background = &quot;yellowgreen&quot;; 19 ps2[this.index].style.background = &quot;pink&quot;; 20 } 21 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM操作方法]]></title>
      <url>%2F2016%2F10%2F31%2Ftitle14%2F</url>
      <content type="text"><![CDATA[1、DOM体验DOM（Document Object Model，文档对象模型）描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。这使得JavaScript操作HTML，不是在操作字符串，而是在操作节点，极大地降低了编程难度。编写例子整体感知一下这个事儿。 1 //获得元素 2 var oDiv = document.getElementById(&quot;box&quot;); 3 var oKaola = document.getElementById(&quot;kaola&quot;); 4 //添加点击事件，盒子变色，图片变图 5 oDiv.onclick = function(){ 6 oDiv.style.backgroundColor = &quot;yellowgreen&quot;; 7 oKaola.src = &quot;images/kaola2.jpeg&quot;; 8 } DOM规范在1998年10月制定，称为“DOM1级规范”。随着ECMAScript的升级，DOM也发展出了2级规范、3级规范。另外，早于1998年的DOM也有事实上的标准，我们称为0级规范。 DOM对很多东西做了抽象，提供了丰富的API：取得元素、css样式、事件、运动、元素尺寸位置、节点操作。每个知识体系都非常庞大，千丝万缕。我们今天的课程，把一些线头都掐出来，日后的课程深入研究每个线头。 2、获取元素JavaScript通过document对象表示文档，它表示整个页面。它有很多属性和方法，包含了绝大多数多页面的特征和操作。学习DOM，说白了就是学习document对象。例如document.title属性，就是页面的标题。 1 document.title = &quot;获取元素&quot;; 2 alert(document.title); DOM操作，往往都是从取得某个（些）HTML元素开始，然后对这个（些）元素进行一些操作。所以得到元素是非常重要的。得到元素的操作可以使用document对象的两个方法来完成： document.getElementById() document.getElementsByTagName() getElementById：get得到 element 元素 by 通过 id id属性值。通过id名字获得某一个元素。 驼峰命名法：一个标识符由多个英文单词组成，首个单词正常小写，从第二个开始每个单词首字符要大写，其他的小写。 JS的书写位置：如果要想获得某一个元素，那么获得之前，元素必须是加载过的。js的书写顺序，需要写在标签后面。 1 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; //标签写在获取元素的前面 2 &lt;script&gt; 3 // document.title = &quot;获取元素&quot;; 4 // alert(document.title); 5 6 //获取div元素 7 var box = document.getElementById(&quot;box&quot;); 8 box.onclick = function(){ 9 box.style.border = &quot;10px solid #0f0&quot;; 10 } 11 &lt;/script&gt; 获取元素语法：直接将获得的这个元素的id属性值写在参数里。名字必须加引号。跟css区别，不需要加#。 错误写法： 1 var box = document.getElementById(&quot;#box&quot;); 正确写法： 1 var box = document.getElementById(&quot;box&quot;); 获得的元素的数据类型。通过检测，得到一个对象类型。 1 console.log(typeof box); 也就是说，我们通过id获得元素本身又是一个对象类型的数据，内部还包含了一些属性和方法。可以对这些元素打点继续调用属性和方法。 注意：id名不能重复。 1 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; 2 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; 3 //id名字不能重复，如果有重复的，只得到第一个 4 var oBox = document.getElementById(&quot;box&quot;); 5 oBox.style.backgroundColor = &quot;#0f0&quot;; id大小写要严格区分，但是在IE6、7中，大小写是不区分的。 IE7及较低版本还有一个怪癖，表单元素name特性也会被当做id。为了避免这个问题，所以页面上的name最好也不要和任何id相同。 3、操作html获取一个html标签之后，得到一个对象类型变量。 可以控制html的属性：得到属性、更改属性。 有两种选择：getAttribute()和setAttribute()方法，或者使用点语法。 点语法： 获得元素属性：直接在元素对象后点语法调用，输出属性值。 1 //获得img标签的src属性 2 console.log(oImg.src); 3 console.log(oImg.id); 4 console.log(oImg.alt); 更改html标签属性：可以通过点语法调用相关属性后，通过等号给这个属性赋值，更改属性值的方法。 1 //通过点语法得到相关属性，等号赋新值 2 oImg.src = &quot;images/kaola2.jpeg&quot;; 3 //不要去更改id属性，id是只读。 第二种方法： 得到属性值getAttribute()，需要得到什么属性，直接将名字写在小括号内。 1 console.log(oImg.getAttribute(&quot;src&quot;)); //得到的就是属性值的字符串 2 console.log(oImg.getAttribute(&quot;alt&quot;)); //得到的就是属性值的字符串 设置属性值setAttribute()，设置属性的新的属性值，直接写在小括号内，用引号包裹。 1 oImg.setAttribute(&quot;src&quot;,&quot;images/kaola.jpg&quot;); 第一个参数：设置属性名，第二个参数：新的属性值，中间用逗号隔开。 区别： ①html标签可以使用自定义属性，自定义属性调用和更改都不能使用点语法实现。getAttribute（）可以获得自定义属性，setAttribute（）可以更改自定义属性。 1 //自定义属性 2 oImg.setAttribute(&quot;kaola&quot;,&quot;yuanxing&quot;); 3 console.log(oImg.kaola); 4 console.log(oImg.getAttribute(&quot;kaola&quot;)); ②点语法调用html属性时，有一些属性名需要进行更改，这些属性名可能是其他的关键字，规避这些名字。getAttribute方法不用规避，直接写原属性名。 class 改为className for 改为htmlFor rowspan 改为rowSpan colspan 改为colSpan 1 //更改一些属性名的写法，只限于点语法 2 console.log(oImg.class); 3 console.log(oImg.className); getAttribute方法不需要改变写法，如果改了反而错。 1 console.log(oImg.getAttribute(&quot;className&quot;)); 2 console.log(oImg.getAttribute(&quot;class&quot;)); ③如果调用style属性得到的还是一个css对象，可以继续打点调用css的样式，遇到复合属性的单一写法，点语法需要些驼峰命名，另外一种方法不需要。 text- font- line- background- border- margin- padding- 1 //console.log(oImg.style.border-color); 2 console.log(oImg.style.borderColor); getAttribute方法直接写css内的命名就行。 ④点语法得到的style属性是一个对象，可以继续打点调用内部的属性。getAttribute方法得到style属性，是一个字符串，不能再继续打点调用。 1 //console.log(oImg.style.border-color); 2 console.log(typeof oImg.style); 3 console.log(typeof oImg.getAttribute(&quot;style&quot;)); 点语法才能继续打点调用css样式属性。 总结：除了自定义属性用getAttribute和setAttribute之外，其他情况都用点语法。 4、操作css通过对一个元素对象打点调用style属性，得到的是css样式的一个对象。可以通过得到css样式的对象，进行css属性的读取和更改。 通过点语法读取和更改的css样式都是行内样式。 1 &lt;img src=&quot;images/kaola.jpg&quot; alt=&quot;这是一只考拉&quot; style=&quot;border:2px solid #f00;&quot; class=&quot;tupian&quot; id=&quot;image&quot; kaola=&quot;bianxing&quot; /&gt; 2 //点语法得到样式都是行内样式，更改的也是行内样式 3 console.log(oImg.style.width); 4 console.log(oImg.style.border); 通过点语法改的css样式属性都是在行内式进行更改的。 1 //更改样式 2 oImg.style.height = &quot;400px&quot;; 语法注意：点语法直接调用。如果给属性赋新值，通过等号赋值，右侧的值必须写在一对儿引号里，css里面怎么写属性值，引号里直接就这么些。 1 oImg.style.height = &quot;400px&quot;; 2 oImg.style.borderColor = &quot;#00f&quot;; innerHTML表示标签内的文本。 input标签有自己的获得方法，点语法直接调用value属性。 1 console.log(oBox.innerHTML); 2 console.log(oTxt.value); 5、事件 DOM0级事件： onclick 单击事件 ondblclick 双击事件 onmouseover 鼠标移上事件 onmouseout 鼠标移出事件 onmousedown 鼠标按下事件 onmouseup 鼠标弹起事件 onfocus 获得焦点事件 onblur 失去焦点事件 onload 加载事件 事件监听：给一个元素去添加事件，如果触发事件就会执行相应的功能。JS在加载的时候，先去整个页面去查看，看谁绑定了事件，引擎就会给这个元素进行监控（监听），监控我们的元素有没有被触发这个事件的动作，如果触发动作，在瞬间执行相应的功能。 语法：给哪个元素绑定事件，就给这个元素对象打点添加对应的事件，用等号给这个事件添加事件函数。 2 box.onmouseover = function(){ 3 事件触发之后要做的事。 4 }; 如果事件被触发，立即执行后面的事件函数，不需要加()调用函数。 6 //获取元素 7 var oImg = document.getElementById(&quot;image&quot;); 8 // 绑定鼠标移上的效果，变图片 9 oImg.onmouseover = function(){ 10 oImg.src = &quot;images/kaola2.jpeg&quot;; 11 }; 调用函数方法：用小括号调用，触发事件执行事件函数。 onclick：单击事件,鼠标单击事件元素触发事件。 5 //鼠标单击事件 6 oImg.onclick = function(){ 7 oImg.style.width = &quot;300px&quot;; 8 }; 4 //鼠标双击事件 5 oImg.ondblclick = function(){ 6 oImg.style.width = &quot;300px&quot;; 7 }; 3 //绑定鼠标移上的效果，变图片 4 oImg.onmouseover = function(){ 5 oImg.src = &quot;images/kaola2.jpeg&quot;; 6 }; 7 //鼠标移出效果，一般与鼠标移上成对出现 8 oImg.onmouseout = function(){ 9 oImg.src = &quot;images/kaola.jpg&quot;; 10 }; 2 //获取元素 3 var oBox = document.getElementById(&quot;box&quot;); 4 //添加鼠标移上和移出事件 5 oBox.onmouseover = function(){ 6 oBox.style.backgroundImage = &quot;url(images/jd2.png)&quot;; 7 }; 8 oBox.onmouseout = function(){ 9 oBox.style.backgroundImage = &quot;url(images/jd1.png)&quot;; 10 }; 5 //添加鼠标按下和弹起事件 6 oBtn.onmousedown = function(){ 7 oBtn.style.backgroundColor = &quot;pink&quot;; 8 }; 9 oBtn.onmouseup = function(){ 10 oBtn.style.backgroundColor = &quot;skyblue&quot;; 11 }; 点击： 松开： 4 //获得焦点事件，输入框清空 5 oTxt.onfocus = function(){ 6 oTxt.value = &quot;&quot;; 7 }; 8 oTxt.onblur = function(){ 9 oImg.src = &quot;images/kaola2.jpeg&quot;; 10 }; onload事件：表示元素加载完之后执行某一个事件函数。 3 //onload加载，图片加载完之后，弹出一句话，加载完了 4 oImg.onload = function(){ 5 alert(&quot;加载完毕&quot;); 6 }; 页面整体加载事件： window.onload:表示页面的所有html标签、css样式都加载完。JS就可以随意书写加载位置。 3 // 只有页面全部加载完了才会触发window.onload 4 window.onload = function(){ 5 //获取元素 6 var oImg = document.getElementById(&quot;image&quot;); 7 var oTxt = document.getElementById(&quot;txt&quot;); 8 //绑定鼠标移上的效果，变图片 9 oImg.onmouseover = function(){ 10 oImg.src = &quot;images/kaola2.jpeg&quot;; 11 }; 12 //鼠标移出效果，一般与鼠标移上成对出现 13 oImg.onmouseout = function(){ 14 oImg.src = &quot;images/kaola.jpg&quot;; 15 }; 16 }； window浏览器对象，alert就是window对象里面的一个方法。window可以省略。 window.alert(&quot;yes&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[arguments对象]]></title>
      <url>%2F2016%2F10%2F29%2Ftitle13%2F</url>
      <content type="text"><![CDATA[1、arguments对象在其他语言里，一个函数定义两次，每次有不同的形式参数，代表的就是两个不同的函数，叫做函数的重载（overloaded）。 1 function fun(a,b){ 2 console.log(1); 3 } 4 function fun(a,b,c){ 5 console.log(2); 6 } 以上在其他语言里，作为两个不同的函数执行，如果实际参数有2个，调用第一个函数，如果实际参数有三个，调用第二个函数。 JS语言没有函数重载的现象。一个标识符不能给两个函数，如果给了两个函数，第二个会覆盖前面的。不论参数是多少个，都会去执行最后一个函数内部的代码。 1 function fun(a,b){ 2 console.log(1); 3 } 4 function fun(a,b,c){ 5 console.log(2); 6 } 7 fun(1,2,3,4); JS的函数内部默认都有一个叫做arguments的类数组对象。在调用函数过程中，会传递参数，所有的实际参数不管有没有对应的形参都会存到arguments对面。 arguments对象内部存的是所有的实参，将实参以数组单独数据的形式存起来。 1 function fun(a,b){ 2 console.log(arguments); 3 } 4 fun(1,2,3,4,45,6,7); 1 function fun(a,b){ 2 // console.log(arguments); 3 arguments[5] = 10; 4 arguments.length = 10; 5 console.log(arguments.length); 6 var sum = 0; 7 for(var i = 0 ; i &lt; arguments.length ; i++){ 8 sum += arguments[i]; 9 } 10 console.log(sum); 11 } 12 fun(1,2,3,4,45,6,7); arguments并不能完全使用数组的所有方法。 1 var arr = arguments.slice(3,5); 2 console.log(arr); arguments常用于封装函数时，模拟函数重载现象。 一个函数有三个形式参数，用户传一个参数，直接给参数乘以2，传2个参数，求两个参数的和，如果穿3个参数，先比较前两个数的大小，大的数与第三个数求和。 1 function sum(a,b,c){ 2 //根据实际参数个数不同，走不同的分支 3 switch(arguments.length){ 4 case 1: 5 return a * 2; 6 break; 7 case 2: 8 return a + b; 9 break; 10 case 3: 11 return (a &gt; b ? a : b) + c; 12 break; 13 default: 14 throw new Error(&quot;参数个数必须是1到3个，请重新输入&quot;); 15 } 16 } 17 console.log(sum(1)); 18 console.log(sum(1,2)); 19 console.log(sum(1,2,3)); 20 console.log(sum(1,2,3,4)); 2、IIFEIIFE：immediately-invoked function expression。即时调用函数表达式。指的就是函数在声明、定义的同时，直接调用。 （）调用函数的操作符。不能直接用在关键字定义的函数后面。 1 function fun(){ 2 console.log(1); 3 }(); 可以用函数表达式直接调用。函数表达式中，将函数矮化成了表达式，表达式是可以参数数学运算。 1 var fun = function(){ 2 console.log(2); 3 }(); 可以通过将函数矮化成表达式的形式，直接进行调用。常用的其他方法：如果函数前面加一个数学运算符，就可以矮化成表达式。 1 2 +function fun(){ 3 console.log(1); 4 }(); 5 -function fun(){ 6 console.log(1); 7 }(); 8 !function fun(){ 9 console.log(1); 10 }(); 11 (function fun(){ //()是我们最常用 12 console.log(1); 13 })(); IIFE的函数不能再外面使用函数名调用，认为函数是未定义。 1 (function fun(){ 2 console.log(1); 3 })(); 4 fun(); IIFE将fun函数的作用域给关住，在外面调用找不到这个函数定义。最常见的IIFE的写法：内部的函数是一个匿名函数。 1 (function(){ 2 console.log(1); 3 })(); IIFE可以自身传递参数。 1 2 (function(a){ 3 a++; 4 console.log(a); 5 })(5); 6 (function(a){ 7 a++; 8 console.log(a); 9 })(5); 10 (function(a){ 11 a++; 12 console.log(a); 13 })(8); 在查找变量时，在IIFE内部查找，不会去全局。 1 var a = 5; 2 (function(a){ 3 a++; 4 console.log(a); 5 })(); 作用：用来解决一些闭包的问题。 3、通过数组观察闭包数组内部每一项都是一个函数。可以自动的通过遍历给数组添加项。 1 //在数组内添加十个函数 2 var arr = []; 3 for(var i = 0 ; i &lt; 10 ; i++){ 4 //闭包：记住自己的定义域环境、内部语句。 5 arr[i] = function(){ 6 console.log(i); 7 }; 8 } 9 console.log(arr[8]); 10 arr[0](); 11 arr[1](); 12 arr[2](); 13 arr[3](); 14 arr[4](); 15 arr[5](); 每个函数都记住了自己的定义域环境和内部语句，环境记住了一个i变量，最终执行时，i变量的值已经变成了10. 利用IIFE解决问题。 1 //在数组内添加十个函数 2 var arr = []; 3 for(var i = 0 ; i &lt; 10 ; i++){ 4 //闭包：记住自己的定义域环境、内部语句。 5 //IIFE可以关注函数的作用域 6 (function(a){ 7 //内部记住a的值是固定的了，就是这次循环传进来的i 8 arr[a] = function(){ 9 console.log(a); 10 } 11 })(i); 12 } 13 console.log(arr[8]); 14 arr[0](); 15 arr[1](); 16 arr[2](); 17 arr[3](); 18 arr[4](); 19 arr[5](); IIFE可以解决数组中闭包出现的问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则的术语和操作符]]></title>
      <url>%2F2016%2F10%2F26%2Ftitle12%2F</url>
      <content type="text"><![CDATA[由一些普通字符和一些特殊字符（又叫元字符–metacharacters）组成。普通字符包括大小写的字母和数字，而元字符则具有特殊的含义。 特殊字符： （） [ ] { } \ ^ $ | ? * + . 就想匹配特殊字符，将特殊字符进行转义。用到转义符号\。 ( [ . 1、精确匹配精确匹配指的是我们要去匹配某一个固定值或者常量，匹配abc，正则表达式里必须用精确的术语进行匹配。 正则表达式：/abc/,表示我们要匹配的是三个字符，分别是a，b，c，必须是顺序在一起，顺序不能颠倒。 2、预定义特殊字符：\t /\t/ 制表符 eg: console.log(/\t/.test(&apos; &apos;)) \n /\n 回车符 eg: console.log(/\n/.test(`aaa bbb`)); \f /\f/ 换页符 \b /\b/ 空格 3、字符集用正则表达式中的一类字符去配字符串中的一个字符。字符集用[]包括。 比如[abc]，表示可以匹配a，也可以匹配b，也可以匹配c，只要存在其中任意一个都是对的。 简单类:正则的多个字符对应一个字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符。将所有可能性都列在[]内，不要任何其他字符，直接连写 范围类:有时匹配的东西过多，而且类型又相同，全部输入太麻烦，我们可以在中间加了个横线。[a-z]、[0-9]、[A-Z] 组合类:允许用中括号匹配不同类型的单个字符[0-9a-b]只要数字和小写字母：[0-9a-z] 负向类:[]前面加个元字符(^)进行取反，表示匹配不能为括号里面的字符。[^a] 4、修饰符g 修饰符用于执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 match、replace这两种方法可以使用。 i 修饰符用于执行对大小写不敏感的匹配。 注意：修饰符书写位置，都是在//写完之后，紧跟在后面。修饰符可以同时使用，连写就可以。 5、边界^ 开头 注意不能紧跟于左中括号的后面 界定的是我们的字符串必须以什么为开头。^后面的正则术语匹配的字符串就必须是开头。 $ 结尾 界定的是必须以$前面的字符为结尾，$写在正则的最后。 ^和$可以同时使用，必须以他们中间的内容当做开头和结尾，字符串只能有中间的内容。 \b 单词边界，用于查找位于单词的开头或结尾的匹配。 对我们字符匹配是前后字符的界定。\b写在前面，表示后面的那个字符匹配时必须是一个单词的开始，\b写在后面，表示前面的那个字符匹配时必须是一个单词的结尾。 借用：\w,表示单词字符，包括数字、大小写字母、下划线。 \B 非单词边界，用于查找不处在单词的开头或结尾的匹配。 \B写在前面，表示后面的那个字符匹配时必须不是一个单词的开始，\B写在后面，表示前面的那个字符匹配时必须不是一个单词的结尾。 对比记忆：单词边界\b必须包括单词边界。非单词边界\B不能有单词边界。 6、预定义类预定义类其实都是对一些字符集的简写。 . [^\n\r] 除了换行和回车之外的任意字符 \d [0-9] 数字字符 digital \D [^0-9] 非数字字符 只要不是数字都可以 \s [ \t\n\x0B\f\r] 空白字符 空格、缩进、换行、换页 space \S [^ \t\n\x0B\f\r] 非空白字符 \w [a-zA-Z_0-9] 单词字符(所有的字母/数字/下划线) word \W [^a-zA-Z_0-9] 非单词字符 7、量词规定数量：作用范围是量词的前面的一个字符。 {n} 硬性量词 对应零次或者n次，n人为自定义的，可以是任意正数和0 {n,m} 软性量词 至少出现n次但不超过m次(中间不能有空格) {n,} 软性量词 至少出现n次(+的升级版) ? 软性量词 出现零次或一次 等价于{0,1} 软性量词 出现零次或多次(任意次) 等价于{0,} 软性量词 出现一次或多次（至少一次） 等价于{1,} 量词除了修饰前面的单个字符，还经常搭配预定义类使用。 8、或操作符可以使用竖线（|）字符表示或者的关系。 会匹配|前面或者后面。 a|bcd : 表示匹配的字符串，要么包括一个单独的a，要么包括一个整体的bcd。 可以利用小括号分组，将|操作符包裹起来，跟后面就没关系了。 (a|b)cd : 表示从a、b选一个，后面是cd。 验证一个月的31天： 1 ^((0?[1-9])|((1|2)[0-9])|30|31)$ 9、分组的反向引用反向引用标识是对正则表达式中的匹配组捕获的子字符串进行编号，通过“\编号(在表达式中)”，“$编号（在表达式外）”进行引用。从1开始计数。 在正则表达式里反向引用。 1 &apos;123*456&apos;.replace(/(\d{3})\*(\d{3})/, &apos;$2*$1&apos;) 除了直接反向引用 之外，还可以对引用的字符做一些复杂操作。 1 &apos;123*456&apos;.replace(/(\d{3})\*(\d{3})/, function (match, $1, $2) { 2 return $2 + &apos;*&apos; + $1 3 })4 10、中文匹配固定用法：[\u4e00-\u9fa5] 1 var str = prompt(&quot;请输入用户名，必须是4-6位的汉字&quot;); 2 var reg = /^[\u4e00-\u9fa5]{4,6}$/; 3 if(reg.test(str)){ 4 alert(&quot;right&quot;); 5 }else{ 6 alert(&quot;wrong&quot;); 7 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符串属性和方法]]></title>
      <url>%2F2016%2F10%2F23%2Ftitle11%2F</url>
      <content type="text"><![CDATA[1、length属性length 属性可返回字符串中的字符数目。 49 //数组可以存一组数据 50 var str = &quot;今天要多讲一会儿了hahaha，你能怎 样？&quot;; 51 console.log(str.length); 2、方法charAt() 方法可返回指定位置的字符。 index:字符索引值，从0开始。 36 语法：str.charAt(index); 52 var str = &quot;今天要多讲一会儿了hahaha，你能怎 样？&quot;; 53 console.log(str.charAt(3)); concat() 方法用于连接两个或多个字符串。原字符串不会被改变。 37 //concat() 方法用于连接两个或多个字符串。 38 var str2 = str.concat(&quot;不怎么样啊&quot;); 39 console.log(str); 40 console.log(str2); indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。得到的结果是字符串的索引值。 注意：区分字母大小写。如果找不到对应的字符，返回-1. 54 //indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 55 console.log(str.indexOf(&quot;多讲&quot;)); lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 注意：输出的还是索引值，它是从后面找第一次出现的位置。 41 console.log(str.indexOf(&quot;a&quot;)); 42 console.log(str.lastIndexOf(&quot;a&quot;)); slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。生成新的字符串，对原字符串没影响。 56 //slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。 57 var str2 = str.slice(4,8); 58 console.log(str); 59 console.log(str2); split() 方法用于把一个字符串分割成字符串数组。参数：分隔符。 43 var str2 = &quot;lsdfowekfsdfowekdowfefsfwepp&quot;; 44 var arr = str2.split(&quot;f&quot;); 45 console.log(str2); 46 console.log(arr); toLowerCase() 方法用于把字符串转换为小写。 toUpperCase() 方法用于把字符串转换为大写。 60 var str4 = str3.toUpperCase(); 61 var str5 = str4.toLowerCase(); 62 console.log(str3); 63 console.log(str4); 64 console.log(str5); substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。 start：开始的索引值。可以为正、可以为负。 length：截取的字符串数量。可以写可以不写，不写截取到字符串结尾。 47 var str4 = str3.substr(5,6); 48 console.log(str3); 49 console.log(str4); substring() 方法用于提取字符串中介于两个指定下标之间的字符。 substring() 方法返回的子串包括 start 处的字符，但不包括 end 处的字符。与slice一样。 不一样：substring参数不能为负。两个参数位置可以互换，第一个参数字符位置可以在第二个参数位置之后。 如果 start 比 end 大，那么该方法在提取子串之前会先交换这两个参数。end参数可以不写。 29 //substring() 方法用于提取字符串中介于两个指定下标之间的字符。 30 var str4 = str3.substring(4,9); 31 var str5 = str3.substring(9,4); 32 console.log(str3); 33 console.log(str4); 34 console.log(str5);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[if语句]]></title>
      <url>%2F2016%2F10%2F10%2Ftitle5%2F</url>
      <content type="text"><![CDATA[1、if语句if是如果的意思。else，否则。 1 语法： 2 if(condition){ 3 statement1 //结构体，多行代码，写在一对大括号内部 4 }else{ 5 statement2 6 } 结构体要执行就都执行，要不执行，就都不执行。 condition：条件表达式，强制给我们转成布尔值。 含义：如果条件condition为真，执行第一个结构体。如果为假，执行第二个结构体。 1 if(条件){ 2 条件为真，执行的结构体； 3 }else{ 4 条件为假，执行的结构体； } if语句可以没有else，条件成立执行结构体，不成立直接退出程序 1 if(a &lt; 60){ 2 alert(&quot;抱歉没及格，努力吧&quot;);3 } 如果执行的结构体只有单行语句，可以省略大括号 1 if(a &gt;= 60) 2 alert(&quot;恭喜，及格了&quot;); 3 else 4 alert(&quot;很遗憾，没及格，继续努力&quot;); 也能写在if语句的同一行，仅限单行结构体。 1 if(a &gt;= 60) alert(&quot;恭喜，及格了&quot;); 2 else alert(&quot;很遗憾，没及格，继续努力&quot;); 这两种写法不会报错，但是为了避免出一些不必要的问题，尽量写大括号。大括号后面不需要写分号，不会出错。 if语句殊途同归，不管执行哪个程序，退出后都继续执行后面的语句 1 if(a &gt;= 60){ 2 alert(&quot;恭喜，及格了&quot;); 3 }else{ 4 alert(&quot;很遗憾，没及格，继续努力&quot;); 5 } 6 alert(&quot;好好准备下一次考试&quot;); 2、多条件分支语句条件并不是只有一个，每一个条件对应一个结构体。 if……else if …… else if…… else if…… else …… 如果……否则如果……否则如果……否则…… 1 if(条件1){ 2 满足条件1执行的结构体 3 }else if(条件2){ 4 条件1不满足，满足条件2时执行的结构体 5 }else if(条件3){ 6 条件1/2都不满足，满足条件3时执行的结构体 7 }else if(条件4){ 8 条件1/2/3都不满足，满足条件4时执行的结构体 9 }else{ 10 以上条件都不满足，执行的结构体11 } 跳楼现象：程序会选择一个分支执行（跳楼），如果执行了这个分支，表示前面分支的条件都没有满足。 案例：详细划分成绩评价，优秀，良好，及格，不及格。 1 if(a &gt;= 90){ 2 alert(&quot;优秀&quot;); 3 }else if(a &gt;= 70){ //如果走到这一步，隐含了a&lt;90 4 alert(&quot;良好&quot;); //执行完之后，直接跳楼，不会执行后面的条件分之 5 }else if(a &gt;= 60){ 6 alert(&quot;及格&quot;); //如果走到这一步，隐含了a&lt;70 7 }else{ 8 alert(&quot;不及格&quot;);9 } 大坑 1 var b = 1; 2 if(b &lt;= 3){ //只会选择这个条件内部的结构体，执行后直接跳楼 3 b += 4; 4 }else if(b == 5){ 5 b += 3 6 }else if(b == 8 ){ 7 b += 4 8 }else{ 9 b += 10; 10 } 11 console.log(b); 3、if语句嵌套制作一个结构的时候，有两个限制条件，可以使用if语句的嵌套。 if语句可以嵌套if语句使用，最终执行符合条件成立的结构体 1 if(sex == &quot;男&quot; &amp;&amp; age &gt;= 22){ 2 alert(&quot;可以领证了&quot;); 3 }else if(sex == &quot;女&quot; &amp;&amp; age &gt;= 20){ 4 alert(&quot;可以领证了&quot;); 5 }else{ 6 alert(&quot;你还小，等等吧&quot;); 7 } 以上程序也可以达到效果：结构划分不清晰，条件比较复杂。 1 //if语句嵌套方法，每一层if语句只判断一个条件，内部再去进行另一个条件的判断。 2 //第一层，只判断性别 3 if(sex == &quot;男&quot;){ 4 //第二次，判断年龄 5 if(age &gt;= 22){ 6 alert(&quot;可以领证了&quot;); 7 }else{ 8 alert(&quot;你还小，等等吧&quot;); 9 } 10 }else{ 11 //第二次，判断年龄 12 if(age &gt;= 20){ 13 alert(&quot;可以领证了&quot;); 14 }else{ 15 alert(&quot;你还小，等等吧&quot;); 16 } 17 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS条件分支语句]]></title>
      <url>%2F2016%2F10%2F10%2Ftitle6%2F</url>
      <content type="text"><![CDATA[1、三元运算符他是唯一一个需要三个元素参与的运算。也叫作三元表达式。 符号：? : 1 语法：boolean_expression ? true_value : false_value; 表示：前面的布尔表达式的值只有true和false两种，如果为true，运算结果就是冒号前面的true_value，如果是false，运算结果就是冒号后面的false_value。 表达式：在js里面如果出现表达式，在参与代码运行时，会先计算出结果。 1 var a = 23; 2 console.log(true ? 1 : 0); 3 console.log(false ? 1 : 0); 4 console.log(7 &gt; 8 ? 1 : 0); 5 console.log(a &gt; 0 ? 1 : 0); 6 console.log(&quot;nihao&quot; ? 1 : 0); 7 console.log(&quot;&quot; ? 1 : 0); 三元运算符的结果都可以用if语句模仿。 1 //用if语句模拟三元运算符 2 var a = 23; 3 if(a &gt; 0){ 4 console.log(1); 5 }else{ 6 console.log(0); 7 } 简单的二选一得到值的程序里，三元运算符比if语句要更加简单。而且，三元运算符会直接计算出一个值，可以赋值给变量。 1 var a = 7 &gt; 8 ? 1 : 0; 2 console.log(a); 遇到给变量通过条件二选一赋值的时候，三元表达式更加好用。 1 var beishu; 2 if(year == 0){ 3 //发月薪的1倍月薪年终奖，如果月薪大于8000，那么就是发1.2倍 4 beishu = salary &gt; 8000 ? 1.2 : 1; 5 }else if(year == 1){ 6 beishu = salary &gt; 10000 ? 1.7 : 1.5; 7 }else{ 8 beishu = salary &gt; 12000 ? 3.2 : 3; 9 } 10 bonus = salary * beishu; 11 alert(&quot;您的年终奖是&quot; + bonus + &quot;元&quot;); 拓展：逻辑运算符也有选择的功能。 1 var year = parseFloat(prompt(&quot;请输入你的工作年限，不满1年输入0&quot;)) || 0; 2、switch语句开关语句允许一个程序求一个表达式的值，并且尝试去匹配表达式的值到一个case标签。如果匹配成功，这个程序执行相关的语句。 比较if语句和switch语句： if语句： 1 if(xingzuo == &quot;白羊座&quot;){ 2 alert(&quot;会有旧朋友约见面，还有一两场的应酬，相对是比较有口福的一天，但是要注意别饮食过量，引起肠胃不适，另外还需要花费一笔钱。爱情不太稳定，会有点的小状况，部...&quot;); 3 }else if(xingzuo == &quot;金牛座&quot;){ 4 alert(&quot;今天运势佳，生活无忧无虑，爱情欢乐浪漫，时刻能感受到激情的乐趣，单身者寻寻觅觅，真爱可能就在身边。另一半会是你工作上的好帮手，能为你解决许多问题。&quot;); 5 }else if(xingzuo == &quot;双子座&quot;){ 6 alert(&quot;今日头脑清醒，思路也变得清晰许多，时间比较宽裕，可以多看看书，多补充一些额外的专业知识，对以后的发展会有帮助。对投资理财有点兴趣，领悟能力不错&quot;); 7 }else{ 8 alert(&quot;不好意思，查不到了&quot;); 9 } switch语句： 1 switch(xingzuo){ 2 case &quot;白羊座&quot;: 3 alert(&quot;会有旧朋友约见面，还有一两场的应酬，相对是比较有口福的一天，但是要注意别饮食过量，引起肠胃不适，另外还需要花费一笔钱。爱情不太稳定，会有点的小状况，部...&quot;); 4 break; 5 case &quot;金牛座&quot;: 6 alert(&quot;今天运势佳，生活无忧无虑，爱情欢乐浪漫，时刻能感受到激情的乐趣，单身者寻寻觅觅，真爱可能就在身边。另一半会是你工作上的好帮手，能为你解决许多问题。&quot;); 7 break; 8 case &quot;双子座&quot;: 9 alert(&quot;今日头脑清醒，思路也变得清晰许多，时间比较宽裕，可以多看看书，多补充一些额外的专业知识，对以后的发展会有帮助。对投资理财有点兴趣，领悟能力不错&quot;); 10 break; 11 default: 12 alert(&quot;不好意思，查不到了&quot;); 13 break; 14 } 语法： 1 switch(expression){ 2 case label1: //如果表达式的值等于label1，执行下面的statement1. 3 statement1; 4 break; //遇到break，直接跳出switch语句。 5 case label2: //如果表达式的值等于label2，执行下面的statement2. 6 statement2; 7 break; //遇到break，直接跳出switch语句。 8 case label3: //如果表达式的值等于label3，执行下面的statement3. 9 statement3; 10 break; //遇到break，直接跳出switch语句。 11 …… 12 default://前面的情况都不匹配，执行default后面的结构体 13 statement_n; 14 break;15 } default：相当于if语句里面的else。可以省略。如果写了，前面不符合就走default，如果不写，前面情况都不符合，直接跳出switch。后面的break可以不写。 break：打断程序，强制跳出当前的switch语句。如果不写break，程序会继续往下进行，直到碰到一个break或者程序执行完，才能跳出。 1 switch(a){ 2 case 3: 3 alert(&quot;three&quot;); 4 case 4: 5 alert(&quot;four&quot;); 6 case 5: 7 alert(&quot;five&quot;); 8 case 6: 9 alert(&quot;six&quot;); 10 case 7: 11 alert(&quot;seven&quot;); 12 case 8: 13 alert(&quot;eight&quot;); 14 case 9: 15 alert(&quot;nine&quot;); 16 default: 17 alert(&quot;sorry, I don&apos;t know&quot;); 18 } 虽然不写不能跳出程序，我们可以利用这个特点做一些特殊的小程序。 1 var a = parseInt(prompt(&quot;请输入一个个位数，会输出它是奇数还是偶数&quot;)); 2 switch(a){ 3 case 1: 4 case 3: 5 case 5: 6 case 7: 7 case 9: 8 alert(&quot;奇数&quot;); 9 break; 10 default: 11 alert(&quot;偶数&quot;); 12 } 以下写法是错误： 1 case 1 || 3 || 5 || 7 || 9: //程序遇到表达式会先计算出结果。2 alert(“奇数”);3 break; switch语句能做的，if语句都能做。但是对于给某一个值进行匹配的情况，switch语句更优化。 总结： if语句最常用，可以做所有的条件分支语句。三元运算符，多用于给某一个变量赋值时二选一的情况。switch语句，多用于给某一个变量去匹配固定值的情况。以下也可以判断成绩好坏，但是不如if语句清晰。 1 var a = 67; 2 switch(true){ 3 case a &gt;= 90: 4 alert(&quot;best&quot;); 5 break; 6 case a &gt;= 70: 7 alert(&quot;better&quot;); 8 break; 9 case a &gt;= 60: 10 alert(&quot;good&quot;); 11 break; 12 default: 13 alert(&quot;bad&quot;); 14 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[运算符介绍]]></title>
      <url>%2F2016%2F09%2F30%2Ftitle4%2F</url>
      <content type="text"><![CDATA[运算符1、概述 运算符（Operators，也翻译为操作符），是发起运算的最简单形式。数学运算符(Arithmetic operators)比较运算符(Comparison operators)逻辑运算符(Logical operators)赋值运算符(Assignment operators)按位运算符(Bitwise operators)条件 (三元) 运算符(Conditional operator) 2、数学运算符数学运算符： + - * / % () 运算顺序：先算乘除取余，再算加减，有小括号先算小括号。js里数学运算没有[]、{}，全部用（）代替。 正规：数字与数字之间进行数学运算。非正规：数字与其他类型数据进行运算，其他类型数据之间进行数学运算。 ①如果是数字与纯数字字符串字符串之间进行运算。 除了＋号之外，其他的运算符，会自动将字符串转成数字。这个过程是私下进行，叫做隐式转换。不需要使用parseInt等方法。 1 // 数字与纯数字字符串,纯数字字符串之间 2 console.log(12 + &quot;2&quot;); //&quot;122&quot; 3 //在纯数字字符串参与运算之前，被隐式转换成数字类型 4 console.log(12 - &quot;2&quot;); //&quot;122&quot; 5 console.log(12 * &quot;2&quot;); //&quot;122&quot; 6 console.log(12 / &quot;2&quot;); //&quot;122&quot; 7 console.log(12 % &quot;2&quot;); //&quot;122&quot; 8 console.log(&quot;12&quot; % &quot;2&quot;); //&quot;122&quot; ②其他类型的数据参与数学运算。 其他类型的数据也会发生饮食转换。] 转换为0：空字符串、null、false转成1：true转NaN：undefined、非空非纯数字字符串。 1 console.log(23 + true); 2 console.log(23 - true); 3 console.log(23 * true); 4 console.log(23 / true); 5 console.log(23 % true); 6 console.log(23 + false); 7 console.log(23 + null); 8 console.log(23 - “”); 9 console.log(23 - undefined); 10 console.log(23 - “hello”); 11 console.log(23 - “12hello”); 1 “”→0 null→0 false→0 true→1 “12helle”→NaN undefined→NaN ③特殊数字参与运算。 特殊值NaN参与的运算都会返回NaN。 1 //所有NaN参与的运算都返回NaN 2 console.log(12 + NaN); 3 console.log(12 - NaN); 4 console.log(12 * NaN); 5 console.log(12 / NaN); 6 console.log(12 % NaN); Infinity参与的运算，要单独看。 1 //Infinity参与运算 2 console.log(23 + Infinity); 3 console.log(23 - Infinity); 4 console.log(23 * Infinity); 5 console.log(23 / Infinity); 6 console.log(23 % Infinity); 7 console.log(Infinity % Infinity); 8 console.log(Infinity + Infinity); 9 console.log(Infinity - Infinity); 10 console.log(Infinity * Infinity); 11 console.log(Infinity / Infinity); 特殊值的数学运算，防止被大公司面试阴，要过一下脑子。不过数学运算的特殊值，真心没有任何实战价值，建议没必要刻意记忆，留着脑容量记更有用的。《高3》P47~P50 总结一下：纯数字字符串、字符串在参与数学运算时，除了加号之外，其他的运算都会隐式转换。其他数据类型参与任何数学运算都会被隐式转换。 3、比较运算符种类： 大于&lt; 小于= 大于等于&lt;= 小于等于== 相等!= 不等=== 全等!== 不全等 比较运算符输出结果，都是布尔值，要么是true，要么是false。 1 //数字与数字比较 2 console.log(7 &gt; 8); 3 console.log(7 &lt; 8); 4 console.log(7 &gt;= 8); 5 console.log(7 &lt;= 8); 6 console.log(7 == 8); 7 console.log(7 != 8); 8 console.log(7 === 8); 9 console.log(7 !== 8); 10 console.log(8 === 8); 11 console.log(8 !== 8); 非常规：数字与其他类型数据进行比较，或者其他数据类型之间进行比较。 ①如果数字进行其他比较，其他类型的数据会隐式转换为数字，然后再比较。 纯数字字符串转为对应的数字，空字符串、null、false转0，true转成1. 1 console.log(1 == “1”); 2 console.log(1 == true); 3 console.log(0 == false); 4 console.log(0 == null); 5 console.log(0 &gt;= null); 6 console.log(0 &lt;= null); 7 console.log(0 == “”); 相等于和全等于的区别：相等只判断值相等就够了，全等于还要判断数据类型。 1 //判断全等,除了判断值得大小，还要判断数据类型。 2 console.log(1 === &quot;1&quot;); 3 console.log(1 === true); 4 5 //不等于、不全等于，先看等于和全等于，取反 6 console.log(1 !== &quot;1&quot;); ②字符串与字符串进行比较。 不会隐式转换为数字，比较的是Unicode字符编码顺序。顺序在前面的小于顺序在后面。 字符编码顺序：数字0~9、大写字母A~Z、小写字母a~z。 比较方法：比较的不是字符串的长度，根据字符编码顺序，一个字符一个字符比较，直到比较出大小。 1 //字符串与字符串进行比较 2 console.log(&quot;12&quot; &lt; &quot;2&quot;); 3 console.log(&quot;22&quot; &lt; &quot;2&quot;); 4 console.log(&quot;abc&quot; &lt; &quot;banana&quot;); 5 console.log(&quot;ball&quot; &lt; &quot;banana&quot;); 6 console.log(&quot;ball&quot; &lt; &quot;23&quot;); 7 console.log(&quot;ball&quot; &lt; &quot;ABC&quot;); ③NaN参与的比较 除了不等于和不全等于，NaN参与的比较运算返回的都是false。 ④Infinity自身的比较 特殊情况： 比较：3&gt;2&gt;1; 原因：代码从前往后执行，先计算3&gt;2,得到的是true，再比较时true&gt;1,返回false。控制台快捷键：清空控制台：ctrl+L执行代码：enter换行：shift+enter重新输入上一次代码：Ctrl+↑。 4、逻辑运算符逻辑运算符常用于布尔类型值之间; 当操作数都是布尔值时，返回值也是布尔值。 &amp;&amp; 逻辑与运算符 且 交集|| 逻辑或运算符 并集! 逻辑非运算符 ①逻辑与运算 真值表 a &amp;&amp; ba b 输出真 真 真真 假 假假 真 假假 假 假 规律：都真才真，有假就假。 1 //逻辑与运算 2 console.log(true &amp;&amp; true); 3 console.log(true &amp;&amp; false); 4 console.log(false &amp;&amp; true); 5 console.log(false &amp;&amp; false); ②逻辑或运算 真值表 a || b a b 输出 真 真 真 真 假 真 假 真 真 假 假 假 规律：有真就真，都假为假。 1 //逻辑或运算 2 console.log(true || true); 3 console.log(true || false); 4 console.log(false || true); 5 console.log(false || false); ③逻辑非运算 规律：非真即假，非假即真。 1 // 逻辑非运算 2 console.log(!true); 3 console.log(!false); 4 console.log(!!!!!!!!!!!!false); 正常：用于布尔值之间的逻辑运算。 非正常：其他类型的数据参与逻辑运算。将其他的数据隐式转换成布尔类型的值，计算完之后，输出对应位置的数据。不一定是输出布尔值。 隐式转换成true：非0数字、非空字符串。隐式转换为false：0、NaN、空字符串、undefined、null 1 //非布尔类型的数据 2 console.log(35 &amp;&amp; null); 3 console.log(35 || null); 4 console.log(35 &amp;&amp; &quot;nihao&quot;); 5 console.log(35 || &quot;nihao&quot;); 当它们用于非布尔值的时候，返回值就可能是非布尔值。其实这种运算非常简单，就两句话： (逻辑与 &amp;&amp; ) 如果a能被转换为false，那么返回a；否则，返回b。(逻辑或 || ) 如果a能被转换为true，那么返回a；否则，返回b。 要能深层次的理解上面的话，达到不用刻意背，自行能推倒出来的“最高境界”。花式写法：短路语法。 5、短路语法将逻辑运算，模拟电路里面的短路。 ①逻辑与比喻成串联电路。 电流通过a到b；如果a为真，电流可以流通到b，不论b为真还是假，直接抛出b。如果a为假，电流通不过，停留在a，就直接抛出a。 1 // //逻辑与运算 2 console.log(23 &amp;&amp; &quot;haha&quot;); 3 console.log(23 &amp;&amp; null); 4 console.log(undefined &amp;&amp; Infinity); 5 console.log(NaN &amp;&amp; null); ②逻辑或比喻成并联电路。 电流优先通过a。如果a为真，电流可以直接通过a，不需要到b，直接抛出a。如果a为假，电流不能通过a，换到b流过，不管b为真还是假，都抛出b。 1 //逻辑或运算 2 console.log(23 || &quot;haha&quot;); 3 console.log(23 || null); 4 console.log(undefined || Infinity); 5 console.log(NaN || null); 逻辑运算有顺序：非、与、或。 案例：NaN &amp;&amp; null || 23 &amp;&amp; !true || !false 原式= NaN &amp;&amp; null || 23 &amp;&amp; !true || !false = NaN &amp;&amp; null || 23 &amp;&amp; false || true = NaN || false || true = false || true = true 6、赋值运算符做了两步工作：先运算，后赋值。必须有变量参与运算。 = 等于 += 加等于 将后面的值加到原来的变量值上，得到的值赋值给变量 -= 减等于 *= /= %= ++ 递加 在原来的基础上加1，再赋值 – 递减 在原来基础上减一，在赋值 1 //带等号的赋值运算符 2 var a = 1; 3 4 //加等于 5 a += 2;// a = a + 2; 6 console.log(a); //3 7 8 //减等于 9 a -= 5; // a = a - 5; 10 console.log(a); //-2 11 12 //乘等于 13 a *= -5; // a = a * -5; 14 console.log(a); //10 15 16 //除等于 17 a /= 2; // a = a / 2; 18 console.log(a); //5 19 20 //取余等于 21 a %= 6; // a = a % 6; 22 console.log(a); //5 递加：符号++，与前面的变量之间不能有空格。而且++符号可以写在变量的前面，也可以写在后面。着这两种情况使用时有一些区别。 ++a:如果在一个算式里，第一次使用的值，是加完后的值，第二次使用也是加完后的新值。a++：如果在一个算是里，参与运算时，第一次使用时原来的就值，第二次使用的时候就是新值。 1 var a = 2; 2 console.log(a++); 3 console.log(a); 4 a = 2; 5 console.log(++a); 6 console.log(a); 特殊运算： 1 var a = 10, 2 b = 20, 3 c = 30; 4 var sum = ++a + b++ + a++ + ++c; 5 console.log(sum); //73 6 console.log(a); //12 7 console.log(b); //21 8 console.log(c); //31 7、综合运算顺序贴身的 → 数学的 → 比较 → 逻辑的 → 赋值的。 1 综合案例： 2 var a = 4; 3 a *= 1 * (2 + 3) &amp;&amp; ++a || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || !9;4 原式 = a *= 1 * (2 + 3) &amp;&amp; ++a || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || !9; = a *= 1 * (2 + 3) &amp;&amp; 5 || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || false; = a *= 5 &amp;&amp; 5 || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || false; = a *= 5 &amp;&amp; 5 || false &amp;&amp; true || false = a *= 5 || false || false = a *= 5 a = 20]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数的使用]]></title>
      <url>%2F2014%2F10%2F17%2Ftitle8%2F</url>
      <content type="text"><![CDATA[函数就是功能。函数可以封装一段代码，整体会具备一个功能，可以人为的定义自己的功能。函数执行时候，所有的这一段封装的代码都会立即执行，实现这个功能。 1 //定义函数 2 function fun(){ 3 console.log(1); 4 console.log(2); 5 console.log(3); 6 console.log(4); 7 console.log(5); 8 } 9 //使用函数 10 fun(); 11 fun(); 函数的特点①：函数能够封装一些重复性的代码，使用时直接调用，简化代码。 1、函数的声明和调用1.1 函数的声明 函数必须先定义才能使用。 函数定义：也叫作函数声明。关键字：function。本身就是功能意思。定义语法：function关键字后面必须跟一个空格，后面是我们自定义的函数名字，紧跟着是一个小括号（参数），后面紧跟着是一个大括号，里面放的就是我们封装的结构体。函数后面不用加分号。 1 function 函数名(参数){ 2 封装的结构体； 3 } 函数名是一种标识符，必须遵循标识符命名规范： 首字符必须是字母、下划线、美元符号。 其他字符可以是字母、下划线、美元符号、数字。 区分大小写，且不能是关键字和保留字。 1 function fun(){ 2 alert(&quot;hello world&quot;); 3 } 意义：只是定义了一下函数执行时要做的工作，并不会去自动执行这些代码。函数只有调用的时候，才会执行内部的结构体。 1.2函数的调用 函数调用方法：函数名（）；直接在函数名后面加小括号。 1 //函数声明 2 function fun(){ 3 alert(&quot;hello world&quot;); 4 } 5 //函数的调用 6 fun(); 函数内部的结构体执行的位置，与定义的位置无关，与函数调用的位置有关。 1 //定义函数 2 function fun(){ 3 console.log(1); 4 console.log(2); 5 console.log(3); 6 } 7 console.log(10); 8 console.log(20); 9 console.log(30); 10 fun(); 函数一次声明，可以多次调用。函数每次调用时，内部的结构体都会全部一起执行。 1 fun(); 2 fun(); 2、函数的参数函数使用的目的，方便我们重复使用某一个功能，有时候需要功能发生一些变化，函数留了一个接口给我们，让我们的程序可以根据输入值的不同发生相应变化。 参数就是函数预留的接口：通过参数的变化，让函数执行结果发生改变。参数书写位置：函数名后面的小括号里。 1 function 函数名(参数){ 2 封装的结构体； 3 } 参数：就是一些变量。可以有一个变量或者多个变量。 1 //定义函数 2 function fun(a){ 3 console.log(a); 4 } 5 //调用时 6 fun(1); 函数的参数：定义时，小括号内的参数叫做形式参数（形参），调用时小括号内的参数叫做实际参数（实参），真正调用时参与到结构体里面的数据是实际参数的数据。 整个函数调用的过程，就是实际参数传递给形式参数（过程叫做传参），执行语句的过程。 函数的执行结果跟传递的参数息息相关。 参数本身是变量：变量的数据类型是动态变化，跟我们变量的赋值的数据类型有关。根据传参的不同，我们的函数会出现不同的结果。 案例：定义一个求和的函数。 1 //定义求和函数 2 function sum(a,b){ 3 console.log(a + b); 4 } 5 //调用 6 sum(2,3); 7 sum(2,&quot;3&quot;); arguments：实际参数组成的一个类数组对象。函数的形参和实参的个数可以不同。函数的形式参数可以少于实际参数，匹配对应形参的个数，多余的实参，不参与程序的执行。 1 //定义求和函数 2 function sum(a,b){ 3 console.log(a + b); 4 } 5 //调用 6 sum(1,2,3,4); 函数的形式参数多于实际参数，对应的实参先匹配传递，多出来的形式参数相当于只定义没有赋值，有一个默认的undefined值，会参与程序执行。 1 //定义求和函数 2 function sum(a,b){ 3 console.log(a + b); 4 } 5 //调用 6 sum(3); 函数参数提供了一个便利： 其实根本不需要去看函数内部的结构体怎么定义的，只需要知道执行函数传递几个参数，能实现什么功能就行了。后期，只需要对相应的函数传参，执行实现某种功能即可。 定义函数后：给一个说明，告诉用户输入几个参数，参数的数据类型要求是什么，执行之后会有什么后果。也叫API使用说明。 函数的特点 ②：函数很便利，只需要知道怎么使用某一个函数，不需要了解内部的构造。可以使用自己的函数，也可以使用别人的定义的函数，只需要知道怎么用，不需要知道为什么。简化我们自己的编程。 3、函数的返回值函数可以通过参数接收数据，也可以通过一个return返回一个值。 return：返回的意思。将函数执行结果返回一个固定的值。 1 //定义函数 2 function sum(a,b){ 3 return a + b; 4 } 5 //函数返回的是一个计算后的值，需要一个输出语句看值是多少 6 console.log(sum(2,3)); 如果函数有return返回值，就相当于将函数矮化成了一个表达式，表达式都会计算出一个结果参与到程序里。 可以将有return的函数执行后赋值给一个变量。 函数的参数也是变量，函数执行时，传递实参可以是另外一个有return函数的执行结果。 2 console.log(sum(4,sum(2,3))); 函数的特点③： 函数可以有返回值，可以将他的返回值当做另一个函数的参数，参与编程。模块化编程。 return的另外一个功能：函数内部如果遇到return，不会往下继续执行，跳出函数。 2 function fun(){ 3 console.log(1); 4 console.log(2); 5 console.log(3); 6 return; 7 console.log(4); 8 console.log(5); 9 console.log(6); 10 } 11 fun(); 4、模块化编程逆向思维：输出0~10000之间的完美数 → 什么是完美数 → 一个数的约数和 写的过程：约数和函数 → 判断完美数函数 → 输出所有完美数 13 // 逆向思维：输出0~10000之间的完美数 → 什么是完美数 → 一个数的约数和 14 // 写的过程：约数和函数 → 判断完美数函数 → 输出所有完美数 15 16 //封装一个约数和函数，传入一个数，返回它的约数和 17 function sum(a){ 18 var sum = 0; 19 for(var i = 1 ; i &lt; a ; i++){ 20 if(a % i == 0){ 21 sum += i; 22 } 23 } 24 return sum; 25 } 26 //console.log(sum(10)); 27 //可以封装判断完美数函数，传入一个数，返回它是否是完美数 28 function isWanmei(a){ 29 if(a == sum(a)){ 30 return true; 31 }else{ 32 return false; 33 } 34 } 35 //console.log(isWanmei(16)); 36 //输出0-10000之间的所有完美数 37 for(var i = 1 ; i &lt;= 10000; i++){ 38 if(isWanmei(i)){ 39 console.log(i); 40 } 41 } &gt; 5、函数递归递归：函数内部通过函数名调用这个函数本身。 19 //定义函数，内部调用了这个函数 20 function sum(a,b){ 21 b = sum(a,b); 22 return a + b; 23 } 24 console.log(sum(1,2)); 递归如果写的不够严谨，容易出错。使用时一定要考虑好。 斐波那契数列： 1、1、2、3、5、8、13、21、34、55、89、144、233……用求和函数内部，参数就是自己的上一次函数执行。 2 //定义函数，从第三项开始，等于前两项的和 3 //输出第几项斐波那契数列的值 4 function fib(a){ 5 if(a == 1 || a == 2){ 6 return 1; 7 }else{ 8 return fib(a-1) + fib(a-2); 9 } 10 } 11 console.log(fib(1)); 12 console.log(fib(2)); 13 console.log(fib(3)); 14 console.log(fib(4)); 15 console.log(fib(5)); 16 console.log(fib(6)); 17 console.log(fib(7)); 18 console.log(fib(8)); 6、函数表达式通过将一个匿名函数（或者有函数名的函数）矮化成一个表达式，赋值给一个变量的形式定义函数。 调用方法：使用变量名加小括号调用。不能用函数自身的名字调用，会报错。能够在函数内部用自己函数名字。 匿名函数：函数没有名字。也叫拉姆达函数。 9 //定义：将一个函数赋值给变量 10 //这种定义方式最后要加分号，相当于一个普通的语句给变量赋值。 11 var fun = function(){ 12 console.log(1); 13 }; 14 // 调用使用变量加小括号 15 //因为变量内部的值是一个函数，数据类型是函数的类型，函数能加小括号执行。 16 fun(); 9 var fun = function fun1(){ 10 console.log(1); 11 }; 12 //函数赋值给一个变量，函数名在外面就相当于未定义 13 fun(); 14 fun1(); 但是，函数名在函数内部是可以使用的。 8 var fun = function fun1(a){ 9 if(a == 1 || a == 2){ 10 return 1; 11 }else{ 12 return fun1(a - 1) + fun1(a - 2); 13 } 14 }; 15 //函数赋值给一个变量，函数名在外面就相当于未定义 16 console.log(fun(3)); 17 console.log(fun1(3)); 7、函数的数据类型函数数据类型：function。函数类型 10 // //定义：将一个函数赋值给变量 11 var fun = function fun1(a){ 12 if(a == 1 || a == 2){ 13 return 1; 14 }else{ 15 return fun1(a - 1) + fun1(a - 2); 16 } 17 }; 18 function fun2(){ 19 console.log(1); 20 } 21 console.log(typeof fun); 22 console.log(typeof fun2); function数据类型是一种复杂数据类型，也叫作引用类型。 简单数据类型：number、string、undefined、boolean、null。 变量内部数据类型是动态数据类型，存储数据是什么类型就是什么。 变量内部存的数据如果是简单数据类型的，存的就是一个实际的确切的能自身更改的值。 变量内部存的数据如果是引用类型，存的不是一个确切的object，而是这个对象的地址、指针。 如果存的是简单数据类型，将一个变量赋值给另一个变量的时候，相当于将变量内部的值复制了一份给新变量，而其中一个变量发生变化，对另一个不会产生任何影响。 7 var a = 1; 8 var b = a; 9 b = 2; 10 console.log(a); 11 console.log(b); 如果变量存的是引用类型，赋值给别的变量时，是将对象的地址复制一份给b，a和b指向的是一个对象原型，通过a或者b对对象做出变化，另外一个也会相应发生变化。 17 //复杂的数据类型，存储地址 18 var a = function(){ 19 console.log(1); 20 }; 21 var b = a; 22 b.haha = 2; 23 console.log(a.haha); 24 console.log(b.haha);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS循环语句]]></title>
      <url>%2F2014%2F10%2F13%2Ftitle7%2F</url>
      <content type="text"><![CDATA[1、循环语句循环语句是一系列反复执行直到符合特定条件的命令。 循环语句实际是对某一段代码进行循环执行，在规定的一个判断条件表达式为假的时候，跳出循环，停止重复执行。 JavaScript 支持 for, do while, while这些循环语句。另外，你可以在循环语句中使用break和continue 语句 。 1、for循环语句for循环语句是一种前测试循环语句。在执行下一次需要重复的代码之前，我需要先测试一下条件表达式到底是真还是假。如果是真，可以执行，如果是假，就不在循环，跳出for循环。for循环内部的循环语句执行时有先决条件。 1 //体验一下考拉体重飙升的过程 2 for(var i = 7 ; i &lt;= 178 ; i+=3){ 3 console.log(&quot;考拉今天&quot; + i + &quot;斤了&quot;); 4 } for循环的语法： 1 for(){} 其他人总结的规律： 1 for(定义循环变量；变量的最大值；步长){ 2 循环体； 3 }以上总结有局限性，for循环并不是只有这一种书写情况。 运行原理： 遇到for循环，先执行①位置的语句，然后执行语句②条件表达式，如果②的值为true，继续执行语句③；如果②的结果为false，直接跳出for循环，执行语句⑤。如果能执行到语句③，执行完之后，去执行语句④，然后再执行语句②，如果②的值为true，继续执行语句③；如果②的结果为false，直接跳出for循环，执行语句⑤。重复这个过程……直到条件②语句为假false，彻底跳出for循环，去执行语句⑤。 注意：（）里面有三个语句，用两个分号分割开，最后一个语句后面不要加分号。 1 for(var i = 3 ; i &lt;= 35 ; i += 6;){ 2 console.log(i); 3 } 1 //第二个 2 for(var i = 5 ; i &lt; 25 ; i += 5){ 3 console.log(i); 4 } 1 //第三个 2 for(var i = 30; i &gt;= 10 ; i -= 7){ 3 console.log(i); 4 } 1 //第四个 2 for(var i = 3 ; i &lt;= 35 ; i *= 2){ 3 console.log(i); 4 } for循环内部定义的这个i变量，是一个全局变量，定义在全局，可以在全局任意地方使用。可以将i变量的声明和赋初值，写在for循环外面，第一个语句的位置可以空着。 1 //第五种 2 var i = 3; 3 for(; i &lt;= 10 ; i += 3){ 虽然第一个语句可以不写，但是分号不能省略 4 console.log(i); 5 } 如果不写第一个分号，会报错，认为你没写第三个语句 1 //第六个 2 var i = 3; 3 for(console.log(i++); i &lt;= 10 ; i += 3){ 4 console.log(i); 5 } 如果限制条件没有了，不写，认为可以一直进入到语句③，循环会无限进行下去，叫做死循环。程序一定要合理，不要书写死循环。 1 //第七个 2 var i = 3; 3 for(console.log(i++); ; i += 3){ 4 console.log(i); 5 } 6 var i = 3; 7 for(console.log(i++); i &gt; 1 ; i += 3){ 8 console.log(i); 9 }10 1 //第八个 2 for(var i = 4 ; i &lt;= 12 ;){ 3 i += 3; 4 console.log(i); 5 } 1 //第九个 2 for(var i = 4 ; i &lt;= 3 ;){ 3 i += 3; 4 console.log(i); 5 } for循环内部可以嵌套if语句，输出并不是无条件输出，只有满足某一个条件才会执行输出代码。 1 //第十个，嵌套if语句 2 for(var i = 3 ; i &lt;= 20 ; i += 5){ 3 if(i % 2 == 0){ 4 console.log(i); 5 } 6 } for循环还可以嵌套for循环，注意我们定义的循环变量一定不能重复。循环变量常用名字i,j,k. 1 //第十一个 2 for(var i = 1 ; i &lt;= 5 ; i++){ 3 for(var j = 1; j &lt;= 4 ; j++){ 4 console.log(i,j); 5 } 6 } 2、穷举思想一般我们希望得到一组有特殊意义的数据，电脑并不会直接帮我们输出，而是需要我们编写一段代码，规定一个合理范围，从范围内找到这些数据。电脑需要一一去验证某一个数据是否符合条件，如果符合就输出。 程序必须将范围内每一个数据都检测一遍，通过判断条件确定是否符合要求。这些都需要我们来编写。用到我们的循环将所有可能情况循环一遍，挑出有用的，用if语句。 穷举思想：将可能性全部列举完，穷就是穷尽、完全的意思。 外层：for循环，列举。 内层：if语句，判断。 3、do while循环do while循环是一种后测试循环语句，重复执行某一段代码，直到入口条件测试为假时，跳出循环。 1 语法： 2 do{ 3 statement 4 }while(expression);5 6 do：做某事 while：当……时候 特点：在第一次测试条件之前，结构体会提前执行一次。通常会定义一些变量，让循环有一些不同。需要将这样的变量定义在循环外面，如果定义在内部，会每次重置，有可能死循环。 1 //循环变量定义在循环外面 2 var i = 1; 3 do{ 4 console.log(i); 5 i++; 6 }while(i &lt;= 10); 结构体总是会至少输出一次，条件是后测试的，哪怕条件为假，我也会执行一次结构体。 1 //循环变量定义在循环外面 2 var i = 1; 3 do{ 4 console.log(i); 5 i++; 6 }while(i &gt;= 10); for循环其实可以模拟do while的结构体先执行一次的情况，但是不够优化，尽量少用。 1 //for循环模拟do while 2 var i = 1; 3 for(console.log(i); i &gt;= 9 ; ){ 4 console.log(++i); 5 } 1 //如果变量写在内部，每次循环都会重置，有可能是死循环 2 do{ 3 var i = 1; //全局变量不要定义在内部，会被重置，死循环 4 console.log(i); 5 i++; 6 }while(i &lt;= 10); 7 变量自加的语句，写在输出语句前面和后面，得到的结果是不一样的。 4、while循环while语句反复执行直到一个特定的条件计算为假。 while语句是一个前测试循环语句，在循环体中的代码执行之前，就要测试出口条件。 语法： 1 while(expression){ 2 statement;} 注意：如果有循环变量，需要定义在循环外边。 1 //循环变量写在外面 2 var i = 1; 3 while(i &lt; 10){ 4 console.log(i); 5 i += 3; 6 } 可以用for循环模拟，都是前测试循环语句。 1 //while语句能做的，for循环都能做 2 for(var i = 1 ; i &lt; 10 ; i += 3){ 3 console.log(i); 4 } 变量自加的过程写的位置不同，结果不同。 1 var i = 1; 2 while(i &lt; 10){ 3 i += 3; 4 console.log(i); 5 } 总结：for循环是最重要，用的最多的循环语句。如果必须先执行一次结构体，再判断，最好用do while循环。while能做的for都能做。随意挑选。 5、breakbreak会终止我们的循环。 1 //碰到5的倍数，就停止循环 2 for(var i = 1 ; i &lt; 40 ; i++){ 3 console.log(i); 4 if(i % 5 == 0){ 5 break; 6 } 7 } break如果没有特殊指向，只能终止自己在的内层循环，不能终止外层的其他循环。 1 for(var i = 1 ; i &lt;= 4 ; i++){ 2 for(var j = 1 ; j &lt;= 4 ; j++){ 3 console.log(i,j); 4 if(j == 2){ 5 break; 6 } 7 } 8 } break控制外层循环：给外层循环加一个标签，标签可以代表外层循环，在break后面加这个标签，就会终止标签对应的这一层循环。 1 waiceng : for(var i = 1 ; i &lt;= 4 ; i++){ 2 for(var j = 1 ; j &lt;= 4 ; j++){ 3 console.log(i,j); 4 if(j == 2){ 5 break waiceng; 6 } 7 } 8 } 所有循环语句：如果能够执行break语句，都会跳出循环。 6、continue作用：终止当前这一次的循环，直接进入下一次循环。案例：从1到10，去找偶数，判断如果不是2，不输出直接进入下一个循环。 1 for(var i = 1 ; i &lt;= 10 ; i++){ 2 //如果你不能被3整除，直接跳过看下一个可能性 3 if(i % 3 != 0){ 4 continue; 5 } 6 console.log(i); 7 } continue语句与break一样，也只能作用于当前的循环，不能控制外层循环。 1 for(var i = 1 ; i &lt; 4; i++){ 2 for(var j = 1 ; j &lt; 4 ; j++){ 3 if(j == 2){ 4 //这不是我要的，继续下一次循环 5 continue; 6 } 7 console.log(i,j); 8 } 9 } 控制外层循环：给外层循环加一个标签，将标签名写在continue后面，就可以控制了。 1 waiceng:for(var i = 1 ; i &lt; 4; i++){ 2 for(var j = 1 ; j &lt; 4 ; j++){ 3 if(j == 2){ 4 //这不是我要的，继续下一次循环 5 continue waiceng; 6 } 7 console.log(i,j); 8 } 9 } break和continue：能够优化我们的代码。判断一个数是不是质数，通过break简化。 1 var sum = 0; 2 for(var i = 2 ; i &lt;= Math.sqrt(n) ; i++){ 3 if(n % i == 0){ 4 //说明i是n的一个约数，n肯定不是质数 5 sum++; 6 // alert(n + &quot;不是质数&quot;); 7 break; 8 } 9 } 10 if(sum == 0){ 11 alert(n+&quot;是质数&quot;); 12 }else{ 13 alert(n + &quot;不是质数&quot;);14 } 简化：输出1~10000之间的质数 1 //输出2~10000之间的质数 2 //列出所有的情况，只要发现这个数不是质数的可能性，直接跳到下一次循环 3 waiceng:for(var i = 2 ; i &lt;= 10000 ; i++){ 4 //判断除了1和本身之外只要有质数，打断，跳入下一次循环 5 for(var j = 2 ; j &lt;= Math.sqrt(i) ; j++ ){ 6 if(i % j == 0){ 7 continue waiceng; 8 } 9 } 10 //能够进行到这一步，说明前面的continue没发生作用，j一直都不是i的约数 11 // 确定i就是一个质数 12 console.log(i); 13 }]]></content>
    </entry>

    
  
  
</search>
