<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[教你如何搭建github技术博客]]></title>
      <url>%2F2016%2F09%2F23%2Ftitle11%2F</url>
      <content type="text"><![CDATA[适合人群 喜欢写Blog的人 有一定的编程基础 爱折腾的人 熟练使用版本控制Git 了解使用Github 熟悉基本的MarkDown语法 环境准备 安装Git 下载 msysgit 并执行即可完成安装。 安装Node.js 在 Windows 环境下安装 Node.js 非常简单，仅须下载安装文件并执行即可完成安装。 安装hexo 利用 npm 命令即可安装。（在任意位置点击鼠标右键，选择Git bash） npm install -g hexo 问题 npm ERR! registry error parsing json 错误可能需要设置npm代理,执行命令 npm config set registry http://registry.cnpmjs.org hexo:command not found删除刚刚安装的npm目录，重新执行命令npm install -g hexo安装hexo 创建hexo文件夹 安装完成后，在你喜爱的文件夹下（如H:\hexo），执行以下指令(在H:\hexo内点击鼠标右键，选择Git bash)，Hexo 即会自动在目标文件夹建立网站所需要的所有文件。 hexo init 安装依赖包 npm install 本地查看 现在我们已经搭建起本地的hexo博客了，执行以下命令(在H:\hexo)，然后到浏览器输入localhost:4000看看。 hexo generate hexo server 好了，至此，本地博客已经搭建起来了，只是本地哦，别人看不到的。下面，我们要部署到Github。 问题 执行hexo server提示找不到该指令 解决办法： 在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下： npm install hexo -server --save 安装此server后再试，问题解决 github 创建博客注册账号 地址：https://github.com/ 输入账号、邮箱、密码,然后点击注册按钮. 创建页面仓库 这个仓库的名字需要和你的账号对应，格式: yourname.github.io输入基本信息，然后点击创建仓库. 注意命名规则：你的github账号.github.io，我这里被坑了，之前是jekell写的，现在换成hexo，所以我是另建创库了。 生成SSH密钥 ssh-keygen -t rsa -C “你的邮箱地址”，按3个回车，密码为空。 在C:\Users\Administrator.ssh下，得到两个文件id_rsa和id_rsa.pub。 在GitHub上添加SSH密钥 打开id_rsa.pub，复制全文。https://github.com/settings/ssh ，Add SSH key，粘贴进去。 hexo使用 目录结构 .├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json 全局配置 _config.yml # Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site #站点信息 title: #标题 subtitle: #副标题 description: #站点描述，给搜索引擎看的 author: #作者 email: #电子邮箱 language: zh-CN #语言 # URL #链接格式 url: #网址 root: / #根目录 permalink: :year/:month/:day/:title/ #文章的链接格式 tag_dir: tags #标签目录 archive_dir: archives #存档目录 category_dir: categories #分类目录 code_dir: downloads/code permalink_defaults: # Directory #目录 source_dir: source #源文件目录 public_dir: public #生成的网页文件目录 # Writing #写作 new_post_name: :title.md #新文章标题 default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿） titlecase: false #标题转换成大写 external_link: true #在新选项卡中打开连接 filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false highlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace: # Category &amp; Tag #分类和标签 default_category: uncategorized #默认分类 category_map: tag_map: # Archives 2: 开启分页 1: 禁用分页 0: 全部禁用 archive: 2 category: 2 tag: 2 # Server #本地服务器 port: 4000 #端口号 server_ip: localhost #IP 地址 logger: false logger_format: dev # Date / Time format #日期时间格式 date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/ time_format: H:mm:ss # Pagination #分页 per_page: 10 #每页文章数，设置成 0 禁用分页 pagination_dir: page # Disqus #Disqus评论，替换为多说 disqus_shortname: # Extensions #拓展插件 theme: landscape-plus #主题 exclude_generator: plugins: #插件，例如生成 RSS 和站点地图的 - hexo-generator-feed - hexo-generator-sitemap # Deployment #部署，将 lmintlcx 改成用户名 deploy: type: git repo: 刚刚github创库地址.git branch: master 注意 配置文件的冒号“:”后面有一个空格 repo: 刚刚github创库地址.git hexo命令行使用 常用命令： hexo help #查看帮助 hexo init #初始化一个目录 hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成网页，可以在 public 目录查看整个网站的文件 hexo server #本地预览，&apos;Ctrl+C&apos;关闭 hexo deploy #部署.deploy目录 hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹** 简写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 编辑文章 新建文章 hexo new &quot;标题&quot; 在 _posts 目录下会生成文件标题.md title: Hello World date: 2015-07-30 07:56:29 #发表日期，一般不改动 categories: hexo #文章文类 tags: [hexo,github] #文章标签，多于一项时用这种格式 --- 正文，使用Markdown语法书写 编辑完后保存，hexo server 预览 hexo部署 执行下列指令即可完成部署。 hexo generate hexo deploy 以下提示说明部署成功 [info] Deploy done: git 点击 Github 上项目的 Settings，GitHub Pages，提示Your site is published at http://****.com 图床 1.墙裂推荐七牛云储存,注册地址。 2.七牛云储存提供10G的免费空间,以及每月10G的流量.存放个人博客图片最好不过了 3.七牛云储存还有各种图形处理功能、缩略图、视频存放速度也给力（非打广告）。 具体使用见使用七牛作为github博客的图床 域名 将独立域名与GitHub Pages的空间绑定 方法一：在站点source目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如wuxiaolong.me方法二：在Repository的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，比如wuxiaolong.me DNS设置 用DNSpod，快，免费，稳定。注册DNSpod，添加域名，如下图设置。 其中A的两条记录指向的ip地址是github Pages的提供的ip如何知道你的github上项目的IP，如下： 去Godaddy修改DNS地址 更改godaddy的Nameservers为DNSpod的NameServers。 总结 之前用的jekell写的，手把手教你建github技术博客by jekyll，也是折腾了几天才做成自己满意的，昨天决定换成hexo，也是花了一天半时间，为了追求更好，必须折腾！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Less语法的使用简介]]></title>
      <url>%2F2016%2F07%2F27%2Ftitle32%2F</url>
      <content type="text"><![CDATA[1 概述PHP和HTML的关系就是LESS和CSS的关系。 PHP是超文本预处理器 &lt;h1&gt;好高兴啊，我买了一个iPhone&lt;?php echo 3+4; ?&gt;&lt;/h1&gt; 编译为： &lt;h1&gt;好高兴啊，我买了一个iPhone7&lt;/h1&gt; LESS也是CSS预处理器： @a : 100px; div{ width:@a; } 编译为： div{ width:100px; } 用的时候还是用CSS！浏览器不能直接渲染PHP、不能直接渲染Less，必须转为HTML、CSS之后才能渲染。但是写的时候PHP就是比HTML厉害，Less就是比CSS厉害。 2 浏览器编译试着写一个a.less文件： @a : 200px; div{ width:@a; } @a表示定义一个变量。 Less现在先解决编译的问题，然后再学习语法！ 编译有两种，浏览器编译是最简单的： &lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;a.less&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/less.js&quot;&gt;&lt;/script&gt; 此时这个js文件就会发出Ajax请求，去请求a.less文件，此时会把返回的文本，用正则表达式进行编译。编译好的内容，直接内嵌到当前HTML文件中。 3、服务器端编译使用nodejs编译less。 nodejs是一个js的运行环境，可以让js运行在服务器端。原来js运行在浏览器中，JS现在开始可以和PHP、ASP、JSP平起平坐！ 4 less编译工具的安装（手动编译）所以有很多人发明了一些工具，发布出去了，发布到了npm的世界中，nodejs package management，nodejs包管理器。安装完node之后，npm已经被自动安装了。我们可以使用npm命令，轻松的从互联网上下载各式各样的nodejs程序。 npm install命令表示通过连接互联网，从网上下载工具，我们下载的就是less工具。 npm install表示安装，-g表示安装到全局，每个人的全局地址都不一样，请通过 npm root -g来查看 装好less处理器之后，就能通过lessc命令来编译less文件了。 5 利用Grunt自动监控less文件自动编译 Grunt是一个自动化构建工具，依赖NodeJS，说白了就是NodeJS程序而已。要使用Grunt必须现在系统的全局安装grunt-cli程序，cli就是命令行界面的意思。 需要先安装grunt-cli程序，打开系统CMD，输入下面的命令（保证计算机已经联网）： npm install -g grunt-cli 不要忘记-g，必须装在全局。 此时，你的神秘全局文件夹中就有了，此时你就可以在CMD中输入grunt命令而不会报错了。 现在，我们要安装grunt，刚才安装的是grunt-cli，此时来到你的项目文件夹中，注意这句话，来到你的项目文件夹中。 cd 你的项目路径 然后在这个文件夹中安装grunt，不要加-g。 npm install grunt 此时你的项目文件夹中就会出node_modules文件夹： 接下来我们就要告诉Grunt你要做什么，所以我们建立一个Gruntfile.js的文件，告诉Grunt你的任务。注意这个文件的名字不能换！ 下面就是这个Gruntfile.js的代码清单： 配置任务，列出了三个任务：pkg、less、watch。pkg任务是必须写的；less任务就是编译less的任务，watch任务就是监控任务。 部分在罗列插件。grunt-contrib-less、grunt-contrib-watch。 部分是事务队列、清单。 module.exports = function (grunt) { //任务配置,所有插件的配置信息 grunt.initConfig({ pkg: grunt.file.readJSON(&apos;package.json&apos;), //less插件配置 less: { main: { expand: true, src: [&apos;less/*.less&apos;], //核心语句，编译less dest: &apos;desc&apos;, ext: &apos;.css&apos; }, dev: { options: { compress: true, yuicompress:false } } }, watch: { scripts: { files: [&apos;less/*.less&apos;], tasks: [&apos;less&apos;] } } }); //告诉grunt我们将使用插件 grunt.loadNpmTasks(&apos;grunt-contrib-less&apos;); grunt.loadNpmTasks(&apos;grunt-contrib-watch&apos;); //告诉grunt当我们在终端中输入grunt时需要做些什么(注意先后顺序) grunt.registerTask(&apos;default&apos;, [&apos;less&apos;,&apos;watch&apos;]); }; 在项目文件夹里面再次放入一个package.json的文件： { &quot;name&quot;: &quot;text&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;devDependencies&quot;: { &quot;grunt&quot;: &quot;~0.4.5&quot;, &quot;grunt-contrib-less&quot;: &quot;~0.10.0&quot; } } 插件还没有装呢！所以要在项目文件夹中， npm install grunt-contrib-less npm install grunt-contrib-watch 如果全部操作都正确的话，此时你可以在项目文件的CMD中，输入grunt一个单词，可以实时监控你的less文件夹中的less文件。实时编译到dest文件夹中。 6、Less语法http://less.bootcss.com/ 变量： @hong : rgb(252,0,0); div{ background: @hong; border-top: 1px solid @hong; box-shadow: 1px 1px 1px 1px @hong; } 选择器也可以用变量： @dahezideleiming : container; .@{dahezideleiming}{ width:100px; } 文件路径： @imagesURL : &quot;../images&quot;; background: url(&quot;@{imagesURL}/1.jpg no-repeat center center&quot;); 导入文件： @import &quot;01.less&quot;; @import &quot;02.less&quot;; 属性也能用变量： @property: color; .widget { @{property}: #0ee; background-@{property}: #999; } 混合： .xiao{ width: 200px; height: 200px; } .cu{ font-weight: 500; } .xian{ text-decoration: underline; } .zhongyao{ .cu(); .xian(); } 嵌套： nav{ width:100px; height:100px; ul{ float:left; } } 可以接受参数，类似一个函数： .yuanjiao(@dushu){ -webkit-border-radius: @dushu; -moz-border-radius: @dushu; -ms-border-radius: @dushu; -o-border-radius: @dushu; border-radius: @dushu; } when逻辑判断： .haha(@a) when (@a &gt; 100){ width:300px; height: 300px; } .haha(@a) when (@a &lt; 100){ width:200px; height: 200px; } div{ .haha(900); } 编译之后： div { width: 300px; height: 300px; } 循环语句： .zihao(@n) when (@n =&lt; 60) { .fs@{n}{ font-size:1px * @n; } .zihao(@n + 1); } .zihao(10);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax中的GET请求和POST请求]]></title>
      <url>%2F2015%2F12%2F09%2Ftitle41%2F</url>
      <content type="text"><![CDATA[1、GET请求GET请求参数在URL中，所以参数非常好携带。GET请求没有上行报文体，所以send里面是null。 xhr.open(&quot;get&quot;,&quot;check.php?username=考拉&amp;age=12&quot;,true); xhr.send(null); 研究两个事情：字符转码的问题、用JSON来转为query string。 我们观察一个事情，此时在地址栏中输入你好： 复制出来就是： http://127.0.0.1/test.txt?%E4%BD%A0%E5%A5%BD 也就是说中文汉字就是：%AA%AA%AA 其中AA是一个两位16进制数字。 这个叫做URI转码（Uniform Resource Identifier，统一资源标识符），URI和URL差不多，只不过URL强调的是地址，URI强调的是具体的写法。 因为网址只能是英语字符和数字，不能是中文、日语、韩语、阿拉伯文等等，所以URI就想了个办法，用16进制数字来表示非英语文字。 JavaScript内置了转码的函数，各个浏览器兼容很好： 从中文 → URI编码：encodeURIComponent(“我爱你”)URL编码 → 中文：decodeURIComponent(“%E4%BD%A0%E5%A5%BD”) 此时任何后台语言都不需要再次解码就能识别标准URI编码。所以你要知道这个东西不是密码，就是在传输过程中为了防止非英语文字变形，用的临时编码。 &lt;?php $ciyu = $_GET[&quot;ciyu&quot;]; echo $ciyu; ?&gt; 为了防止传输过程中变形，所以我们的Ajax程序要： xhr.open(&quot;get&quot;,&quot;check.php?yonghuming=&quot; + encodeURIComponent(yonghuming) + &quot;&amp;age=&quot; + encodeURIComponent(12)); 再来研究一个事情，能不能写一个函数，接受一个JSON，返回query string。比如传入： { &quot;yonghuming&quot; : &quot;小明&quot;, &quot;age&quot; : 12, &quot;sex&quot; : &quot;男&quot; } 返回 &quot;?yonghuming=%E5%B0%8F%E6%98%8E&amp;age=12&amp;sex=%E7%94%B7&quot; 函数很好写，利用数组的join方法，是个神器！一旦你遇见让你返回字符串，然后字符串之间有符号，开头、结尾没有符号，就要想到join方法。 function changeJSON2QueryString(JSON){ var temp = []; for(var k in JSON){ temp.push(k + &quot;=&quot; + encodeURIComponent(JSON[k])); } return temp.join(&quot;&amp;&quot;); } 所以现在我们Ajax的open语句可以这么玩儿： var querystring = changeJSON2QueryString({ &quot;yonghuming&quot; : &quot;小明&quot;, &quot;age&quot; : 12, &quot;sex&quot; : &quot;男&quot; }); xhr.open(&quot;get&quot;,&quot;check.php?&quot; + querystring , true); 2、POST请求POST请求是通过request报文体来传输，所谓open简单，send里面有内容。PHP程序需要我们加上一个Request Header中的Content-type为普通表单，才能在后台用$_POST[]识别。 任何一个post的表单的上行报文头里面，都有这样的K-V对儿： Content-Type:application/x-www-form-urlencoded 所以我们在Ajax中也要设置（今后遇见node.js就不用设置）： xhr.open(&quot;post&quot;,&quot;dopost.php&quot;,true); xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); xhr.send(&quot;yonghuming=%E5%B0%8F%E6%98%8E&amp;age=12&amp;sex=%E7%94%B7&quot;); 3、JSON的识别JSON是一个通用信息交换格式，比如PHP工程师，可以使用json_encode()函数把别名数组转为标准JSON： &lt;?php $arr = array( &quot;result&quot; =&gt; array( array(&quot;xingming&quot; =&gt; &quot;小明&quot; , &quot;nianling&quot; =&gt; 12 , &quot;xingbie&quot; =&gt;&quot;男&quot;), array(&quot;xingming&quot; =&gt; &quot;小红&quot; , &quot;nianling&quot; =&gt; 15 , &quot;xingbie&quot; =&gt;&quot;女&quot;), array(&quot;xingming&quot; =&gt; &quot;小刚&quot; , &quot;nianling&quot; =&gt; 13 , &quot;xingbie&quot; =&gt;&quot;男&quot;) ) ); echo json_encode($arr); ?&gt; JSON显示在页面上的时候，不方便我们看JSON的结构，此时推荐安装一个浏览器插件，叫做JSONView。 Chrome应用商店打不开，并且网上下载的都不适合现在的Chrome版本。所以我们可以安装QQ浏览器，它的内核也是Chrome内核，中国人没有自己的浏览器内核。在应用中心中，安装“JSONView”。 安装完插件之后，访问JSON页面： 4、JSON识别我们使用Ajax读取一个JSON的时候，此时明明是JSON，但是读进来是String。此时就要把String变为JSON。 $.get(&quot;04_JSON.php&quot;,function(data){ console.log(data); console.log(typeof data); }); 一共有三种方法。 方法1：使用内置构造函数JSON的方法 var dataobj = JSON.parse(data); console.log(dataobj); console.log(typeof dataobj); JSON是系统内置的构造函数，和Number、String、Array一样。它IE8才开始有，IE6、7不支持JSON内置构造函数。 它一共就有两个方法： JSON.parse() 字符串 → 对象 JSON.stringify() 对象 → 字符串 JSON.parse()函数里面的字符串必须是标准JSON，必须有双引号引用所有的key。 方法2：使用eval语句 eval语句可以把字符串变为语句，是JS中的一个特色。 var str = &quot;alert(1+2+3)&quot;; //字符串 eval(str); //字符串变为了语句 弹出6。 eval()一般都是当做奇淫技巧使用，注意任何文本框都需要用正则表达式阻止eval。比如让你输出一个用户名，你叫做eval(“setInterval(function(){alert(‘哈哈’);},1)”); 极其危险！ 我们可以利用eval语句来把JSON字符串变为对象的JSON，但是此时要注意：如果直接eval一个JSON字符串，会报错： 语法要求必须用圆括号括起来： 所以： var dataobj = eval(&quot;(&quot; + data + &quot;)&quot;); console.log(dataobj); console.log(typeof dataobj); 方法3：借助Function函数 var sum = new Function(&quot;a&quot;,&quot;b&quot;,&quot;return a + b&quot;); alert(sum(3,4)); Function你仔细琢磨，也可以把字符串变为语句啊！ var dataobj = (new Function(&quot;return &quot; + data))(); console.log(dataobj); console.log(typeof dataobj); 5、复杂JSON的JS处理现在拿一个JSON举例子： 请用Ajax读取它，在HTML页面上枚举所有点击数大于1000的文章标题。 &lt;script type=&quot;text/javascript&quot;&gt; $.get(&quot;system/baijiayanshi.txt&quot;,function(data){ //把字符串转为真正的JSON var dataobj = eval(&quot;(&quot; + data + &quot;)&quot;); //如鱼得水，“JSON回家了” var arr = dataobj.data.list; for(var i = 0 ; i &lt; arr.length ; i++){ if(arr[i].hotcount &gt; 1000){ $(&quot;&lt;p&gt;&quot; + arr[i].m_title + &quot;【点击数：&quot; + arr[i].hotcount + &quot;】&lt;/p&gt;&quot;).appendTo(&quot;#box&quot;); } } }); &lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[异步和回调函数]]></title>
      <url>%2F2015%2F12%2F06%2Ftitle21%2F</url>
      <content type="text"><![CDATA[1、异步异步（Asynchronous），是计算机多线程的异步处理。与同步处理相对，异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。 js如果没有特殊语句：都是单线程，必须等到前面语句执行完之后，才能执行下面的语句。 同步： 1 console.log(1); 2 console.log(2); 3 console.log(3); 4 console.log(4); 5 //for循环，必须跳出循环才能走后面的语句 6 for(var i = 0 ; i &lt;= 100000 ; i++){ 7 console.log(1); 8 } 9 //后面的语句必须等到前面执行完才嫩执行，否则，只能排队等待。 10 console.log(5); 同步：工作中，完成一个demo，拿给项目经理去看，你就在旁边站着等，经理看完之后，告诉你这个可以了，继续下一个工作。 异步：工作中，完成一个demo，拿给项目经理去看，在经理看的过程，你回工位做下一个demo，经理同时也在检查你的原demo，他做完了之后告诉你，你这个可以了，继续工作。 如果要做异步：必须有异步语句的参与，setInterval、setTimeout、Ajax、node.js。 1 //定时器做异步 2 console.log(1); 3 console.log(2); 4 console.log(3); 5 console.log(4); 6 setInterval(function(){ 7 console.log(1); 8 },30) 9 console.log(5); 2、回调函数回调函数：定时器走完，可以利用一个回调函数告诉我的程序，某一个线程走完了，可以做什么工作了。 1 var timer; 2 var sum = 0; 3 timer = setInterval(function(){ 4 sum++; 5 console.log(1); 6 if(sum == 100){ 7 //清除定时器 8 clearInterval(timer); 9 //可以告诉程序下一步做什么 10 //回调函数，告诉我们定时器结束之后要做的工作 11 end(); 12 } 13 },30); 14 function end(){ 15 alert(&quot;定时器走完了&quot;); 16 } 一般有一个固定的写法：将结束后的回调函数作为一个参数。每次执行可以传递函数参数。 1 function yundong(callback){ 2 var timer; 3 var sum = 0; 4 timer = setInterval(function(){ 5 sum++; 6 console.log(1); 7 if(sum == 100){ 8 //清除定时器 9 clearInterval(timer); 10 //可以告诉程序下一步做什么 11 //回调函数，告诉我们定时器结束之后要做的工作 12 callback(); //必须写函数的调用 13 } 14 },30); 15 } 某一段代码结束后，继续执行的下一个内容。 1 animate(box1,{&quot;left&quot;:400},1000,function(){ 2 //运动执行完，回调函数内执行的语句 3 box1.style.background = &quot;#0f0&quot;; 4 animate(box1,{&quot;top&quot;:400},800,function(){ 5 box1.style.background = &quot;#00f&quot;; 6 }); 7 });]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[call和apply]]></title>
      <url>%2F2015%2F11%2F01%2Ftitle22%2F</url>
      <content type="text"><![CDATA[call和apply了解普通函数内部有没有this关键，指向是谁。 1 var box = document.getElementById(&quot;box1&quot;); 2 animate(box,{&quot;left&quot;:300},1000,function(){ 3 console.log(this); 4 }); 5 function move(){ 6 console.log(this); 7 } 普通函数（事件函数除外）内部的this默认指向window对象。 call方法和apply方法能够帮我们制定函数内部this的指向。 1 fun.call(obj); 2 fun.apply(obj); obj就是内部this规定的指向元素。 1 //作用：第一个执行函数，第二个指定this。 2 move.call(box); 3 move.apply(box); 两种方法都能用。 区别：就是函数传参的方式不同。 1 fn.call(obj,参数1,参数2,参数3……); 2 fn.apply(obj,[参数1,参数2,参数3……]);3 1 // call方法直接传递 2 sum.call(box,1,2,3); 3 //apply必须将参数放在一个数组 4 sum.apply(box,[2,3,4]); 对封装的函数制定内部的回调函数的this。 1 move(box1); 2 function move(obj){ 3 animate(obj,{&quot;left&quot;:400},1000,function(){ 4 //运动执行完，回调函数内执行的语句 5 this.style.background = &quot;#0f0&quot;; 6 animate(this,{&quot;top&quot;:400},1000,function(){ 7 this.style.background = &quot;#00f&quot;; 8 //在调用运动函数 9 animate(this,{&quot;left&quot;:0},1000,function(){ 10 this.style.background = &quot;#0ff&quot;; 11 //在调用运动函数 12 animate(this,{&quot;top&quot;:100},1000,function(){ 13 this.style.background = &quot;#f00&quot;; 14 move(this); 15 }); 16 }); 17 }); 18 }); 19 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP状态码含义大全]]></title>
      <url>%2F2015%2F10%2F26%2Ftitle12%2F</url>
      <content type="text"><![CDATA[大家都知道404是木有找到东西，301是定义转向，但又有几个人知道206或者307呢？本文就给大家列出了各种HTTP状态码的含义，适合长期收藏。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动web百分比布局]]></title>
      <url>%2F2015%2F09%2F28%2Ftitle35%2F</url>
      <content type="text"><![CDATA[1 百分比布局手机web页面都没有版心，都是撑满的，这是因为： 手机本身就小，你再留白边，寸土寸金的地方都浪费了； APP一般都是撑满的，大家手机上网的时候，也希望撑满。 此时就会给制作带来难度，因为尺寸不能写px单位了，比如版心设置为360px，此时iPhone6plus的414视口会看见白色边： 2 百分比布局基础用百分比设置宽度、高度（绝大多数高度可以写为px）、padding、margin的布局方式，叫做流式布局，页面有弹性，所以也叫弹性布局。 &lt;body&gt; &lt;div&gt;&lt;/div&gt; → div是body的亲儿子，60%指的是窗口宽度的60% &lt;/body&gt; &lt;body&gt; &lt;div&gt; &lt;main&gt; → 60%指的是div的width的60%，无视div的padding。 &lt;p&gt;&lt;/p&gt; → 60%指的是main的width的60%，无视div的padding。 &lt;/main&gt; &lt;/div&gt; &lt;/body&gt; 看看padding，都参考父亲的width。注意，竖直方向上的padding也是看父亲的width，而不是height。 &lt;div&gt; &lt;main&gt;&lt;/main&gt; → padding-left:10%;指的是父亲的width的10%，而不是父亲的padding。 padding-top:10%;指的是父亲的width的10%，而不是父亲的height。 &lt;/div&gt; 再来看border，不能用百分比写。 border: 10% solid #000; 再来看margin，一律参考父亲width，不参考父亲的margin和height。 &lt;style type=&quot;text/css&quot;&gt; *{ margin: 0; padding: 0; } div{ width: 200px; height: 600px; border: 10% solid #000; } p{ margin: 10%; } &lt;/style&gt; 总结： 无论margin、padding、width、height，无论竖直方向还是水平方向，参考的都是父亲的width。 3 边框带来的麻烦因为边框不能用百分比来写，所以会带来麻烦： &lt;div&gt; &lt;p&gt;1&lt;/p&gt; → float: left;width:50%; border:1px solid red; &lt;p&gt;2&lt;/p&gt; → float: left;width:50%; border:1px solid red; &lt;/div&gt; p就不能浮动成功，因为总宽度已经是100%多了4个px。 此时边框不能写成百分比，所以就不好减！ div{ width: 80%; height: 200px; margin: 0 auto; background-color: #eee; } p{ float: left; width: 50%; → 这里不能轻松减去2px height: 200px; background: orange; border: 1px solid #000; } 谁说不能？！CSS3中增加了calc函数： div{ width: 80%; height: 200px; margin: 0 auto; background-color: #eee; } p{ float: left; width: calc(50% - 2px); → 谁说不能？！CSS3中增加了calc函数 height: 200px; background: orange; border: 1px solid #000; } 使用的时候一定要在运算符前后加上空格： calc(50%-2px); 应该是 calc(50% - 2px); 兼容性不好，至少安卓4.4还不是特别兼容。 4 CSS3新的盒模型我们之前的盒模型padding、border、margin都是外扩的， div{ width : 200px; height : 200px; padding:10px 20px 30px 40px; } 此时真实面积： 260 × 240 此时加上： div{ width : 200px; height : 200px; padding:10px 20px 30px 40px; box-sizing:border-box; } box表示“盒子”，sizing“尺寸”，“border-box”表示border这一圈的宽度、高度。 此时padding就是内减的，而不是外扩的了： 但是border还是在外面： div{ width : 200px; height : 200px; box-sizing:border-box; padding:10px 20px 30px 40px; border-top:10px solid red; border-left:20px solid red; border-right:30px solid red; border-bottom:40px solid red; margin: 10px; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas基本用法]]></title>
      <url>%2F2015%2F09%2F24%2Ftitle29%2F</url>
      <content type="text"><![CDATA[1、Canvas概述 Canvas和Flash的思路完全不一样，Flash是上屏幕之后还是对象，编程语言叫做Action Script也是ECMAScript范畴。Canvas上屏幕之后像素化了，再也不能得到这个对象了，所以要想让这个元素运动，必须擦除整个屏幕、重绘这个元素。Canvas更流畅，手机端也嗷嗷流畅。 canvas是一个双标签，里面的内容是不支持canvas浏览器显示的内容： &lt;canvas width=&quot;800&quot; height=&quot;600&quot;&gt;对不起，你的浏览器不支持画布，请升级浏览器！&lt;/canvas&gt; 宽度、高度写在标签里面，如果写在css中，就变形、扭曲了。 编程： &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 ctx.fillStyle = &quot;lightseagreen&quot;; ctx.fillRect(100,100,300,200); &lt;/script&gt; 坐标系： API： ctx.fillStyle = &quot;red&quot;; //设置填充颜色 ctx.fillRect(100,100,300,200); //绘制一个填充矩形 2、笔触填充笔触也叫作“描边”，Canvas中的任何形状都是由这两个部分组成的。 笔触在canvas中视为一个“Path”的实例，必须stroke之后才能上屏幕；填充用fill才能上屏幕。 制作一个笔触需要用到的API： ctx.beginPath(); //开始绘制路径 ctx.closePath(); //自动封闭路径 ctx.moveTo(100,200); //将画笔移动到某一个点 ctx.lineTo(200,200); //用画笔划线，此时的参数是终点位置，起点就是画笔此时的位置 ctx.stroke(); //划线 比如： //得到画布标签 var myCanvas = document.querySelector(“#myCanvas”); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(“2d”); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.moveTo(100,100); ctx.lineTo(300,300); ctx.lineTo(600,300); ctx.moveTo(600,400); ctx.lineTo(700,400); ctx.stroke(); 在划线之前可以设置线的宽度和颜色： ctx.lineWidth = &quot;10&quot;; ctx.strokeStyle = &quot;red&quot;; ctx.stroke(); 当ctx上已经有一些path之后，此时调用fill()将自动填充。 &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.moveTo(100,100); ctx.lineTo(300,300); ctx.lineTo(600,300); ctx.closePath(); ctx.lineWidth = &quot;10&quot;; ctx.strokeStyle = &quot;red&quot;; ctx.stroke(); ctx.fillStyle = &quot;lightseagreen&quot;; ctx.fill(); &lt;/script&gt; 绘制新的形状的时候，要重新beginPath() &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.moveTo(100,100); ctx.lineTo(300,300); ctx.lineTo(600,300); ctx.closePath(); ctx.lineWidth = &quot;10&quot;; ctx.strokeStyle = &quot;red&quot;; ctx.stroke(); ctx.fillStyle = &quot;lightseagreen&quot;; ctx.fill(); ctx.beginPath(); ctx.moveTo(600,100); ctx.lineTo(600,200); ctx.lineTo(750,200); ctx.lineTo(790,40); ctx.closePath(); ctx.fillStyle = &quot;orange&quot; ctx.fill(); ctx.stroke(); &lt;/script&gt; fillRect()是一个快捷方法，让你省略了beginPath、moveTo、lineTo。所以fillRect (100,100,300,200)等价于： ctx.move(100,100); ctx.lineTo(400,100); ctx.lineTo(400,300); ctx.lineTo(100,300); ctx.closePath(); ctx.fill(); 3、弧和圆形画弧线用arc方法，它属于Path。所以画弧之前要beginPath()一下。 &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.arc(200,200,100,0,1,true); //圆心坐标200,200。100是半径。0开始角度，1终止角度，true表示逆时针 ctx.stroke(); &lt;/script&gt; 坐标系，Canvas中的角度都是弧度制，1弧度等于57.3度： 完整的圆终止角度就是Mathi.PI * 2 ctx.arc(200,200,200,0,Math.PI*2,false); 画20个同心圆。 for(var i = 10 ; i &lt;= 400 ; i+=5){ ctx.beginPath(); ctx.arc(200,200,i,0,Math.PI * 2,true); ctx.strokeStyle = &quot;rgb(&quot; + i + &quot;,&quot; + i + &quot;,&quot; + i + &quot;)&quot;; ctx.stroke(); } https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors 4、文字fillText函数用来写字，参数是：文字内容、坐标位置 ctx.fillText(&quot;文字内容&quot;,100,100); 可以使用font属性来调整字号和字形： ctx.font = &quot;50px 微软雅黑&quot;; ctx.fillText(&quot;你好&quot;,100,100); 5、new Image()使用图片使用图片有一个固定的语法，必须new Image()然后设置src，监听load事件，使用ctx.drawImage()函数上画布。 var img = new Image(); img.src = &quot;images/0.jpg&quot;; img.onload = function(){ ctx.drawImage(img,100,100); } ctx.drawImage()里面的参数是图片对象、左上角的坐标。 ctx.drawImage()里面可以有四个数字参数，增加了宽度、高度的设置，此时图片会被扭曲： var img = new Image(); img.src = &quot;images/0.jpg&quot;; img.onload = function(){ ctx.drawImage(img,100,100,250,80); } 如果要使用切片，就是9个参数： var img = new Image(); img.src = &quot;images/0.jpg&quot;; img.onload = function(){ ctx.drawImage(img,168,150,126,141,100,100,300,300); } 红色部分描述的是切片的事儿： 蓝色部分是上屏幕之后的事儿： 公式： ctx.drawImage(img,切片x,切片y,切片w,切片h,上屏x,上屏y,上屏w,上屏h); 6、运动canvas中元素不能运动的，因为上屏幕之后就再也得不到它了，没有任何变量能够持有一个: var box = ctx.fillRect(100,100,200,200); 必须重绘一个新的矩形！利用视觉暂留，形成运动！ 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 →清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 →…… 清屏： ctx.clearRect(0,0,800,600); 实际上是清除一个矩形区域，我们一般清除整个画布。 面向对象制作运动，结构： function Circle(){ } Circle.prototype.render = function(){ } Circle.prototype.update = function(){ } var yuan = new Circle(); setInterval(function(){ ctx.clearRect(0,0,800,600); yuan.update(); yuan.render(); },20); 每一帧都要更新演员、渲染演员。只要这个东西是演员，它必须提供update、render方法。 面向接口编程，接口就是具有一定方法的类的集合。说白了，就比如说很多类都有render、update方法，此时Actor（演员）就是一个接口，Circle和Fang类都是这个接口的实现。“接口就是类的类”。 说白了：我们要制作Actor类，Actor类提供update、render方法，并且会把自己放入总数组中。所有演员类，都必须继承这个类，重写Actor和render方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端网页开发经验与心得]]></title>
      <url>%2F2015%2F09%2F19%2Ftitle3%2F</url>
      <content type="text"><![CDATA[智能手机发展确实很迅速，像今年，我的大部分工作就都在移动端网页上。 再往前些年，看到的手机版/移动版网页，限制于浏览器与手机性能，2g网络速度等 网页设计无非是蓝、黑、白，界面单调，并且要尽可能的设计简单。 现在情况就大不相同了，软件上webkit内核浏览器大行其道，硬件突飞猛进，网速来说，4g正炒得火热。 下面就和大家分享一下我的一些移动端网页设计经验与心得。 1、分辨率 这应该是移动端网页最关心的问题了，因为移动设备五花八门，各种分辨率都有。要想在这些设备上都能有良好的浏览体验，得花一番功夫。 使用viewport：这已经是移动端网页的必备了，它可以设定页面的宽度，是否允许缩放等等。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;/&gt; 一般设置width=device-width，就是设置为设备的屏幕宽度，当然也可以是具体数值 百分比与max(min)-width使用：移动端网页不仅分辨率不一，而且随时可以横竖屏切换，所以百分比宽度设定非常必要，再配合max(min)-width限制最大(小)宽度，能有效的适应各种分辨率，若为此还有特别需求，可看下一条，”使用Media Queries” 使用Media Queries，这也是响应式web设计的一部分 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style1.css&quot; media=&quot;screen and (min-width: 640px)&quot;&gt; 这里的意思就是在大于640px的屏幕宽度下，使用style1样式，也可以写在样式内部，如： @media screen and (min-width: 640px){ .d1{background:#ccc;} } 2、内容与缓存 虽才说到现在4g正炒得火热，但不可否认移动设备网络环境上的局限性，所以还是有必要对此做一些处理。 使用manifest缓存 &lt;html manifest=&quot;/mobile.manifest&quot;&gt; 在html上添加manifest，其中文件格式内容如： CACHE MANIFEST ##需要离线的内容 CACHE: Script/jquery.js Script/gameconfig.js Image/home.png Image/logo.png ##总是访问网络的内容 NETWORK: * ##访问A失败时访问B FALLBACK 浏览器将缓存chache内所有的内容，并且可以离线访问，只要文件发生任何改变都将会重新读取并刷新全部缓存，所以更改注释是个更新缓存的好方法这里要注意的是 添加了manifest的当前网页也会被缓存 所以推荐的方式是页面缓存，页面动态内容全部用ajax获取，所以在移动网站项目设计开始就要注意这个问题 页面中添加iframe 然后子页面引用manifest想达到缓存资源而不缓存当前页面内容，是无效的。 尽可能使用css样式来代替图片，由于移动端浏览器对css3的支持，使得以前很多图片可以用样式来代替]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[谈设计师配色技巧]]></title>
      <url>%2F2015%2F07%2F09%2Ftitle2%2F</url>
      <content type="text"><![CDATA[一、橙色 使用了高亮度橙色的站点通常都会给人一种晴朗新鲜的感觉，而通过将黄色、黄绿色等类似颜色与成色搭配使用，通常都能得到非常好的效果。同时，中等色调的橙色类似于泥土的颜色，所以也经常用来创造自然的氛围。 橙色是可以通过变换色调营造出不同氛围的典型颜色，它既能表现出青春的活力也能够实现沉稳老练的效果，所以橙色在网页配色中的使用范围是非常广泛的。 Color Point: 橙色通常会给人一种朝气活泼的感觉，它通常可以是原本抑郁的心情豁然开朗。 在东方文化中，橙色象征着爱情和幸福。充满活力的橙色会给人健康的感觉，且有人说橙色可以提高厌食症患者的食欲。有些国家的僧侣主要穿着橙色的僧侣服，他们解释说橙色代表着谦逊。 二、黄绿色 黄绿色时而能够表现出自然的感觉，时而能够表现出未来虚幻的感觉。 原本这两种印象之间有很大的差异，但黄绿色就像穿越时间隧道那样能够自由自在地表现出这两种截然不同的感觉。 在网页中，黄绿色通常与蓝色搭配使用。总的来说，黄绿色主要用于表现温暖亲切的感觉或高科技神秘虚幻的感觉。 Color Point: 黄绿色和草绿色都会让人联想起大自然。黄绿色同时含有黄色和绿色两种颜色的共同特点，也就是说，黄绿色既能表现出黄色的温暖，也能表现出绿色的清新。在社会上，儿童和年轻人比较喜欢黄绿色。 三、绿色 绿色也是在网页中使用最为广泛的颜色之一。 因为它本身具有一定的与健康相关的感觉，所以也经常用于与健康相关的站点。绿色还经常用于一些公司的公关站点或教育站点。 当搭配使用绿色和白色时，可以得到自然的感觉。 当搭配使用绿色与红色时，可以得到鲜明且丰富的感觉。 同时，一些色彩专家和医疗专家们提出绿色可以适当缓解眼部疲劳。 Color Point: 人们看到绿色的时候，第一反应就会想到大自然。很多人都说绿色是大自然的颜色，绿色也代表着大自然中的每一个可贵的生命。大自然给了我们新鲜的氧气，而绿色也能使我们的心情变得格外明朗。当需要揭开心中的抑郁时，当需要找回安详与宁静的感觉时，回归大自然是最好的方法。 四、黄色 黄色是在站点配色中使用最为广泛的颜色之一，因为黄色本身具有一种明朗愉快的效果，所以能够得到大部分人的认可。 黄色在从儿童站点直至门户型网站等几乎每一个角落中都找到了自己的发挥空间，通过结合紫色、蓝色等颜色可以得到温暖愉快的积极效果。 高彩度的黄色与黑色的结合可以得到清晰整洁的效果，这种配色实例在网页设计中经常可以见到。 采用同一色调的深褐色与黄色的搭配，可以表达一种成熟的城市时尚的感觉。 Color Point: 黄色是明亮的且可以给人甜蜜幸福感觉的颜色。 在很多艺术家的作品，黄色都用来表现喜庆的气氛和富饶的景色。同时黄色还可以起到强调突出的作用，这也是使用黄色作为路口指示灯的原因。黄色因为具有诸多以上的特点，所以在我们的日常生活中随处可见。 黄色是在站点配色中使用最为广泛的颜色之一，因为黄色本身具有一种明朗愉快的效果，所以能够得到大部分人的认可。 黄色在从儿童站点直至门户型网站等几乎每一个角落中都找到了自己的发挥空间，通过结合紫色、蓝色等颜色可以得到温暖愉快的积极效果。 高彩度的黄色与黑色的结合可以得到清晰整洁的效果，这种配色实例在网页设计中经常可以见到。采用同一色调的深褐色与黄色的搭配，可以表达一种成熟的城市时尚的感觉。Color Point: 黄色是明亮的且可以给人甜蜜幸福感觉的颜色。 在很多艺术家的作品，黄色都用来表现喜庆的气氛和富饶的景色。同时黄色还可以起到强调突出的作用，这也是使用黄色作为路口指示灯的原因。黄色因为具有诸多以上的特点，所以在我们的日常生活中随处可见。 五、青绿色 青绿色会给人带来凉爽清新的感觉，且青绿色既可以使人原本兴奋的心情冷静下来，也可以使人原本沉静的心情活跃起来。 使用青绿色的站点也是随处可见。 青绿色与黄色、成色等颜色搭配可以营造出可爱亲切的氛围。 青绿色与蓝色、白色等颜色搭配可以得到清新爽朗的效果。 Color Point: 青绿色可以说是草绿色的健康和蓝色的清新感觉的结合体，但在自然界中它并不多见，会给人较强的人工制作的感觉。这也使它在保留自然颜色原有特点的同时，有为其赋予了特殊的效果。 色彩和心理学家分析说，青绿色可以给一个心情低迷的人一种特殊的信心与活力。 六、蓝色 很多站点都在使用蓝色与青绿色的搭配效果。最具代表性的蓝色物体莫过于海水和蓝天 ，而这两种物体都会让人有一种清凉的感觉。 高彩度的蓝色会营造出一种整洁轻快的印象。 低彩度的蓝色会给人一种都市化的现代派印象。 蓝色与绿色、白色的搭配在我们的现实生活中也使随处可见的，它的应用范围几乎覆盖了整个地球。 主颜色选择明亮的蓝色，配以白色的背景和灰亮的辅助色，可以使站点干净而整洁，给人庄重、充实的印象。 蓝色、青绿色、白色的搭配可以使页面看起来非常干净清澈。 Color Point: 蓝色会使人自然地联想起大海和天空，所以也会使人产生一种爽朗、开阔、清凉的感觉。作为冷色的代表颜色，蓝色会给人很强烈的安稳感，同时蓝色还能够表现出和平、淡雅、洁净、可靠等多种感觉。 低彩度的蓝色主要用于营造安稳、可靠的氛围，而高彩度的蓝色可以营造出高贵的严肃的氛围。 七、蓝紫色 蓝紫色在色相环中位于蓝色和紫色之间，所以它也蕴含着紫色的一些神秘感。 低亮度的蓝紫色显得很有分量，而高亮度的蓝紫色显得非常高雅。在网页中，蓝紫色通常与蓝色一起搭配使用。 Color Point: 蓝紫色可以用来创造出都市化的成熟美，且蓝紫色可以使心情浮躁的人冷静下来。明亮的色调直至灰亮的蓝紫色有一种与众不同的神秘美感。 八、紫红色 清澈（Pale）色调的紫红色又称粉红色，粉红色主要用于包含少女在内的女性站点。因为从明亮（Bright）到苍白（Very Pale）色调的粉红色能够表现出可爱、乖巧的感觉，所以有人也会用作背景色或在页面中大范围地使用该颜色。 紫红色并不能随意在所有的站点中使用，但使用恰当的紫红色会给人留下深刻的印象。 白色、粉红色、天蓝色的颜色搭配，是最受少女欢迎的配色方案。 高彩度的紫色和粉红色之间的搭配通常都能得到较好的效果。 Color Point: 紫红色市非常女性化的颜色，它给人的感觉通常都是浪漫、柔和、华丽、高贵优雅，特别是粉红色可以说是女性化的代表颜色。高彩度的紫红色可以表现出超凡的华丽，而低彩度的粉红色可以表现出高雅的气质。 九、黑色和白色 黑色与白色表现出了两个极端的亮度，而这两种颜色的搭配使用通常可以表现出都市化的感觉。 只要能够合理地搭配使用黑色与白色，甚至可以做到比那些彩色的搭配更生动的效果。 黑色与白色的搭配通常用于现代派站点中，通过合理地添加一些彩色还可以得到突出彩色的效果。 Color Point: 白色有很强烈的感召力，它能够表现出如白雪般的纯洁与柔和。 黑色也有很强大的感染力，它能够表现出特有的高贵，且黑色还经常用于表现死亡和神秘。 因为黑色和白色的搭配有一种特殊的严肃感，所以还经常用于如结婚典礼等庄重的场合]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[arguments对象]]></title>
      <url>%2F2015%2F06%2F17%2Ftitle13%2F</url>
      <content type="text"><![CDATA[1、arguments对象在其他语言里，一个函数定义两次，每次有不同的形式参数，代表的就是两个不同的函数，叫做函数的重载（overloaded）。 1 function fun(a,b){ 2 console.log(1); 3 } 4 function fun(a,b,c){ 5 console.log(2); 6 } 以上在其他语言里，作为两个不同的函数执行，如果实际参数有2个，调用第一个函数，如果实际参数有三个，调用第二个函数。 JS语言没有函数重载的现象。一个标识符不能给两个函数，如果给了两个函数，第二个会覆盖前面的。不论参数是多少个，都会去执行最后一个函数内部的代码。 1 function fun(a,b){ 2 console.log(1); 3 } 4 function fun(a,b,c){ 5 console.log(2); 6 } 7 fun(1,2,3,4); JS的函数内部默认都有一个叫做arguments的类数组对象。在调用函数过程中，会传递参数，所有的实际参数不管有没有对应的形参都会存到arguments对面。 arguments对象内部存的是所有的实参，将实参以数组单独数据的形式存起来。 1 function fun(a,b){ 2 console.log(arguments); 3 } 4 fun(1,2,3,4,45,6,7); 1 function fun(a,b){ 2 // console.log(arguments); 3 arguments[5] = 10; 4 arguments.length = 10; 5 console.log(arguments.length); 6 var sum = 0; 7 for(var i = 0 ; i &lt; arguments.length ; i++){ 8 sum += arguments[i]; 9 } 10 console.log(sum); 11 } 12 fun(1,2,3,4,45,6,7); arguments并不能完全使用数组的所有方法。 1 var arr = arguments.slice(3,5); 2 console.log(arr); arguments常用于封装函数时，模拟函数重载现象。 一个函数有三个形式参数，用户传一个参数，直接给参数乘以2，传2个参数，求两个参数的和，如果穿3个参数，先比较前两个数的大小，大的数与第三个数求和。 1 function sum(a,b,c){ 2 //根据实际参数个数不同，走不同的分支 3 switch(arguments.length){ 4 case 1: 5 return a * 2; 6 break; 7 case 2: 8 return a + b; 9 break; 10 case 3: 11 return (a &gt; b ? a : b) + c; 12 break; 13 default: 14 throw new Error(&quot;参数个数必须是1到3个，请重新输入&quot;); 15 } 16 } 17 console.log(sum(1)); 18 console.log(sum(1,2)); 19 console.log(sum(1,2,3)); 20 console.log(sum(1,2,3,4)); 2、IIFEIIFE：immediately-invoked function expression。即时调用函数表达式。指的就是函数在声明、定义的同时，直接调用。 （）调用函数的操作符。不能直接用在关键字定义的函数后面。 1 function fun(){ 2 console.log(1); 3 }(); 可以用函数表达式直接调用。函数表达式中，将函数矮化成了表达式，表达式是可以参数数学运算。 1 var fun = function(){ 2 console.log(2); 3 }(); 可以通过将函数矮化成表达式的形式，直接进行调用。常用的其他方法：如果函数前面加一个数学运算符，就可以矮化成表达式。 1 2 +function fun(){ 3 console.log(1); 4 }(); 5 -function fun(){ 6 console.log(1); 7 }(); 8 !function fun(){ 9 console.log(1); 10 }(); 11 (function fun(){ //()是我们最常用 12 console.log(1); 13 })(); IIFE的函数不能再外面使用函数名调用，认为函数是未定义。 1 (function fun(){ 2 console.log(1); 3 })(); 4 fun(); IIFE将fun函数的作用域给关住，在外面调用找不到这个函数定义。最常见的IIFE的写法：内部的函数是一个匿名函数。 1 (function(){ 2 console.log(1); 3 })(); IIFE可以自身传递参数。 1 2 (function(a){ 3 a++; 4 console.log(a); 5 })(5); 6 (function(a){ 7 a++; 8 console.log(a); 9 })(5); 10 (function(a){ 11 a++; 12 console.log(a); 13 })(8); 在查找变量时，在IIFE内部查找，不会去全局。 1 var a = 5; 2 (function(a){ 3 a++; 4 console.log(a); 5 })(); 作用：用来解决一些闭包的问题。 3、通过数组观察闭包数组内部每一项都是一个函数。可以自动的通过遍历给数组添加项。 1 //在数组内添加十个函数 2 var arr = []; 3 for(var i = 0 ; i &lt; 10 ; i++){ 4 //闭包：记住自己的定义域环境、内部语句。 5 arr[i] = function(){ 6 console.log(i); 7 }; 8 } 9 console.log(arr[8]); 10 arr[0](); 11 arr[1](); 12 arr[2](); 13 arr[3](); 14 arr[4](); 15 arr[5](); 每个函数都记住了自己的定义域环境和内部语句，环境记住了一个i变量，最终执行时，i变量的值已经变成了10. 利用IIFE解决问题。 1 //在数组内添加十个函数 2 var arr = []; 3 for(var i = 0 ; i &lt; 10 ; i++){ 4 //闭包：记住自己的定义域环境、内部语句。 5 //IIFE可以关注函数的作用域 6 (function(a){ 7 //内部记住a的值是固定的了，就是这次循环传进来的i 8 arr[a] = function(){ 9 console.log(a); 10 } 11 })(i); 12 } 13 console.log(arr[8]); 14 arr[0](); 15 arr[1](); 16 arr[2](); 17 arr[3](); 18 arr[4](); 19 arr[5](); IIFE可以解决数组中闭包出现的问题。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery常用方法]]></title>
      <url>%2F2015%2F04%2F18%2Ftitle24%2F</url>
      <content type="text"><![CDATA[jQuery常用方法1、html()相当于我们原生js里面的innerHTML方法。给元素内部添加内容。 参数必须是字符串。 1 $(&quot;div&quot;).html(&quot;你好，这是一个div&quot;); 手动的给标签内部加其他标签。 1 $(&quot;div&quot;).html(&quot;&lt;p&gt;&lt;a href=\&quot;#\&quot;&gt;你好&lt;/a&gt;&lt;/p&gt;&quot;); 读取内容：只能读取第一个元素内的内容。 1 console.log($(&quot;div&quot;).html()); 2、addClass()和removeClass()增加类名：addClass 移除类名：removeClass 要添加或移除的类名作为参数传入小括号内。 1 $(&quot;.ad&quot;).click(function(){ 2 $(&quot;.box&quot;).addClass(&quot;demo&quot;); 3 }); 4 $(&quot;.re&quot;).click(function(){ 5 $(&quot;.box&quot;).removeClass(&quot;demo&quot;); 6 }); 操作过程中，不会影响元素原有的类名或其他类名。 3、attr()调用或更改html元素的属性和属性值。 1 //获取某一个属性值 2 // console.log($(&quot;.ad&quot;).attr(&quot;type&quot;)); 3 //添加属性，传两个参数，第一个属性名，第二个属性值 4 // $(&quot;.box&quot;).attr(&quot;id&quot;,&quot;demo&quot;); 修改属性值。 1 $(&quot;input&quot;).click(function(){ 2 $(&quot;img&quot;).attr(&quot;src&quot;,&quot;images/cat2.jpg&quot;); 3 }); 4、常用的事件jQuery的事件不需要写on。 单击事件：click()； 1 $(&quot;input&quot;).click(function(){ 2 $(&quot;img&quot;).attr(&quot;src&quot;,&quot;images/cat2.jpg&quot;); 3 }); 鼠标移上：mouseenter鼠标进入 1 //鼠标移上元素添加类名 2 $(&quot;.box&quot;).mouseenter(function(){ 3 $(&quot;.box&quot;).addClass(&apos;demo&apos;); 4 }); 鼠标移出：mouseleave鼠标离开方法 1 //鼠标移出元素移除类名 2 $(&quot;.box&quot;).mouseleave(function(){ 3 $(&quot;.box&quot;).removeClass(&apos;demo&apos;); 4 }); 还有一种on的写法：本身也是一个方法，有两个参数，第一个参数是事件类型，第二个参数是事件函数。 1 //on方法添加事件 2 $(&quot;input&quot;).on(&quot;click&quot;,function(){ 3 $(&quot;img&quot;).attr(&quot;src&quot;,&quot;images/cat2.jpg&quot;); 4 }); 5、css()作用：调用和更改css 样式。 css()方法可以传递两个参数：如果只传一个参数，调用属性计算后的样式，如果传递两个参数，就是修改这个样式。 1 语法：jQuery.css(属性名，属性值); 传递一个参数，表示调用属性值： 得到的值是一个字符串形式的数据，不能直接参与运算。 1 console.log($(&quot;.box&quot;).css(&quot;width&quot;)); 传递两个参数，表示赋值： 1 $(&quot;img&quot;).css(&quot;width&quot;,&quot;200px&quot;); 属性名既可以写驼峰也可以写css写法： 1 //既可以写驼峰也可以写css写法 2 // $(&quot;div&quot;).css(&quot;background-color&quot;,&quot;yellowgreen&quot;); 3 $(&quot;div&quot;).css(&quot;backgroundColor&quot;,&quot;skyblue&quot;); 属性值很灵活，可以直接写数字不带单位，还可以写带单位或不带单位的字符串。 1 $(&quot;div&quot;).css(&quot;width&quot;,200); 2 $(&quot;div&quot;).css(&quot;height&quot;,&quot;200px&quot;); 3 $(&quot;div&quot;).css(&quot;border-width&quot;,&quot;5&quot;); 数值甚至可以写成加等的形式： 1 $(&quot;div&quot;).click(function(){ 2 $(&quot;div&quot;).css(&quot;width&quot;,&quot;+=20px&quot;); 3 }); 如果我们设置多个属性，将多个属性写在JSON对象。 1 //同时设置多个属性 2 $(&quot;div&quot;).css({ 3 &quot;width&quot; : 200, 4 &quot;height&quot; : 200, 5 &quot;border-width&quot; : 5 6 }); 6、hide()和show()就是隐藏和显示某一个元素。 1 $(&quot;.hide&quot;).click(function(){ 2 $(&quot;img&quot;).hide(); 隐藏 3 }) 4 $(&quot;.show&quot;).click(function(){ 5 $(&quot;img&quot;).show(); 显示 6 }) 可以传递一个时间参数，控制隐藏和显示的中间时间。 1 $(&quot;.hide&quot;).click(function(){ 2 $(&quot;img&quot;).hide(1000); 3 }) 4 $(&quot;.show&quot;).click(function(){ 5 $(&quot;img&quot;).show(1000); 6 }) 隐藏：伴随着透明度从设置透明度到0的变化，还有宽高从设置值到0的动画。 方法可以在显示和隐藏之间进行切换：toggle()； 1 $(&quot;.toggle&quot;).click(function(){ 2 $(&quot;img&quot;).toggle(1000); 3 }); 7、slideDown和slideUpslideDown()：滑动显示（方向不一定）； slideUp()：滑动隐藏； 本身就有运动过程。默认运动时间400毫秒。 1 $(&quot;.up&quot;).click(function(){ 2 $(&quot;img&quot;).slideUp(); 3 }); 4 $(&quot;.down&quot;).click(function(){ 5 $(&quot;img&quot;).slideDown(); 6 }); 隐藏的前提：必须是display:block; 显示的前提：必须是display:none; 中间有自己定义的动画：内部的结构，说明我们以什么方式隐藏和显示。 切换：slideToggle()。可以自定义运动时间： 1 $(&quot;.up&quot;).click(function(){ 2 $(&quot;img&quot;).slideUp(1000); 3 }); 4 $(&quot;.down&quot;).click(function(){ 5 $(&quot;img&quot;).slideDown(1000); 6 }); 7 $(&quot;.toggle&quot;).click(function(){ 8 $(&quot;img&quot;).slideToggle(1000); 9 }); 8、fadeIn和fadeOut表示淡入和淡出：透明度发生的变化。 fadeIn：透明度变大，显示元素，淡入。 fadeOut：透明度变到0，隐藏元素，淡出。 默认运动时间是400毫秒，可以自定义时间。 1 $(&quot;.out&quot;).click(function(){ 2 $(&quot;img&quot;).fadeOut(1000); 3 }); 4 $(&quot;.in&quot;).click(function(){ 5 $(&quot;img&quot;).fadeIn(1000); 6 }); 7 $(&quot;.toggle&quot;).click(function(){ 8 $(&quot;img&quot;).fadeToggle(1000); 9 }); 淡入淡出到某一个透明度：fadeTo（）。有两个参数，第一个叫做速度参数。第二个透明度的终点。 1 $(&quot;.to&quot;).click(function(){ 2 $(&quot;img&quot;).fadeTo(&quot;slow&quot;,0.5); 3 }); 1 $(&quot;.out&quot;).click(function(){ 2 $(&quot;img:first&quot;).fadeOut(3000); 3 $(&quot;img:last&quot;).fadeIn(3000); 4 });]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[8种方法加快你的网站访问速度]]></title>
      <url>%2F2015%2F03%2F12%2Ftitle4%2F</url>
      <content type="text"><![CDATA[一、 网站程序中采用DIV+CSS这种模式，不用Table 目前DIV+CSS是主流的编程语言，这与其体积小加载快的优点是密不可分的。主流的网站和CMS采用的也都是这种模式。因此建议大家也采用这种模式来编程，而不要采用原始的Table结构。Table结构不但管理不方便，网页体积也会变大，降低网站的加载速度。 二、 采用Gzip技术对网页进行压缩 采用Gzip技术对网页进行压缩是减少网页体积的一个很好的方式.一般情况下这是需要你的网站空间支持的，像我用的A5的合租主机，压缩率可以达到80%。网页体积小了，自然加载速度就快了。 三、 减少CSS文件数量和体积 在采用DIV+CSS过程中，CSS文件是非常重要的。如果在编写过程中有多个CSS文件，建议将多个CSS文件进行合并，这样可以加快网站加载速度。另外，可以采用专业的网页减肥软件对CSS文件进行减肥，以减少CSS文件的体积。 四、使用CDN加速。 近一年CDN已经在我们个人站长中听的较多，也有很多朋友在使用。CDN的全称是Content Delivery Network，解释为内容分发网络。原理思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。也就是网站加速器，这个需要付费使用的，免费的不是太稳定。 五、优化代码，减少臃肿结构。 如果我们使用较为流行的CMS这方便应该不会有臃肿的代码结构存在，但需要注意的是我们在制作或者选择网站模 板的时候也会存在不合理的结构。我们需要在写模板或者程序的时候使用较为简洁的程序框架，简洁有利于用户体验，也更利于搜索引擎蜘蛛的爬行和抓取。 六、减少图片大小和数量。 我们尽量在上传网站图片的时候减少图片的大小和尺寸，可以在上传图片之前对图片进行压缩处理，图片适当尺码即可，不要过大。图片仅仅是网站的点缀，而不需要都是图文。同时，我们也尽量避免使用大量的视频或者音频内容。 七、减少JavaScript脚本文件，尽量存放在一个文件中。 尽量外部调用JS代码，不要放在网页中，更不要远程调用外部的JS代码。例 如Google建议您加载在HEAD标签的分析。您也可以尝试结合的JavaScript和压缩他们更快地加载。有些时候我们在头部的CSS，JS代码太 多，导致中间内容部分加载太慢。所以尽量减少头部的代码。 八、运用静态的HTML页面 众所周知，ASP、PHP、JSP等顺序完成了网页信息的静态交互，运转起来确实十分方便，由于它们的数据交互性好，能很方便地存取、更改数据库的内容，但是这类顺序也有本人的缺陷，那就是它必需由效劳器先生成HTML页面，然后在“传送”给用户，多了一个步骤，必定会影响到网站的拜访速度，所以笔者建议，在新站开端的时分，在对本人网站的重要调查期内还是采用静态的HTML页面比拟保险。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSONP跨域详解]]></title>
      <url>%2F2015%2F03%2F12%2Ftitle42%2F</url>
      <content type="text"><![CDATA[1、Ajax因为安全限制不允许跨域Ajax不能跨域，指的是如果你的HTML页面在127.0.0.1上，此时将不能访问127.0.0.2上的文件。如果你的文件在www.iqianduan.cn上，也不能访问www.163.com上的文件。有些浏览器甚至不允许你访问news.58gsl.cn。这是浏览器的安全限制，不允许你随随便便的访问其他服务器上的JSON。 2、JSONP跨域JSONP就是JSON with Padding ( JSON和 赘语），指的就是把函数的执行放到外部文件，HTML用script标签引用这个js文件，实际上引用的是对一个函数的执行。此时函数定义在HTML文件里面，数据就通过实参、形参的结合就进入了HTML数据。 &lt;script type=&quot;text/javascript&quot;&gt; function fun(data){ alert(data.xingming); } &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;haha.txt&quot;&gt;&lt;/script&gt; → 这个文件执行了fun函数 haha.txt文件里面： fun({&quot;xingming&quot;:&quot;小明&quot;,&quot;nianling&quot;:12,&quot;xingbie&quot;:&quot;男&quot;}); 红色部分是执行一个函数，就是所谓的“P”。 京东数据的请求： &lt;script type=&quot;text/javascript&quot;&gt; function yuanye(data){ for(var i = 0 ; i &lt; data.comments.length ; i++){ alert(data.comments[i].content); } } &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://sclub.jd.com/comment/productPageComments.action?productId=4048938&amp;score=0&amp;sortType=3&amp;page=1&amp;pageSize=10&amp;callback=yuanye&quot;&gt;&lt;/script&gt; JSONP的缺点： 1） 太不安全，什么时候章泽天和刘强东吵架，刘强东很生气，把JSONP接口换成了 for(var i = 0 ; i &lt; 1000000 ; i++){ alert(&quot;你好&quot;); } 此时你又在用script引用它，此时你的用户也被连带遭殃了。 所以JSONP的提供者，一定要可靠！ 2） 没有明显的异步的特点。页面虽然不会假死，但是没有提供回调函数。不过也没关系，页面不假死是重点。 3） 很难控制请求的发出。比如我想点击一个按钮，然后发出请求。不过也很快被解决了，我们可以动态的创建一个script标签，设置了src，一旦上树，上行请求将发出，此时函数将执行！ &lt;script type=&quot;text/javascript&quot;&gt; var btn = document.getElementById(&quot;btn&quot;); //准备一个函数，一会儿外部文件将执行这个函数 function fun(data){ alert(data.xingming); } //事件监听 btn.onclick = function(){ var oscript = document.createElement(&quot;script&quot;); oscript.src = &quot;haha.txt&quot;; document.head.appendChild(oscript); document.head.removeChild(oscript); } &lt;/script&gt; 甚至我们可以封装一个函数，就不用显式的创建fun函数了，可以把用户传输进来的函数，当做fun函数： &lt;script type=&quot;text/javascript&quot;&gt; var btn = document.getElementById(&quot;btn&quot;); function qingqiu(URL,callback){ //你第二个传入的参数就是哈哈函数 window.fun= callback; var oscript = document.createElement(&quot;script&quot;); oscript.src = URL; document.head.appendChild(oscript); document.head.removeChild(oscript); } qingqiu(&quot;haha.txt&quot;,function(data){ alert(data.nianling); }); &lt;/script&gt; jQuery中使用JSONP和使用正经Ajax一样一样的，你完全看不出来，只是些许有些语法不一样。 3、JSONP的jQuery使用首先： $.get(URL,function(data){ }); $.post(URL,function(data){ }); jQuery中最全活的API是： $.ajax(); 比如： $.ajax({ &quot;url&quot; : &quot;php/job.php&quot;, &quot;data&quot; : { &quot;page&quot; : 2 }, &quot;type&quot; : &quot;get&quot;, &quot;success&quot; : function(data){ alert(data); } }); 等价于： $.get(&quot;php/job.php?page=2&quot;,function(data){ alert(data); }) 此时jQuery实现JSONP跨域： &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.12.3.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $.ajax({ //请求的地址，下面是一个域外的地址 &quot;url&quot; : &quot;http://127.0.0.2/haha.txt&quot;, //请求类型是jsonp类型，注意是dataType属性而不是type属性 &quot;dataType&quot; : &quot;jsonp&quot;, //定义我们传进来的success函数叫什么名字 &quot;jsonpCallback&quot; : &quot;fun&quot;, //定义一个函数，这个函数马上会成为window.fun &quot;success&quot; : function(data){ alert(data.xingming); alert(data.nianling); alert(data.xingbie); } }); &lt;/script&gt; 特别的，如果后台哥哥给你写了callback GET请求参数，可以任意设置调用的函数名字，此时jQuery中可以用？代替这个部分，jQuery会自动帮你填入随机乱码： $.ajax({ &quot;url&quot; : &quot;https://sclub.jd.com/comment/productPageComments.action?productId=4048938&amp;score=0&amp;sortType=3&amp;page=1&amp;pageSize=10&amp;callback=?&quot;, &quot;dataType&quot; : &quot;jsonp&quot;, &quot;success&quot; : function(data){ alert(data.comments.length); } }); 此时jQuery就会把请求发往： https://sclub.jd.com/comment/productPageComments.action?productId=4048938&amp;score=0&amp;sortType=3&amp;page=1&amp;pageSize=10&amp;callback=jQuery112306426957034965071_1480068166765 工作中这种模式最最常用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见字符串算法]]></title>
      <url>%2F2015%2F01%2F14%2Ftitle28%2F</url>
      <content type="text"><![CDATA[常见字符串算法1、短横变驼峰把单词border-left-color变为borderLeftColor。 此时有两种方法： 方法1：border-left-color用字符串的split方法变为数组：[“border”,”left”,”color”]，然后遍历这个数组第1项开始的每项，把首字母toUpperCase()变为大写然后与剩余字母连接，然后join到一起，就是borderLeftColor。 // 短横变驼峰函数 function change(str){ //拆为数组 var strArr = str.split(&quot;-&quot;); //遍历数组 for(var i = 1 ; i &lt; strArr.length ; i++){ var chars = strArr[i]; //将数组的这一项的字符串变为首字母变为大写，与剩余字母做拼接 strArr[i] = chars[0].toUpperCase() + chars.slice(1); } //拼接 return strArr.join(&quot;&quot;); } 方法2：正则表达式。border-left-color用正则表达式去replace替换，替换什么？替换所有(-字母)变为大写字母。 var str = &quot;我爱周杰伦，周杰伦很帅，我要和周杰伦生猴子&quot;; str = str.replace(/周杰伦/g,&quot;杨洋&quot;); console.log(str); var str = &quot;我买了一个手机3000元，电脑5000元，电饭锅100元。今天很热，18度。&quot;; str = str.replace(/(\d+)元/g,function(match,$1,index){ return parseInt($1 / 6) + &quot;美元&quot;; }); console.log(str); var str = &quot;border-left-color&quot;; str = str.replace(/\-(\w)/g,function(match,$1){ return $1.toUpperCase(); }); console.log(str); 2 、寻找连续三项相同字符串现在给你一个字符串，判断里面有没有连续三位或者三位以上相同，如果有，就返回下标数组。 比如： “aabbbccddddee” 返回[2,3,4,7,8,9,10]。 双指针法。在字符串的题目中，基本99%都能用双指针法，比如最大连续相同子串、最大连续重复子串等等，都能用双指针法。 &lt;script type=&quot;text/javascript&quot;&gt; var str = &quot;aabbbccddddee&quot;; //位置是0、1 var i = 0; var j = 1; //结果 var result = []; while(i &lt; str.length){ if(str[i] != str[j]){ //判断是不是到了3位 if(j - i &gt;= 3){ //为位号推入数组 for(var m = i; m &lt;= j-1 ; m++){ result.push(m); } } //i追上j，j后移一位 i = j; } //不管怎么样j都要后移 j++; } console.log(result); &lt;/script&gt; 3 给数字加上千分位符输入12345678901，返回”12,345,678,901”。 数组和字符串的相互转换方法很好用，要敏感一些！实际上就是[12,345,678,901]进行join(“,”)就是结果。所以问题就简化为把12345678901这个数字拆分为数组！数组长度11。 找找规律： 12345678901 str.slice(-3) → 很特殊，没有第二个参数 12345678901 str.slice(-6,-3) 12345678901 str.slice(-9,-6) 12345678901 str.slice(-12,-9) 程序： &lt;script type=&quot;text/javascript&quot;&gt; var num = 12433245245432; //除了null、undefined之外的任何字面量都有toString()方法，表示变为字符串 var length = num.toString().length; //循环终点 var end = -Math.ceil(length / 3) * 3; //结果数组，把特殊的末尾三位放入数组 var result = [num.toString().slice(-3)]; //遍历-6、-9、-12、-15…… //截取的是slice(-6,-3) slice(-9,-6) slice(-12,-9) for(var i = -6 ; i &gt;= end ; i-=3){ result.unshift(num.toString().slice(i,i+3)); } //把数组变为字符串 console.log(result.join(&quot;,&quot;)); &lt;/script&gt; 还可以用正则表达式，我们慢慢推导： \B是一个特殊的正则的东西，表示字母边界，非单词边界。\b表示单词边界。 &lt;script type=&quot;text/javascript&quot;&gt; var str = &quot;abc,adsf haha xixi&quot;; str = str.replace(/\B/g,&quot;★&quot;); console.log(str); &lt;/script&gt; 出现★的地方就是字母边界 然后说正则中的(?=)语法，表示定语从句，位置描述。 比如，我们想替换字符串中所有后面是“你”字的“爱”字. var str = &quot;我爱你，你却爱着他&quot;; str = str.replace(/爱(?=你)/g,&quot;★&quot;); console.log(str); 替换字符串中所有后面有“3位数字”的字母\B ： var str = &quot;12324324324&quot;; str = str.replace(/\B(?=\d{3})/g,&quot;★&quot;); console.log(str); 比较乱，因为我们没有限制边界 替换字符串中所有后面到单词结尾有“3位数字”的\B ： var str = &quot;12324324324&quot;; str = str.replace(/\B(?=\d{3}$)/g,&quot;★&quot;); console.log(str); 替换字符串中所有后面到单词结尾有一个或多个“3位数字”的\B ： var str = &quot;12324324324&quot;; str = str.replace(/\B(?=(\d{3})+$)/g,&quot;★&quot;); console.log(str); 这就是答案，只需要把★改为逗号即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON对象使用方法]]></title>
      <url>%2F2015%2F01%2F12%2Ftitle19%2F</url>
      <content type="text"><![CDATA[概述 数组：存储的是一组数据，可以操作每一项内容，有自己的局限性，通过具体下标才能获得某一项。 数据多的时候，数组的使用效率变低。 JSON对象可以解决这个问题。也可以存多个数据，每个数据都有自己的名字。可以通过数据的名字得到数据的值。 JSON叫做JavaScript Object Notation， JavaScript对象表示法。 JSON对象创建的最简单的方式，就是字面量，一对大括号{}。 语法：{}内部包括多个数据，每个数据之间用逗号隔开，最后一个数据后不能写逗号。每一项数据都包含属性名和属性值，属性名必须用引号包括，属性值根据数据类型单独设置，键值对写法”k”:v。 1 语法：{“k”: v, “k”: v} 创建一个最简单的JSON对象。 1 var json = { 2 &quot;name&quot; : &quot;kaola&quot;, 3 &quot;age&quot; : 18, 4 &quot;sex&quot; : &quot;男&quot;, 5 &quot;tall&quot; : 100, 6 &quot;weight&quot; : 178 7 }; 8 console.log(typeof json); 数据类型：对象型。引用类型数据，变量存的是地址。 调用每一项数据的方法：JSON对象点语法调用属性名即可，或者用[属性名]。 1 //调用 2 console.log(json.name); 3 console.log(json.age); 4 console.log(json.sex); 5 console.log(json.tall); 6 console.log(json[&quot;weight&quot;]); JSON对象内部还能嵌套JSON对象。 1 var json = { 2 &quot;name&quot; : &quot;kaola&quot;, 3 &quot;age&quot; : 18, 4 &quot;sex&quot; : &quot;男&quot;, 5 &quot;tall&quot; : 100, 6 &quot;weight&quot; : 178, 7 &quot;couple&quot; : { 8 &quot;name&quot; : &quot;daishu&quot;, 9 &quot;age&quot; : 17, 10 &quot;sex&quot; : &quot;女&quot;, 11 &quot;tall&quot; : 160, 12 &quot;weight&quot; : 90 13 } 14 }; 如果想调用内部JSON的属性，继续打点调用即可。 1 console.log(json.couple.tall); 修改某一个属性：给调用的属性名去直接赋值。 1 json.tall = 170; 2 console.log(json); 删除：用到一个delete关键字，后面必须加空格，书写他的属性。 1 //删除 2 delete json.couple; 3 console.log(json); 添加：直接给JSON对象打点添加属性，属性值同时赋值。 1 //添加 2 json.hobby = &quot;台球&quot;; 3 console.log(json); 2、JSON的遍历for……in语法：通过属性名去遍历所有属性，从前到后依次去遍历，直到最后一个数据被遍历完。循环结束。 1 for(var k in json){ 2 语句3 } k：表示属性名 json：你要遍历的那个JSON对象。输出每一个属性值： 1 //输出每一个属性值，需要遍历JSON对象 2 for(var k in json){ 3 console.log(json[k]); 4 } 复制一个JSON对象： 属性名都一样，属性值也一样。 过程：新的JSON对象接收复制来的数据。给新对象添加新属性，新属性等于原对象属性，再给新属性赋值，值等于原对象属性的值。 1 var newJson = {}; //必须是空的JSON对象 2 for(var k in json){ 3 //定义新属性并赋值 4 newJson[k] = json[k]; //红色是添加属性，绿色是调用原JSON的属性值 5 } 6 //循环完之后得到一个新的JSON 7 console.log(newJson);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[函数声明提升]]></title>
      <url>%2F2015%2F01%2F11%2Ftitle9%2F</url>
      <content type="text"><![CDATA[1、函数声明提升变量可以先使用后定义。js的解析器在运行的时候，会将所有的全局变量提升到最开始的位置，如果使用的时候可以找到这个变量定义。变量声明提升只提升定义，不提升赋值。初始值默认是undefined。 1 var a; 2 console.log(a); 3 a = 12; 函数声明提升：函数可以先调用，后定义。解析器在程序最开始，将全局范围内定义的函数声明提升到代码最前面，声明的时候提升的就是那个变量名指针，总能够根据函数名找到这个函数的圆型。 1 //先调用 2 fun(); 3 //后定义 4 function fun(){ 5 console.log(1); 6 } 函数声明头提升是强制性的：无视if语句以及for循环。 函数的另外一种定义方式：函数表达式的定义，不会进行函数声明提升，它进行的是变量的声明提升。变量声明提升只提升定义 ，不提升函数赋值，里面存的undefined，给调用函数方法，出现引用类型错误。 1 fun1(); 2 var fun1 = function(){ 3 console.log(2); 4 } 对比：同一个变量名给函数和变量，看顺序。变量写在后面，覆盖掉前面的函数名。 1 function fun(){ 2 console.log(1); 3 } 4 var fun = function(){ 5 console.log(2); 6 } 7 fun(); 函数声明优先于变量声明：同一个标识符，给变量和函数，在定义提升的时候，会将这个标识符优先给函数使用。 1 //先调用 2 3 fun(); 4 //后定义 5 function fun(){ 6 console.log(1); 7 } 8 var fun = function(){ 9 console.log(2); 10 } 11 fun(); 特殊情况解释：函数在定义的时候，进行强制性的声明提升，定义过程已经被提升到代码最前面了，后面再遇到定义的代码，直接忽视。后面定义的变量会遮盖掉这个定义。 1 var fun = function(){ 2 console.log(2); 3 } 4 function fun(){ 5 console.log(1); 6 } 7 fun(); 注意：尽量不要用同一个标识符给变量和函数，定义函数时不要使用函数表达式的方式，用函数关键字的方式。 2、作用域2.1 概述 在函数内定义的变量不能从函数之外的任何地方取得，变量仅仅在该函数的内部有定义。因为我们的函数关住了变量的作用域（定义域）。 JS的作用域：没有块级作用域{}，唯一关住作用域的结构就是函数。在函数内部定义的变量就是函数内部的局部变量，只能在函数内部调用，在外部调用会出现错误。 1 //函数关住作用域，内部定义的是局部变量 2 function fun(){ 3 var a = 1; 4 console.log(a); 5 } 6 fun(); 7 console.log(a); 全局变量：从广义上讲，是一个最外层的局部变量，作用域是全局，所以叫做全局变量。可以在全局范围内都访问到这个变量。 1 var b = 2; 2 function fun(){ 3 var a = 1; 4 console.log(a); 5 console.log(b); 6 } 7 fun(); 原理：全局变量语句没有任何限制，只要遇到就会生成一个变量，在任何地方是能找到。局部变量是声明在函数内部的，函数定义时，内部语句并没有执行，没有定义成这个变量，在函数执行的瞬间，立即定义了一个局部变量，执行完之后，这个变量被立即销毁，从外部找不到这个变量的定义，不能调用。 2.2作用域链 函数内部在调用一个变量的时候，查找的路径问题：当遇见一个变量时，JS引擎会从其所在的作用域依次向外层查找，查找会在找到第一个匹配的标识符的时候停止。在多层嵌套的作用域中可以定义同名的标识符，发生“遮蔽效应”。 1 var a = 1; 2 function outer(){ 3 var a = 2; 4 function inner(){ 5 //var a = 3; 6 console.log(a); 7 } 8 inner(); 9 } 10 outer(); 如果函数内部定义变量时，没有写var关键字，认为我们自动在全局进行了变量的声明，我们创建的不在是局部变量，而是全局变量。会造成一个全局污染。 1 var a = 1; 2 function outer(){ 3 a = 2; 4 function inner(){ 5 //var a = 3; 6 console.log(a); 7 } 8 inner(); 9 } 10 outer(); 11 console.log(a); 在全局定义变量，忘了写var关键字，只要有赋值，变量会自动在全局进行声明。 1 b = 3; 2 console.log(b); 建议：任何时候定义变量都要写var关键字，避免全局污染。 2.3 函数的参数 函数的参数是一个局部变量。在函数内部可以正常使用。在函数外部不能访问函数参数这个变量。 1 function fun(a,b){ 2 a = 1; 3 b = 4; 4 console.log(a + b); 5 } 6 fun(); 7 console.log(a); 实际工作中如果能封装函数，用到的变量，尽量定义在函数内部，不会影响其他的函数或者全局变量。 2.4 全局变量 全局变量尽量少定义，但是它有自己独特的作用：传递、累加。 程序：有两个函数，执行函数加，给我们的一个变量加1，如果执行函数减，让我们的这个变量减1.两个函数控制同一个变量。 传递：在不同的函数之间进行通信，函数都能使用，必须使用全局变量。 1 //全局变量，可以让任何函数使用，通信 2 var a = 1; 3 function plus(){ 4 a++; 5 return a; 6 } 7 function minus(){ 8 a--; 9 return a; 10 } 11 console.log(plus()); 12 console.log(plus()); 13 console.log(plus()); 14 console.log(plus()); 15 console.log(minus()); 16 console.log(minus()); 17 console.log(minus()); 如果一个函数需要累加一个变量的值，多次执行，值依次累加的。不能使用局部变量，因为每次初始值都会被重置。 累加：全局变量会将变化的值存起来，以备下次使用。 1 //全局变量。，累加功能 2 var a = 1; 3 function sum(){ 4 a++; 5 return a; 6 } 7 console.log(sum()); 8 console.log(sum()); 9 console.log(sum()); 10 console.log(sum()); 2.5 函数的作用域 函数也有作用域，就是它定义的那个环境，如果定义在另一个函数内，它也只能在这个函数内部调用，在函数外面调用时引用错误。 1 function sum(a){ 2 return ++a; 3 } 4 //函数定义在另一个函数内部，在外面是访问不到 5 function outer(){ 6 var a = 1; 7 function inner(){ 8 console.log(sum(a)); 9 } 10 inner(); 11 } 12 outer(); 13 inner(); 3、闭包观察闭包的经典案例： 1 //函数定义在另一个函数内部，在外面是访问不到 2 function outer(){ 3 var a = 1; 4 function inner(){ //只能在定义域内使用 5 console.log(a); 6 } 7 return inner; //返回值得到一个inner函数的定义 8 } 9 // 将函数执行结果赋值给一个变量 10 var fun = outer();//其实将inner函数赋值给了fun 11 //函数如果执行，需要在定义域范围去找变量a。全局没有，正常输出了一个1 12 //执行fun函数，其实是执行指向的那个函数原型，它会在自己定义的作用域内执行 13 // inner定义时作用域内有一个a = 1，inner函数记住了这个定义域 14 // 哪怕在outer函数外面使用inner的时候，我也可以访问到a的定义 15 // console.log(typeof fun); 16 // console.log(fun); 17 fun(); 每个函数天生就是一个闭包。函数在定义时，会记住自己的作用域环境以及内部的语句，将外部环境和内部语句组成了一个密闭的环境，就是闭包。 闭包不需要特殊的结构，只是会通过特殊结构来观察函数的这一性质。案例观察： 1 function outer(x){ 2 function inner(y){ //如果执行函数outer，才会定义inner 3 console.log(x + y); 4 } 5 return inner; //一定不要加小括号，如果加了，就立即执行 6 } 7 var i = outer(3); //inner函数定义的位置，环境x = 3 8 // x = 3; 9 // i = function inner(y){ 10 // console.log(x + y); 11 // } 12 console.log(i); 13 i(5); 1 function fun1(m,n){ 2 function fun2(m){ 3 console.log(m + n); 4 } 5 return fun2; 6 } 7 var f = fun1(3,4);//fun2定义的位置 8 f(6); 函数这个闭包里的变量并不是一成不变，可以通过函数调用发生一些变化。 1 function outer(){ 2 var i = 9; 3 function inner(){ 4 return i++; 5 } 6 return inner; 7 } 8 var inn = outer(); //新建了一个函数，函数是inner，赋值给了变量inn 9 console.log(inn()); 10 console.log(inn()); 11 console.log(inn()); 函数定义一次，可以进行多次调用。我们可以认为，每次重新定义，都会产生新的闭包。新的闭包指的是，语句全新，所处环境也是全新的。 1 function outer(){ 2 var i = 9; 3 function inner(){ 4 return i++; 5 } 6 return inner; 7 } 8 var inn = outer(); //新建了一个函数，函数是inner，赋值给了变量inn 9 var inn2 = outer(); //新建了一个函数，函数是inner，赋值给了变量inn2 10 console.log(inn()); 11 console.log(inn()); 12 console.log(inn()); 13 console.log(inn2()); //新的函数，闭包是全新的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[【精】web前端工程师必备技能汇总]]></title>
      <url>%2F2014%2F12%2F19%2Ftitle1%2F</url>
      <content type="text"><![CDATA[项目起源 web前端知识结构图。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Cookie和Session]]></title>
      <url>%2F2014%2F12%2F13%2Ftitle44%2F</url>
      <content type="text"><![CDATA[1、Cookie就是一个Response头部的一个K-V对儿。 当服务器下发了一个Set-Cookie，今后每次request浏览器都会带着相同的cookie上去。 HTTP是无连接的，当你第一次访问一个服务器的时候，第二次再来到这个服务器（可能就10s之后），服务器此时的HTTP和第一次毫无关系的。对于服务器来说，HTTP是两次，两次之间没有持久保持连续。 setcookie函数就是设置cookie的，有三个参数：k、v、过期时间 &lt;?php setcookie(&quot;xingming&quot;,&quot;kaola&quot;,time()+3600); ?&gt; 第一次访问页面的时候，我们关心的是Response Headers： 里面有一个Set-Cookie，值为 xingming=kaola; expires=Fri, 27-Jan-2017 12:38:36 GMT 表示Cookie的值，和过期时间。 今后的每一次访问同一个域名下的任何网站，都可以看见Request Header中携带了相同的Cookie： 有什么用！可以方便让： ① 浏览器记录服务器曾经给我们的信息； ② 服务器记录用户提供的信息 在本地，我们可以轻松使用document.cookie来使用cookie。 此时你会得到一个String，任何的cookie会被链接成为一个String： console.log(document.cookie); 转码： var c = decodeURIComponent(document.cookie); 此时仍然是字符串 变为数组，用;来拆分： var arr = c.split(&quot;;&quot;); 遍历这个数组，继续用=来拆分为数组： var result = {}; for(var i = 0 ; i &lt; arr.length ; i++){ var t_arr = arr[i].split(&quot;=&quot;); console.log(t_arr); } 变为对象： for(var i = 0 ; i &lt; arr.length ; i++){ var t_arr = arr[i].split(&quot;=&quot;); result[trim(t_arr[0])] = t_arr[1]; } console.log(result); 他的值不是object，所以eval： var infoobj = eval(&quot;(&quot; + result[&quot;iqianduan.cn&quot;] + &quot;)&quot;); 自动填入表单 //如果xingming和nianling不是空，则默认填入文本框 if(infoobj.xingming){ document.getElementById(&quot;xingmingTxt&quot;).value = infoobj.xingming; } if(infoobj.nianling){ document.getElementById(&quot;nianlingTxt&quot;).value = infoobj.nianling; } 总结一下： **&gt; cookie的产生仰赖服务器的一次Set-Cookie。今后每一次的访问，我们的request头部都会携带cookie这个东西。 其实如果不借助服务器，我们浏览器自己能不能发送带有cookie的头部呢，能！就是xhr.setRequestHeader()，不过这个东西没有意义！** Cookie的性质 ① Cookie不安全，可以在任何时候被浏览器的network面板被查看。所以千万不要试图让服务器下发密码等机密信息。可以被自由修改！ ② Cookie是文件格式存储。 ③ 有超时的限制，可以自由设置存活时间。 2、Session有cookie，让服务器发起Set-Cookie: username=且试天下Always;login=true; 此时我们的浏览器今后访问每一个这个网站的页面都会带着cookie上去。服务器识别cookie，一看就知道你登录了！ 但是，cookie可以被自由篡改！也就是说，我想登陆谁的号，就登录了谁的号！ 有人发明了一个机制，不要通过cookie下发明文信息，发送一个随机乱码下去！服务器同时在内存中保存这个随机数字的人的各种信息。如果有人带这个随机乱码上来，一定是这个人！ 此时我们把这种特别的cookie叫做SESSION，也叫作会话。也就是说，session就是cookie！是一种特殊的cookie，是不发送明文，而是发送随机乱码的cookie。 服务器下发： &lt;?php //开始session session_start(); $_SESSION[&quot;xingming&quot;] = &quot;小丹尼&quot;; ?&gt; 今后我的每一次访问，都会带着这个码上去。这个吗对于浏览器来说，没有任何意义！但是服务器就是通过这个码来知道你是你的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM操作方法]]></title>
      <url>%2F2014%2F12%2F01%2Ftitle14%2F</url>
      <content type="text"><![CDATA[1、DOM体验DOM（Document Object Model，文档对象模型）描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。这使得JavaScript操作HTML，不是在操作字符串，而是在操作节点，极大地降低了编程难度。编写例子整体感知一下这个事儿。 1 //获得元素 2 var oDiv = document.getElementById(&quot;box&quot;); 3 var oKaola = document.getElementById(&quot;kaola&quot;); 4 //添加点击事件，盒子变色，图片变图 5 oDiv.onclick = function(){ 6 oDiv.style.backgroundColor = &quot;yellowgreen&quot;; 7 oKaola.src = &quot;images/kaola2.jpeg&quot;; 8 } DOM规范在1998年10月制定，称为“DOM1级规范”。随着ECMAScript的升级，DOM也发展出了2级规范、3级规范。另外，早于1998年的DOM也有事实上的标准，我们称为0级规范。 DOM对很多东西做了抽象，提供了丰富的API：取得元素、css样式、事件、运动、元素尺寸位置、节点操作。每个知识体系都非常庞大，千丝万缕。我们今天的课程，把一些线头都掐出来，日后的课程深入研究每个线头。 2、获取元素JavaScript通过document对象表示文档，它表示整个页面。它有很多属性和方法，包含了绝大多数多页面的特征和操作。学习DOM，说白了就是学习document对象。例如document.title属性，就是页面的标题。 1 document.title = &quot;获取元素&quot;; 2 alert(document.title); DOM操作，往往都是从取得某个（些）HTML元素开始，然后对这个（些）元素进行一些操作。所以得到元素是非常重要的。得到元素的操作可以使用document对象的两个方法来完成： document.getElementById() document.getElementsByTagName() getElementById：get得到 element 元素 by 通过 id id属性值。通过id名字获得某一个元素。 驼峰命名法：一个标识符由多个英文单词组成，首个单词正常小写，从第二个开始每个单词首字符要大写，其他的小写。 JS的书写位置：如果要想获得某一个元素，那么获得之前，元素必须是加载过的。js的书写顺序，需要写在标签后面。 1 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; //标签写在获取元素的前面 2 &lt;script&gt; 3 // document.title = &quot;获取元素&quot;; 4 // alert(document.title); 5 6 //获取div元素 7 var box = document.getElementById(&quot;box&quot;); 8 box.onclick = function(){ 9 box.style.border = &quot;10px solid #0f0&quot;; 10 } 11 &lt;/script&gt; 获取元素语法：直接将获得的这个元素的id属性值写在参数里。名字必须加引号。跟css区别，不需要加#。 错误写法： 1 var box = document.getElementById(&quot;#box&quot;); 正确写法： 1 var box = document.getElementById(&quot;box&quot;); 获得的元素的数据类型。通过检测，得到一个对象类型。 1 console.log(typeof box); 也就是说，我们通过id获得元素本身又是一个对象类型的数据，内部还包含了一些属性和方法。可以对这些元素打点继续调用属性和方法。 注意：id名不能重复。 1 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; 2 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; 3 //id名字不能重复，如果有重复的，只得到第一个 4 var oBox = document.getElementById(&quot;box&quot;); 5 oBox.style.backgroundColor = &quot;#0f0&quot;; id大小写要严格区分，但是在IE6、7中，大小写是不区分的。 IE7及较低版本还有一个怪癖，表单元素name特性也会被当做id。为了避免这个问题，所以页面上的name最好也不要和任何id相同。 3、操作html获取一个html标签之后，得到一个对象类型变量。 可以控制html的属性：得到属性、更改属性。 有两种选择：getAttribute()和setAttribute()方法，或者使用点语法。 点语法： 获得元素属性：直接在元素对象后点语法调用，输出属性值。 1 //获得img标签的src属性 2 console.log(oImg.src); 3 console.log(oImg.id); 4 console.log(oImg.alt); 更改html标签属性：可以通过点语法调用相关属性后，通过等号给这个属性赋值，更改属性值的方法。 1 //通过点语法得到相关属性，等号赋新值 2 oImg.src = &quot;images/kaola2.jpeg&quot;; 3 //不要去更改id属性，id是只读。 第二种方法： 得到属性值getAttribute()，需要得到什么属性，直接将名字写在小括号内。 1 console.log(oImg.getAttribute(&quot;src&quot;)); //得到的就是属性值的字符串 2 console.log(oImg.getAttribute(&quot;alt&quot;)); //得到的就是属性值的字符串 设置属性值setAttribute()，设置属性的新的属性值，直接写在小括号内，用引号包裹。 1 oImg.setAttribute(&quot;src&quot;,&quot;images/kaola.jpg&quot;); 第一个参数：设置属性名，第二个参数：新的属性值，中间用逗号隔开。 区别： ①html标签可以使用自定义属性，自定义属性调用和更改都不能使用点语法实现。getAttribute（）可以获得自定义属性，setAttribute（）可以更改自定义属性。 1 //自定义属性 2 oImg.setAttribute(&quot;kaola&quot;,&quot;yuanxing&quot;); 3 console.log(oImg.kaola); 4 console.log(oImg.getAttribute(&quot;kaola&quot;)); ②点语法调用html属性时，有一些属性名需要进行更改，这些属性名可能是其他的关键字，规避这些名字。getAttribute方法不用规避，直接写原属性名。 class 改为className for 改为htmlFor rowspan 改为rowSpan colspan 改为colSpan 1 //更改一些属性名的写法，只限于点语法 2 console.log(oImg.class); 3 console.log(oImg.className); getAttribute方法不需要改变写法，如果改了反而错。 1 console.log(oImg.getAttribute(&quot;className&quot;)); 2 console.log(oImg.getAttribute(&quot;class&quot;)); ③如果调用style属性得到的还是一个css对象，可以继续打点调用css的样式，遇到复合属性的单一写法，点语法需要些驼峰命名，另外一种方法不需要。 text- font- line- background- border- margin- padding- 1 //console.log(oImg.style.border-color); 2 console.log(oImg.style.borderColor); getAttribute方法直接写css内的命名就行。 ④点语法得到的style属性是一个对象，可以继续打点调用内部的属性。getAttribute方法得到style属性，是一个字符串，不能再继续打点调用。 1 //console.log(oImg.style.border-color); 2 console.log(typeof oImg.style); 3 console.log(typeof oImg.getAttribute(&quot;style&quot;)); 点语法才能继续打点调用css样式属性。 总结：除了自定义属性用getAttribute和setAttribute之外，其他情况都用点语法。 4、操作css通过对一个元素对象打点调用style属性，得到的是css样式的一个对象。可以通过得到css样式的对象，进行css属性的读取和更改。 通过点语法读取和更改的css样式都是行内样式。 1 &lt;img src=&quot;images/kaola.jpg&quot; alt=&quot;这是一只考拉&quot; style=&quot;border:2px solid #f00;&quot; class=&quot;tupian&quot; id=&quot;image&quot; kaola=&quot;bianxing&quot; /&gt; 2 //点语法得到样式都是行内样式，更改的也是行内样式 3 console.log(oImg.style.width); 4 console.log(oImg.style.border); 通过点语法改的css样式属性都是在行内式进行更改的。 1 //更改样式 2 oImg.style.height = &quot;400px&quot;; 语法注意：点语法直接调用。如果给属性赋新值，通过等号赋值，右侧的值必须写在一对儿引号里，css里面怎么写属性值，引号里直接就这么些。 1 oImg.style.height = &quot;400px&quot;; 2 oImg.style.borderColor = &quot;#00f&quot;; innerHTML表示标签内的文本。 input标签有自己的获得方法，点语法直接调用value属性。 1 console.log(oBox.innerHTML); 2 console.log(oTxt.value); 5、事件 DOM0级事件： onclick 单击事件 ondblclick 双击事件 onmouseover 鼠标移上事件 onmouseout 鼠标移出事件 onmousedown 鼠标按下事件 onmouseup 鼠标弹起事件 onfocus 获得焦点事件 onblur 失去焦点事件 onload 加载事件 事件监听：给一个元素去添加事件，如果触发事件就会执行相应的功能。JS在加载的时候，先去整个页面去查看，看谁绑定了事件，引擎就会给这个元素进行监控（监听），监控我们的元素有没有被触发这个事件的动作，如果触发动作，在瞬间执行相应的功能。 语法：给哪个元素绑定事件，就给这个元素对象打点添加对应的事件，用等号给这个事件添加事件函数。 2 box.onmouseover = function(){ 3 事件触发之后要做的事。 4 }; 如果事件被触发，立即执行后面的事件函数，不需要加()调用函数。 6 //获取元素 7 var oImg = document.getElementById(&quot;image&quot;); 8 // 绑定鼠标移上的效果，变图片 9 oImg.onmouseover = function(){ 10 oImg.src = &quot;images/kaola2.jpeg&quot;; 11 }; 调用函数方法：用小括号调用，触发事件执行事件函数。 onclick：单击事件,鼠标单击事件元素触发事件。 5 //鼠标单击事件 6 oImg.onclick = function(){ 7 oImg.style.width = &quot;300px&quot;; 8 }; 4 //鼠标双击事件 5 oImg.ondblclick = function(){ 6 oImg.style.width = &quot;300px&quot;; 7 }; 3 //绑定鼠标移上的效果，变图片 4 oImg.onmouseover = function(){ 5 oImg.src = &quot;images/kaola2.jpeg&quot;; 6 }; 7 //鼠标移出效果，一般与鼠标移上成对出现 8 oImg.onmouseout = function(){ 9 oImg.src = &quot;images/kaola.jpg&quot;; 10 }; 2 //获取元素 3 var oBox = document.getElementById(&quot;box&quot;); 4 //添加鼠标移上和移出事件 5 oBox.onmouseover = function(){ 6 oBox.style.backgroundImage = &quot;url(images/jd2.png)&quot;; 7 }; 8 oBox.onmouseout = function(){ 9 oBox.style.backgroundImage = &quot;url(images/jd1.png)&quot;; 10 }; 5 //添加鼠标按下和弹起事件 6 oBtn.onmousedown = function(){ 7 oBtn.style.backgroundColor = &quot;pink&quot;; 8 }; 9 oBtn.onmouseup = function(){ 10 oBtn.style.backgroundColor = &quot;skyblue&quot;; 11 }; 点击： 松开： 4 //获得焦点事件，输入框清空 5 oTxt.onfocus = function(){ 6 oTxt.value = &quot;&quot;; 7 }; 8 oTxt.onblur = function(){ 9 oImg.src = &quot;images/kaola2.jpeg&quot;; 10 }; onload事件：表示元素加载完之后执行某一个事件函数。 3 //onload加载，图片加载完之后，弹出一句话，加载完了 4 oImg.onload = function(){ 5 alert(&quot;加载完毕&quot;); 6 }; 页面整体加载事件： window.onload:表示页面的所有html标签、css样式都加载完。JS就可以随意书写加载位置。 3 // 只有页面全部加载完了才会触发window.onload 4 window.onload = function(){ 5 //获取元素 6 var oImg = document.getElementById(&quot;image&quot;); 7 var oTxt = document.getElementById(&quot;txt&quot;); 8 //绑定鼠标移上的效果，变图片 9 oImg.onmouseover = function(){ 10 oImg.src = &quot;images/kaola2.jpeg&quot;; 11 }; 12 //鼠标移出效果，一般与鼠标移上成对出现 13 oImg.onmouseout = function(){ 14 oImg.src = &quot;images/kaola.jpg&quot;; 15 }; 16 }； window浏览器对象，alert就是window对象里面的一个方法。window可以省略。 window.alert(&quot;yes&quot;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2014年中国IE6浏览器状况]]></title>
      <url>%2F2014%2F11%2F20%2Ftitle25%2F</url>
      <content type="text"><![CDATA[IE6在4月9日停止更新了，与数日前XP退役引起的唏嘘与争论不同，IE6走得很悄然。我想，这是因为在许多人的电脑里，它早已被搁置了多年，取代它的有Chrome、Opera、Safari、搜狗和360等诸多后辈，老大哥寿终正寝，是历史的必然。 可是，IE6真的被完全取代了吗，抱着谨慎的态度，我查询了一些资料： 根据NetApplications的数据显示，就在IE6停止更新的4月9日，它在全球的市场占有率是4.4%。对于一款在美国本土的市场占有率只有0.2%的浏览器来说，退休或许是唯一的归宿。但是，令人惊奇的是，IE6在中国的市场占有率竟然是22.2%，这意味着，在其4.4%的全球市场份额中，仅中国大陆就占据了3.4%的份额。 再来看看CNZZ的数据，数据显示在中国4月8日PC端浏览器的使用率中，IE以39.05%遥遥领先，其中IE6贡献了其中的10.19%。 一句话总结：IE6没死，至少在中国，它活得好好的。 一个在全世界范围内行将就木的产品，唯独在中国生机勃勃。这不禁让我们产生一个问题：是什么人还在使用IE6? 一个主要的数据源，我认为是中国大量的网吧。中国文化部于2012年发布的《2012年中国网吧市场年度报告》显示，2012年中国的网吧关闭了一万家左右，值得注意的是，这是2004年以来，网吧数量的首次下滑。网吧的电脑多数配置不高，因此占用内存较小的XP系统目前仍旧是主流的网吧系统，其自带的IE6浏览器尽管漏洞颇多，但网吧用户的安全威胁远不止这一个。虱子多了，就不痒了。 另一个主要的数据源，我认为是中国大量的中老年网民。普遍中老年网民对互联网的依赖性非常低，对互联网功能的熟练程度远远不如年轻人，在使用和需求上也有很大区别。在一项调查中显示78%的中老年人上网只是浏览资讯，互联网强大的力量并没有传递到他们的周围。 因此，IE6在中国“看上去很美”的境况，事实上也是一种虚假的繁荣。知乎上曾经有这样一段问答，戏谑间解释了很多事情： 多年前，有这样一份关于使用浏览器与IQ高低的调查，当年的结论是，IE浏览器用户的IQ全线偏低，2011年IE6用户的平均智商只有83，IE9的用户也不过90而已。Opera以128的平均智商遥遥领先。 一个慵懒庞大的体系占据着40%的市场份额，这是严重违背互联网精神的事情。今日得到UC浏览器要发布桌面浏览器的消息，其目的是想将PC端和移动端打通;360几日前开始从百度的hao123导航抢用户，也说明PC端浏览器的用户争夺还在持续着。在中国市场，十多款浏览器竞争着IE家族之外的60%的市场份额，战斗已经持续多年，空间已经颇为狭小。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[if语句]]></title>
      <url>%2F2014%2F11%2F10%2Ftitle5%2F</url>
      <content type="text"><![CDATA[1、if语句if是如果的意思。else，否则。 1 语法： 2 if(condition){ 3 statement1 //结构体，多行代码，写在一对大括号内部 4 }else{ 5 statement2 6 } 结构体要执行就都执行，要不执行，就都不执行。 condition：条件表达式，强制给我们转成布尔值。 含义：如果条件condition为真，执行第一个结构体。如果为假，执行第二个结构体。 1 if(条件){ 2 条件为真，执行的结构体； 3 }else{ 4 条件为假，执行的结构体； } if语句可以没有else，条件成立执行结构体，不成立直接退出程序 1 if(a &lt; 60){ 2 alert(&quot;抱歉没及格，努力吧&quot;);3 } 如果执行的结构体只有单行语句，可以省略大括号 1 if(a &gt;= 60) 2 alert(&quot;恭喜，及格了&quot;); 3 else 4 alert(&quot;很遗憾，没及格，继续努力&quot;); 也能写在if语句的同一行，仅限单行结构体。 1 if(a &gt;= 60) alert(&quot;恭喜，及格了&quot;); 2 else alert(&quot;很遗憾，没及格，继续努力&quot;); 这两种写法不会报错，但是为了避免出一些不必要的问题，尽量写大括号。大括号后面不需要写分号，不会出错。 if语句殊途同归，不管执行哪个程序，退出后都继续执行后面的语句 1 if(a &gt;= 60){ 2 alert(&quot;恭喜，及格了&quot;); 3 }else{ 4 alert(&quot;很遗憾，没及格，继续努力&quot;); 5 } 6 alert(&quot;好好准备下一次考试&quot;); 2、多条件分支语句条件并不是只有一个，每一个条件对应一个结构体。 if……else if …… else if…… else if…… else …… 如果……否则如果……否则如果……否则…… 1 if(条件1){ 2 满足条件1执行的结构体 3 }else if(条件2){ 4 条件1不满足，满足条件2时执行的结构体 5 }else if(条件3){ 6 条件1/2都不满足，满足条件3时执行的结构体 7 }else if(条件4){ 8 条件1/2/3都不满足，满足条件4时执行的结构体 9 }else{ 10 以上条件都不满足，执行的结构体11 } 跳楼现象：程序会选择一个分支执行（跳楼），如果执行了这个分支，表示前面分支的条件都没有满足。 案例：详细划分成绩评价，优秀，良好，及格，不及格。 1 if(a &gt;= 90){ 2 alert(&quot;优秀&quot;); 3 }else if(a &gt;= 70){ //如果走到这一步，隐含了a&lt;90 4 alert(&quot;良好&quot;); //执行完之后，直接跳楼，不会执行后面的条件分之 5 }else if(a &gt;= 60){ 6 alert(&quot;及格&quot;); //如果走到这一步，隐含了a&lt;70 7 }else{ 8 alert(&quot;不及格&quot;);9 } 大坑 1 var b = 1; 2 if(b &lt;= 3){ //只会选择这个条件内部的结构体，执行后直接跳楼 3 b += 4; 4 }else if(b == 5){ 5 b += 3 6 }else if(b == 8 ){ 7 b += 4 8 }else{ 9 b += 10; 10 } 11 console.log(b); 3、if语句嵌套制作一个结构的时候，有两个限制条件，可以使用if语句的嵌套。 if语句可以嵌套if语句使用，最终执行符合条件成立的结构体 1 if(sex == &quot;男&quot; &amp;&amp; age &gt;= 22){ 2 alert(&quot;可以领证了&quot;); 3 }else if(sex == &quot;女&quot; &amp;&amp; age &gt;= 20){ 4 alert(&quot;可以领证了&quot;); 5 }else{ 6 alert(&quot;你还小，等等吧&quot;); 7 } 以上程序也可以达到效果：结构划分不清晰，条件比较复杂。 1 //if语句嵌套方法，每一层if语句只判断一个条件，内部再去进行另一个条件的判断。 2 //第一层，只判断性别 3 if(sex == &quot;男&quot;){ 4 //第二次，判断年龄 5 if(age &gt;= 22){ 6 alert(&quot;可以领证了&quot;); 7 }else{ 8 alert(&quot;你还小，等等吧&quot;); 9 } 10 }else{ 11 //第二次，判断年龄 12 if(age &gt;= 20){ 13 alert(&quot;可以领证了&quot;); 14 }else{ 15 alert(&quot;你还小，等等吧&quot;); 16 } 17 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css position的正确用法]]></title>
      <url>%2F2014%2F10%2F27%2Ftitle%2F</url>
      <content type="text"><![CDATA[本文向大家描述一下DIV CSS布局中的position属性的用法，position属性主要有四种属性值，任何元素的默认position的属性值均是static,静态。这节课主要讲讲relative（相对）以及absolute（绝对）。 【如何学习DIV+CSS布局之position属性】 如果用position属性来布局页面，父级元素的position属性必须为relative，而定位于父级内部某个位置的元素，最好用absolute。定位(position)布局页面说容易非常容易，只需要记住这节课最后一句话就可以了，说困难，那是相当的难理解，需要一定的耐心，不过还好，KwooJan给大家总结的已经很通俗易懂了。 如果下面的文字实在是无法理解透，那就记住这节课最后总结的一句话“如果用position来布局页面，父级元素的position属性必须为relative，而定位于父级内部某个位置的元素，最好用absolute，因为它不受父级元素的padding的属性影响，当然你也可以用position，不过到时候计算的时候不要忘记padding的值。” 任何元素的默认position的属性值均是static,静态。这节课主要讲讲relative（相对）以及absolute（绝对）。 【DIV+CSS布局之position属性:absolute】 意思是：他的意思是绝对定位，他默认参照浏览器的左上角，配合TOP、RIGHT、BOTTOM、LEFT(下面简称TRBL)进行定位，有以下属性： 1)如果没有TRBL，以父级的左上角，在没有父级的时候，他是参照浏览器左上角,如果在没有父级元素的情况下，存在文本，则以它前面的最后一个文字的右上角为原点进行定位但是不断开文字，覆盖于上方。 2)如果设定TRBL，并且父级没有设定position属性，那么当前的absolute则以浏览器左上角为原始点进行定位，位置将由TRBL决定。 3)如果设定TRBL，并且父级设定position属性(无论是absolute还是relative)，则以父级的左上角为原点进行定位，位置由TRBL决定。即使父级有Padding属性，对其也不起作用，说简单点就是：它只坚持一点，就以父级左上角为原点进行定位，父级的padding对其根本没有影响。 以上三点可以总结出，若想把一个定位属性为absolute的元素定位于其父级元素内，只有满足两个条件： 第一：设定TRBL 第二：父级设定Position属性 上面的这个总结非常重要，可以保证你在用absolue布局页面的时候，不会错位，并且随着浏览器的大小或者显示器分辨率的大小，而不发生改变。 只要有一点不满足，元素就会以浏览器左上角为原点，这就是初学者容易犯错的一点，已经定位好的板块，当浏览器的大小改变，父级元素会随之改变，但是设定Position属性为absolute的板块和父级元素的位置发生改变，错位了，这就是因为此时元素以浏览器的右上角为原点的原因。 初学者很容易犯错的是，不清楚Position属性为absolute的板块，若想定位到父级板块中，并且当浏览器的大小改变或显示器的分辨率改变，布局不发生改变，是需要满足两个条件的，只要有一点不满足，元素就会以浏览器左上角为原点，从而导致页面布局错位。 【DIV+CSS布局之position属性:relative】 意思是相对定位，他是默认参照父级的原始点为原始点，无父级则以文本流的顺序在上一个元素的底部为原始点，配合TRBL进行定位，当父级内有padding等CSS属性时，当前级的原始点则参照父级内容区的原始点进行定位，有以下属性： 1)如果没有TRBL，以父级的左上角，在没有父级的时候，他是参照浏览器左上角(到这里和absolute第一条一样)，如果在没有父级元素的情况下，存在文本，则以文本的底部为原始点进行定位并将文字断开(和absolut不同)。 2)如果设定TRBL，并且父级没有设定position属性，仍旧以父级的左上角为原点进行定位(和absolut不同) 3)如果设定TRBL，并且父级设定position属性(无论是absolute还是relative)，则以父级的左上角为原点进行定位，位置由TRBL决定(前半段和absolut一样)。如果父级有Padding属性，那么就以内容区域的左上角为原点，进行定位(后半段和absolut不同)。 以上三点可以总结出，无论父级存在不存在，无论有没有TRBL，均是以父级的左上角进行定位，但是父级的Padding属性会对其影响。 综合上面对relative的叙述，我们就可以将position属性为relative的DIV视成可以用TRBL进行定位的的普通DIV，或者说只要将我们平时布局页面的div的CSS属性中加上position:relative后，就不只是用float布局页面了，还可以用TRBL进行布局页面了，或者说加上position:relative的DIV也可以像普通的DIV进行布局页面了，只不过还可以用TRBL进行布局页面。但是position属性为absolute不可以用来布局页面，因为如果用来布局的话，所有的DIV都相对于浏览器的左上角定位了，所以只能用于将某个元素定位于属性为absolute的元素的内部某个位置。 总结： 如果用position来布局页面，父级元素的position属性必须为relative，而定位于父级内部某个位置的元素，最好用absolute，因为它不受父级元素的padding的属性影响，当然你也可以用position，不过到时候计算的时候不要忘记padding的值。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS循环语句]]></title>
      <url>%2F2014%2F10%2F21%2Ftitle7%2F</url>
      <content type="text"><![CDATA[1、循环语句循环语句是一系列反复执行直到符合特定条件的命令。 循环语句实际是对某一段代码进行循环执行，在规定的一个判断条件表达式为假的时候，跳出循环，停止重复执行。 JavaScript 支持 for, do while, while这些循环语句。另外，你可以在循环语句中使用break和continue 语句 。 1、for循环语句for循环语句是一种前测试循环语句。在执行下一次需要重复的代码之前，我需要先测试一下条件表达式到底是真还是假。如果是真，可以执行，如果是假，就不在循环，跳出for循环。for循环内部的循环语句执行时有先决条件。 1 //体验一下考拉体重飙升的过程 2 for(var i = 7 ; i &lt;= 178 ; i+=3){ 3 console.log(&quot;考拉今天&quot; + i + &quot;斤了&quot;); 4 } for循环的语法： 1 for(){} 其他人总结的规律： 1 for(定义循环变量；变量的最大值；步长){ 2 循环体； 3 }以上总结有局限性，for循环并不是只有这一种书写情况。 运行原理： 遇到for循环，先执行①位置的语句，然后执行语句②条件表达式，如果②的值为true，继续执行语句③；如果②的结果为false，直接跳出for循环，执行语句⑤。如果能执行到语句③，执行完之后，去执行语句④，然后再执行语句②，如果②的值为true，继续执行语句③；如果②的结果为false，直接跳出for循环，执行语句⑤。重复这个过程……直到条件②语句为假false，彻底跳出for循环，去执行语句⑤。 注意：（）里面有三个语句，用两个分号分割开，最后一个语句后面不要加分号。 1 for(var i = 3 ; i &lt;= 35 ; i += 6;){ 2 console.log(i); 3 } 1 //第二个 2 for(var i = 5 ; i &lt; 25 ; i += 5){ 3 console.log(i); 4 } 1 //第三个 2 for(var i = 30; i &gt;= 10 ; i -= 7){ 3 console.log(i); 4 } 1 //第四个 2 for(var i = 3 ; i &lt;= 35 ; i *= 2){ 3 console.log(i); 4 } for循环内部定义的这个i变量，是一个全局变量，定义在全局，可以在全局任意地方使用。可以将i变量的声明和赋初值，写在for循环外面，第一个语句的位置可以空着。 1 //第五种 2 var i = 3; 3 for(; i &lt;= 10 ; i += 3){ 虽然第一个语句可以不写，但是分号不能省略 4 console.log(i); 5 } 如果不写第一个分号，会报错，认为你没写第三个语句 1 //第六个 2 var i = 3; 3 for(console.log(i++); i &lt;= 10 ; i += 3){ 4 console.log(i); 5 } 如果限制条件没有了，不写，认为可以一直进入到语句③，循环会无限进行下去，叫做死循环。程序一定要合理，不要书写死循环。 1 //第七个 2 var i = 3; 3 for(console.log(i++); ; i += 3){ 4 console.log(i); 5 } 6 var i = 3; 7 for(console.log(i++); i &gt; 1 ; i += 3){ 8 console.log(i); 9 }10 1 //第八个 2 for(var i = 4 ; i &lt;= 12 ;){ 3 i += 3; 4 console.log(i); 5 } 1 //第九个 2 for(var i = 4 ; i &lt;= 3 ;){ 3 i += 3; 4 console.log(i); 5 } for循环内部可以嵌套if语句，输出并不是无条件输出，只有满足某一个条件才会执行输出代码。 1 //第十个，嵌套if语句 2 for(var i = 3 ; i &lt;= 20 ; i += 5){ 3 if(i % 2 == 0){ 4 console.log(i); 5 } 6 } for循环还可以嵌套for循环，注意我们定义的循环变量一定不能重复。循环变量常用名字i,j,k. 1 //第十一个 2 for(var i = 1 ; i &lt;= 5 ; i++){ 3 for(var j = 1; j &lt;= 4 ; j++){ 4 console.log(i,j); 5 } 6 } 2、穷举思想一般我们希望得到一组有特殊意义的数据，电脑并不会直接帮我们输出，而是需要我们编写一段代码，规定一个合理范围，从范围内找到这些数据。电脑需要一一去验证某一个数据是否符合条件，如果符合就输出。 程序必须将范围内每一个数据都检测一遍，通过判断条件确定是否符合要求。这些都需要我们来编写。用到我们的循环将所有可能情况循环一遍，挑出有用的，用if语句。 穷举思想：将可能性全部列举完，穷就是穷尽、完全的意思。 外层：for循环，列举。 内层：if语句，判断。 3、do while循环do while循环是一种后测试循环语句，重复执行某一段代码，直到入口条件测试为假时，跳出循环。 1 语法： 2 do{ 3 statement 4 }while(expression);5 6 do：做某事 while：当……时候 特点：在第一次测试条件之前，结构体会提前执行一次。通常会定义一些变量，让循环有一些不同。需要将这样的变量定义在循环外面，如果定义在内部，会每次重置，有可能死循环。 1 //循环变量定义在循环外面 2 var i = 1; 3 do{ 4 console.log(i); 5 i++; 6 }while(i &lt;= 10); 结构体总是会至少输出一次，条件是后测试的，哪怕条件为假，我也会执行一次结构体。 1 //循环变量定义在循环外面 2 var i = 1; 3 do{ 4 console.log(i); 5 i++; 6 }while(i &gt;= 10); for循环其实可以模拟do while的结构体先执行一次的情况，但是不够优化，尽量少用。 1 //for循环模拟do while 2 var i = 1; 3 for(console.log(i); i &gt;= 9 ; ){ 4 console.log(++i); 5 } 1 //如果变量写在内部，每次循环都会重置，有可能是死循环 2 do{ 3 var i = 1; //全局变量不要定义在内部，会被重置，死循环 4 console.log(i); 5 i++; 6 }while(i &lt;= 10); 7 变量自加的语句，写在输出语句前面和后面，得到的结果是不一样的。 4、while循环while语句反复执行直到一个特定的条件计算为假。 while语句是一个前测试循环语句，在循环体中的代码执行之前，就要测试出口条件。 语法： 1 while(expression){ 2 statement;} 注意：如果有循环变量，需要定义在循环外边。 1 //循环变量写在外面 2 var i = 1; 3 while(i &lt; 10){ 4 console.log(i); 5 i += 3; 6 } 可以用for循环模拟，都是前测试循环语句。 1 //while语句能做的，for循环都能做 2 for(var i = 1 ; i &lt; 10 ; i += 3){ 3 console.log(i); 4 } 变量自加的过程写的位置不同，结果不同。 1 var i = 1; 2 while(i &lt; 10){ 3 i += 3; 4 console.log(i); 5 } 总结：for循环是最重要，用的最多的循环语句。如果必须先执行一次结构体，再判断，最好用do while循环。while能做的for都能做。随意挑选。 5、breakbreak会终止我们的循环。 1 //碰到5的倍数，就停止循环 2 for(var i = 1 ; i &lt; 40 ; i++){ 3 console.log(i); 4 if(i % 5 == 0){ 5 break; 6 } 7 } break如果没有特殊指向，只能终止自己在的内层循环，不能终止外层的其他循环。 1 for(var i = 1 ; i &lt;= 4 ; i++){ 2 for(var j = 1 ; j &lt;= 4 ; j++){ 3 console.log(i,j); 4 if(j == 2){ 5 break; 6 } 7 } 8 } break控制外层循环：给外层循环加一个标签，标签可以代表外层循环，在break后面加这个标签，就会终止标签对应的这一层循环。 1 waiceng : for(var i = 1 ; i &lt;= 4 ; i++){ 2 for(var j = 1 ; j &lt;= 4 ; j++){ 3 console.log(i,j); 4 if(j == 2){ 5 break waiceng; 6 } 7 } 8 } 所有循环语句：如果能够执行break语句，都会跳出循环。 6、continue作用：终止当前这一次的循环，直接进入下一次循环。案例：从1到10，去找偶数，判断如果不是2，不输出直接进入下一个循环。 1 for(var i = 1 ; i &lt;= 10 ; i++){ 2 //如果你不能被3整除，直接跳过看下一个可能性 3 if(i % 3 != 0){ 4 continue; 5 } 6 console.log(i); 7 } continue语句与break一样，也只能作用于当前的循环，不能控制外层循环。 1 for(var i = 1 ; i &lt; 4; i++){ 2 for(var j = 1 ; j &lt; 4 ; j++){ 3 if(j == 2){ 4 //这不是我要的，继续下一次循环 5 continue; 6 } 7 console.log(i,j); 8 } 9 } 控制外层循环：给外层循环加一个标签，将标签名写在continue后面，就可以控制了。 1 waiceng:for(var i = 1 ; i &lt; 4; i++){ 2 for(var j = 1 ; j &lt; 4 ; j++){ 3 if(j == 2){ 4 //这不是我要的，继续下一次循环 5 continue waiceng; 6 } 7 console.log(i,j); 8 } 9 } break和continue：能够优化我们的代码。判断一个数是不是质数，通过break简化。 1 var sum = 0; 2 for(var i = 2 ; i &lt;= Math.sqrt(n) ; i++){ 3 if(n % i == 0){ 4 //说明i是n的一个约数，n肯定不是质数 5 sum++; 6 // alert(n + &quot;不是质数&quot;); 7 break; 8 } 9 } 10 if(sum == 0){ 11 alert(n+&quot;是质数&quot;); 12 }else{ 13 alert(n + &quot;不是质数&quot;);14 } 简化：输出1~10000之间的质数 1 //输出2~10000之间的质数 2 //列出所有的情况，只要发现这个数不是质数的可能性，直接跳到下一次循环 3 waiceng:for(var i = 2 ; i &lt;= 10000 ; i++){ 4 //判断除了1和本身之外只要有质数，打断，跳入下一次循环 5 for(var j = 2 ; j &lt;= Math.sqrt(i) ; j++ ){ 6 if(i % j == 0){ 7 continue waiceng; 8 } 9 } 10 //能够进行到这一步，说明前面的continue没发生作用，j一直都不是i的约数 11 // 确定i就是一个质数 12 console.log(i); 13 }]]></content>
    </entry>

    
  
  
</search>
