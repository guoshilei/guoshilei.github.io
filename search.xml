<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[函数声明提升]]></title>
      <url>http://yoursite.com/2017/02/17/title9/</url>
      <content type="html"><![CDATA[<h2 id="1、函数声明提升"><a href="#1、函数声明提升" class="headerlink" title="1、函数声明提升"></a>1、函数声明提升</h2><p>变量可以先使用后定义。js的解析器在运行的时候，会将所有的全局变量提升到最开始的位置，如果使用的时候可以找到这个变量定义。变量声明提升只提升定义，不提升赋值。初始值默认是undefined。</p>
<pre><code>1    var a;
2    console.log(a);
3    a = 12;
</code></pre><p>函数声明提升：函数可以先调用，后定义。解析器在程序最开始，将全局范围内定义的函数声明提升到代码最前面，声明的时候提升的就是那个变量名指针，总能够根据函数名找到这个函数的圆型。</p>
<pre><code>1    //先调用
2            fun();
3            //后定义
4            function fun(){
5                console.log(1);
6            }
</code></pre><p>函数声明头提升是强制性的：无视if语句以及for循环。</p>
<p>函数的另外一种定义方式：函数表达式的定义，不会进行函数声明提升，它进行的是变量的声明提升。变量声明提升只提升定义 ，不提升函数赋值，里面存的undefined，给调用函数方法，出现引用类型错误。</p>
<pre><code>1    fun1();
2            var fun1 = function(){
3                console.log(2);
4            }
</code></pre><p>对比：同一个变量名给函数和变量，看顺序。变量写在后面，覆盖掉前面的函数名。</p>
<pre><code>1    function fun(){
2                console.log(1);
3            }
4            var fun = function(){
5                console.log(2);
6            }
7            fun();
</code></pre><p>函数声明优先于变量声明：同一个标识符，给变量和函数，在定义提升的时候，会将这个标识符优先给函数使用。</p>
<pre><code>1    //先调用
2            
3            fun();
4            //后定义
5            function fun(){
6                console.log(1);
7            }
8            var fun = function(){
9                console.log(2);
10            }
11    fun();
</code></pre><p>特殊情况解释：函数在定义的时候，进行强制性的声明提升，定义过程已经被提升到代码最前面了，后面再遇到定义的代码，直接忽视。后面定义的变量会遮盖掉这个定义。</p>
<pre><code>1    var fun = function(){
2                console.log(2);
3            }
4            function fun(){
5                console.log(1);
6            }        
7            fun();
</code></pre><p>注意：尽量不要用同一个标识符给变量和函数，定义函数时不要使用函数表达式的方式，用函数关键字的方式。</p>
<h2 id="2、作用域"><a href="#2、作用域" class="headerlink" title="2、作用域"></a>2、作用域</h2><p>2.1 概述</p>
<p>在函数内定义的变量不能从函数之外的任何地方取得，变量仅仅在该函数的内部有定义。因为我们的函数关住了变量的作用域（定义域）。</p>
<p>JS的作用域：没有块级作用域{}，唯一关住作用域的结构就是函数。在函数内部定义的变量就是函数内部的局部变量，只能在函数内部调用，在外部调用会出现错误。</p>
<pre><code>1    //函数关住作用域，内部定义的是局部变量
2            function fun(){
3                var a = 1;
4                console.log(a);
5            }
6            fun();
7            console.log(a);
</code></pre><p>全局变量：从广义上讲，是一个最外层的局部变量，作用域是全局，所以叫做全局变量。可以在全局范围内都访问到这个变量。</p>
<pre><code>1    var b = 2;
2            function fun(){
3                var a = 1;
4                console.log(a);
5                console.log(b);
6            }
7            fun();
</code></pre><p>原理：全局变量语句没有任何限制，只要遇到就会生成一个变量，在任何地方是能找到。局部变量是声明在函数内部的，函数定义时，内部语句并没有执行，没有定义成这个变量，在函数执行的瞬间，立即定义了一个局部变量，执行完之后，这个变量被立即销毁，从外部找不到这个变量的定义，不能调用。</p>
<p>2.2作用域链</p>
<p>函数内部在调用一个变量的时候，查找的路径问题：当遇见一个变量时，JS引擎会从其所在的作用域依次向外层查找，查找会在找到第一个匹配的标识符的时候停止。在多层嵌套的作用域中可以定义同名的标识符，发生“遮蔽效应”。</p>
<pre><code>1        var a = 1;
2            function outer(){
3                var a = 2;
4                function inner(){
5                    //var a = 3;
6                    console.log(a);
7                }
8                inner();
9            }
10            outer();
</code></pre><p>如果函数内部定义变量时，没有写var关键字，认为我们自动在全局进行了变量的声明，我们创建的不在是局部变量，而是全局变量。会造成一个全局污染。</p>
<pre><code>1    var a = 1;
2            function outer(){
3                a = 2;
4                function inner(){
5                    //var a = 3;
6                    console.log(a);
7                }
8                inner();
9            }
10            outer();
11            console.log(a);
</code></pre><p>在全局定义变量，忘了写var关键字，只要有赋值，变量会自动在全局进行声明。</p>
<pre><code>1    b = 3;
2    console.log(b);
</code></pre><p>建议：任何时候定义变量都要写var关键字，避免全局污染。</p>
<p>2.3 函数的参数</p>
<p>函数的参数是一个局部变量。在函数内部可以正常使用。在函数外部不能访问函数参数这个变量。</p>
<pre><code>1    function fun(a,b){
2                a = 1;
3                b = 4;
4                console.log(a + b);
5            }
6            fun();
7            console.log(a);
</code></pre><p>实际工作中如果能封装函数，用到的变量，尽量定义在函数内部，不会影响其他的函数或者全局变量。</p>
<p>2.4 全局变量</p>
<p>全局变量尽量少定义，但是它有自己独特的作用：传递、累加。</p>
<p>程序：有两个函数，执行函数加，给我们的一个变量加1，如果执行函数减，让我们的这个变量减1.两个函数控制同一个变量。</p>
<p>传递：在不同的函数之间进行通信，函数都能使用，必须使用全局变量。</p>
<pre><code>1    //全局变量，可以让任何函数使用，通信
2            var a = 1;
3            function plus(){
4                a++;            
5                return a;
6            }
7            function minus(){
8                a--;
9                return a;
10            }
11            console.log(plus());
12            console.log(plus());
13            console.log(plus());
14            console.log(plus());
15            console.log(minus());
16            console.log(minus());
17            console.log(minus());
</code></pre><p>如果一个函数需要累加一个变量的值，多次执行，值依次累加的。不能使用局部变量，因为每次初始值都会被重置。</p>
<p>累加：全局变量会将变化的值存起来，以备下次使用。</p>
<pre><code>1    //全局变量。，累加功能
2            var a = 1;
3            function sum(){
4                a++;
5                return a;
6            }
7            console.log(sum());
8            console.log(sum());
9            console.log(sum());
10            console.log(sum());
</code></pre><p>2.5 函数的作用域 </p>
<p>函数也有作用域，就是它定义的那个环境，如果定义在另一个函数内，它也只能在这个函数内部调用，在函数外面调用时引用错误。</p>
<pre><code>1    function sum(a){
2                return ++a;
3            }
4            //函数定义在另一个函数内部，在外面是访问不到
5            function outer(){
6                var a = 1;
7                function inner(){
8                    console.log(sum(a));
9                }
10                inner();
11            }
12            outer();
13            inner();
</code></pre><h2 id="3、闭包"><a href="#3、闭包" class="headerlink" title="3、闭包"></a>3、闭包</h2><p>观察闭包的经典案例：</p>
<pre><code>1    //函数定义在另一个函数内部，在外面是访问不到
2            function outer(){
3                var a = 1;
4                function inner(){   //只能在定义域内使用
5                    console.log(a);
6                }
7                return inner;   //返回值得到一个inner函数的定义
8            }
9            // 将函数执行结果赋值给一个变量
10            var fun = outer();//其实将inner函数赋值给了fun
11            //函数如果执行，需要在定义域范围去找变量a。全局没有，正常输出了一个1
12            //执行fun函数，其实是执行指向的那个函数原型，它会在自己定义的作用域内执行
13            // inner定义时作用域内有一个a = 1，inner函数记住了这个定义域
14            // 哪怕在outer函数外面使用inner的时候，我也可以访问到a的定义
15            // console.log(typeof fun);
16            // console.log(fun);
17            fun();
</code></pre><p>每个函数天生就是一个闭包。函数在定义时，会记住自己的作用域环境以及内部的语句，将外部环境和内部语句组成了一个密闭的环境，就是闭包。</p>
<p>闭包不需要特殊的结构，只是会通过特殊结构来观察函数的这一性质。<br>案例观察：</p>
<pre><code>1    function outer(x){
2                function inner(y){   //如果执行函数outer，才会定义inner
3                    console.log(x + y);
4                }
5                return inner;  //一定不要加小括号，如果加了，就立即执行
6            }
7            var i = outer(3);   //inner函数定义的位置，环境x = 3
8            // x = 3;
9            // i = function inner(y){
10            //     console.log(x + y);
11            // }
12            console.log(i);
13            i(5);


1    function fun1(m,n){
2                function fun2(m){
3                    console.log(m + n);
4                }
5                return fun2;
6            }
7            var f = fun1(3,4);//fun2定义的位置
8            f(6);
</code></pre><p>函数这个闭包里的变量并不是一成不变，可以通过函数调用发生一些变化。</p>
<pre><code>1    function outer(){
2                var i = 9;
3                function inner(){
4                    return i++;
5                }
6                return inner;
7            }
8            var inn = outer();  //新建了一个函数，函数是inner，赋值给了变量inn
9            console.log(inn());
10            console.log(inn());
11            console.log(inn());
</code></pre><p>函数定义一次，可以进行多次调用。<br>我们可以认为，每次重新定义，都会产生新的闭包。新的闭包指的是，语句全新，所处环境也是全新的。</p>
<pre><code>1    function outer(){
2                var i = 9;
3                function inner(){
4                    return i++;
5                }
6                return inner;
7            }
8            var inn = outer();  //新建了一个函数，函数是inner，赋值给了变量inn
9            var inn2 = outer();  //新建了一个函数，函数是inner，赋值给了变量inn2
10            console.log(inn());
11            console.log(inn());
12            console.log(inn());
13            console.log(inn2());  //新的函数，闭包是全新的
</code></pre>]]></content>
      
        <categories>
            
            <category> 函数 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cookie和Session]]></title>
      <url>http://yoursite.com/2016/12/13/title44/</url>
      <content type="html"><![CDATA[<h2 id="1、Cookie"><a href="#1、Cookie" class="headerlink" title="1、Cookie"></a>1、Cookie</h2><p>就是一个Response头部的一个K-V对儿。</p>
<blockquote>
<p>当服务器下发了一个Set-Cookie，今后每次request浏览器都会带着相同的cookie上去。</p>
</blockquote>
<p>HTTP是无连接的，当你第一次访问一个服务器的时候，第二次再来到这个服务器（可能就10s之后），服务器此时的HTTP和第一次毫无关系的。对于服务器来说，HTTP是两次，两次之间没有持久保持连续。</p>
<p>setcookie函数就是设置cookie的，有三个参数：k、v、过期时间</p>
<pre><code>&lt;?php
    setcookie(&quot;xingming&quot;,&quot;kaola&quot;,time()+3600);
?&gt;
</code></pre><p>第一次访问页面的时候，我们关心的是Response Headers：</p>
<p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx3vcvg58j20fc04njrm.jpg" alt=""><br>里面有一个Set-Cookie，值为</p>
<pre><code>xingming=kaola; expires=Fri, 27-Jan-2017 12:38:36 GMT
</code></pre><p>表示Cookie的值，和过期时间。</p>
<p>今后的每一次访问同一个域名下的任何网站，都可以看见Request Header中携带了相同的Cookie：</p>
<p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx3vd4wexj20ns05pmxn.jpg" alt=""><br>有什么用！可以方便让：</p>
<blockquote>
<p>① 浏览器记录服务器曾经给我们的信息；</p>
<p>② 服务器记录用户提供的信息</p>
<p>在本地，我们可以轻松使用document.cookie来使用cookie。</p>
</blockquote>
<p>此时你会得到一个String，任何的cookie会被链接成为一个String：</p>
<pre><code>console.log(document.cookie);
</code></pre><p><img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcx3vdbgf3j20lu01laa1.jpg" alt=""></p>
<p>转码：</p>
<pre><code>var c = decodeURIComponent(document.cookie);
</code></pre><p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx3vdgfebj20jy016t8k.jpg" alt=""><br>此时仍然是字符串</p>
<p>变为数组，用;来拆分：</p>
<pre><code>var arr = c.split(&quot;;&quot;);
</code></pre><p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx3vdmzwrj20mc00vmx1.jpg" alt=""> </p>
<p>遍历这个数组，继续用=来拆分为数组：</p>
<pre><code>var result = {};
for(var i = 0 ; i &lt; arr.length ; i++){
    var t_arr = arr[i].split(&quot;=&quot;);
    console.log(t_arr);
}
</code></pre><p><img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcx3vdsctsj20ic01z0sp.jpg" alt=""><br>变为对象：</p>
<pre><code>for(var i = 0 ; i &lt; arr.length ; i++){
    var t_arr = arr[i].split(&quot;=&quot;);
    result[trim(t_arr[0])] = t_arr[1];
}

console.log(result);
</code></pre><p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx3vdy86xj20o300uglk.jpg" alt=""></p>
<p>他的值不是object，所以eval：</p>
<pre><code>var infoobj = eval(&quot;(&quot; + result[&quot;iqianduan.cn&quot;] + &quot;)&quot;);
</code></pre><p>自动填入表单</p>
<pre><code>//如果xingming和nianling不是空，则默认填入文本框
if(infoobj.xingming){
    document.getElementById(&quot;xingmingTxt&quot;).value = infoobj.xingming;
}

if(infoobj.nianling){
    document.getElementById(&quot;nianlingTxt&quot;).value = infoobj.nianling;
}
</code></pre><p>总结一下：</p>
<p>**&gt; cookie的产生仰赖服务器的一次Set-Cookie。今后每一次的访问，我们的request头部都会携带cookie这个东西。</p>
<blockquote>
<p>其实如果不借助服务器，我们浏览器自己能不能发送带有cookie的头部呢，能！就是xhr.setRequestHeader()，不过这个东西没有意义！**</p>
</blockquote>
<p>Cookie的性质</p>
<blockquote>
<p>① Cookie不安全，可以在任何时候被浏览器的network面板被查看。所以千万不要试图让服务器下发密码等机密信息。可以被自由修改！</p>
</blockquote>
<p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx3ve5p7tj20n70dqdgc.jpg" alt=""></p>
<blockquote>
<p>② Cookie是文件格式存储。</p>
</blockquote>
<p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx3vebpv4j20tv09pwf7.jpg" alt=""></p>
<blockquote>
<p>③ 有超时的限制，可以自由设置存活时间。</p>
</blockquote>
<h2 id="2、Session"><a href="#2、Session" class="headerlink" title="2、Session"></a>2、Session</h2><p>有cookie，让服务器发起Set-Cookie: username=且试天下Always;login=true;  此时我们的浏览器今后访问每一个这个网站的页面都会带着cookie上去。服务器识别cookie，一看就知道你登录了！</p>
<p>但是，cookie可以被自由篡改！也就是说，我想登陆谁的号，就登录了谁的号！</p>
<p>有人发明了一个机制，不要通过cookie下发明文信息，发送一个随机乱码下去！服务器同时在内存中保存这个随机数字的人的各种信息。如果有人带这个随机乱码上来，一定是这个人！</p>
<p>此时我们把这种特别的cookie叫做SESSION，也叫作会话。也就是说，session就是cookie！是一种特殊的cookie，是不发送明文，而是发送随机乱码的cookie。 </p>
<p>服务器下发：</p>
<pre><code>&lt;?php
    //开始session
    session_start();

    $_SESSION[&quot;xingming&quot;] = &quot;小丹尼&quot;;
?&gt;
</code></pre><p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx3vknzt6j20lk067q3g.jpg" alt=""><br>今后我的每一次访问，都会带着这个码上去。这个吗对于浏览器来说，没有任何意义！但是服务器就是通过这个码来知道你是你的。</p>
<p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx3vktblej20nz065mxn.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Cookie和Session </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cookie\Session </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP实现分页以及Hash]]></title>
      <url>http://yoursite.com/2016/12/12/title43/</url>
      <content type="html"><![CDATA[<p>##1、PHP实现分页 ##<br>SQL里面的数据非常多的时候，我们不可能一次性查询全部，这样你前台页面无法显示那么多条目。此时可以用LIMIT子句来控制条目跳过多少条，并且读取多少条。</p>
<p>比如：</p>
<pre><code>SELECT * FROM banji0910 LIMIT 25,5;
</code></pre><p>表示跳过25条读取25条。我们就是利用这个SQL语句，制作分页的。</p>
<p>此时PHP工程师会暴露两个参数在GET请求中，page当前页码，pagesize每页条目数：</p>
<pre><code>&lt;?php
    mysql_connect(&quot;localhost&quot;,&quot;root&quot;,123456);
    mysql_select_db(&quot;student&quot;);
    mysql_query(&quot;SET NAMES UTF8&quot;);

    $page = $_GET[&quot;page&quot;];  //从1开始
    $pagesize = $_GET[&quot;pagesize&quot;];

    $skip = $pagesize * ($page - 1);

    $sql = &quot;SELECT * FROM banji0910 ORDER BY id LIMIT {$skip},{$pagesize}&quot;;
    $result = mysql_query($sql);
?&gt;
</code></pre><p>根据这个思路，就可以制作PHP版本的页码条：</p>
<p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx37wqplcj20dr0alaab.jpg" alt=""><br>简单说一下：</p>
<pre><code>//得到条目总数，所以就要发出一次SQL查询
$sql2 = mysql_query(&quot;SELECT count(*) FROM banji0910&quot;);
$r = mysql_fetch_array($sql2);
$count = $r[0];

&lt;div class=&quot;nav&quot;&gt;
    &lt;ul&gt;
        &lt;?php
            //总页数
            $pageAmount = ceil($count / $pagesize);
            for($i = 1 ; $i &lt;= $pageAmount ; $i++){
        ?&gt;
            &lt;li&gt;&lt;a href=&quot;&lt;?php echo &quot;01_PHP_FENYE.php?page={$i}&amp;pagesize={$pagesize}&quot; ?&gt;&quot;&gt;&lt;?php echo $i;?&gt;&lt;/a&gt;&lt;/li&gt;
         &lt;?php
             }
         ?&gt;
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre><blockquote>
<p>PHP分页的好处是：</p>
<p>便于分享网址，因为URL改变了。</p>
<p>PHP分页的缺点是：</p>
<p>页面刷新了并且页面全局刷新了。当你页面其他部分有很多东西的时候，此时非常恐怖，页面的其他的部分陪葬了，重新都刷了一遍。</p>
</blockquote>
<p>现在越来越流行Ajax分页，先说优点就是Ajax不会全局刷新整个页面；缺点就是不便于分享网址。</p>
<h2 id="2、分页条组件的开发"><a href="#2、分页条组件的开发" class="headerlink" title="2、分页条组件的开发"></a>2、分页条组件的开发</h2><p>Ajax分页最难的东西就是分页条组件的开发：</p>
<p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx37wcl3vj20mb0cxgms.jpg" alt=""></p>
<pre><code> `&lt;script type=&quot;text/javascript&quot;&gt;`
    //分页条组件
    function PageNav(params){
        //自己的盒子
        this.$box = $(&quot;#&quot; + params.boxid);
        //试着创建DOM
        $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;cBtn&quot;).html(&quot;上一页&quot;).appendTo(this.$box);
        $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;nBtn&quot;).html(1).appendTo(this.$box);
        $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;nBtn&quot;).html(2).appendTo(this.$box);
        $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;nBtn&quot;).html(3).appendTo(this.$box);
        $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;nBtn&quot;).html(4).appendTo(this.$box);
        $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;ellipsis&quot;).html(&quot;...&quot;).appendTo(this.$box);
        $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;nBtn&quot;).html(999).appendTo(this.$box);
        $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;cBtn&quot;).html(&quot;下一页&quot;).appendTo(this.$box);

        this.$box.find(&quot;.nBtn&quot;).eq(3).addClass(&quot;cur&quot;);
    }

    var pn = new PageNav({
        &quot;boxid&quot; : &quot;pn&quot;
    });
&lt;/script&gt;
</code></pre><p>事件委托，就是给li添加监听，不如给ul添加，用event.target来判断是谁。</p>
<p>函数委托的事情，就是当一个函数要运行的时候，此时不要直接些业务，把具体的业务委托给另一个函数。</p>
<p>在new的时候，要定义一个函数，当页码改变的时候触发：</p>
<pre><code>var pn = new PageNav({
    &quot;boxid&quot; : &quot;pn&quot;,
    //函数委托
    &quot;change&quot; : function(index){
        alert(&quot;页码到了&quot; + index + &quot;页&quot;);

    }
});
</code></pre><p>我们使用翻页的条的时候，new翻页条的时候需要一个总页数。但是总页数往往是在Ajax返回的JSON中：</p>
<p><img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcx37wk1evj20rs079aah.jpg" alt=""><br>此时就要先发出Ajax请求，然后new出翻页条。此时为了防止每次点击翻页条都重新new，一定要判断：</p>
<pre><code>//请求页面
function getStudent(pageNumber){
    $.get(&quot;php/student.php?page=&quot; + pageNumber + &quot;&amp;pagesize=5&quot;,function(data){
        //转为对象
        var dataobj = typeof data == &quot;object&quot; ? data : eval(&quot;(&quot; + data + &quot;)&quot;);
        //数组
        var list = dataobj.result;
        //计算总页数
        var pageAmount = Math.ceil(dataobj.count / 5);
        //删除之前的所有tr
        $(&quot;table tr:gt(0)&quot;).remove();
        //遍历字典，组建DOM上树
        _.each(list,function(dictionary){
            var str = compiled(dictionary);
            $(str).appendTo(&quot;table&quot;);
        });

        //验证导航条是否存在，如果不存在new一个
        if(pageNav == null){
            pageNav = new PageNav({
                &quot;boxid&quot; : &quot;pn&quot;,
                &quot;pageAmount&quot; : pageAmount,
                //函数委托
                &quot;change&quot; : function(index){
                    getStudent(index);
                }
            })
        }
    });
}
</code></pre><h2 id="3、Hash"><a href="#3、Hash" class="headerlink" title="3、Hash"></a>3、Hash</h2><p>Ajax做的一切都是有一个问题，就是URL不变，这样的话，不方便分享网址。此时可以用hash来解决。</p>
<p>一个较完整的URL：</p>
<pre><code>http://www.iqianduan.cn/a/b/c.php?name=%A3%B4%C3%A3%B4%C3&amp;age=12#good
</code></pre><blockquote>
<p>Path 文件路径： <a href="http://www.iqianduan.cn/a/b/c.php" target="_blank" rel="external">http://www.iqianduan.cn/a/b/c.php</a></p>
<p>Query String 查询字符串：?name=%A3%B4%C3%A3%B4%C3&amp;age=12</p>
<p>Hash 锚点：#good</p>
</blockquote>
<p>锚点的本质是a标签，a标签可以发出超级链接，也可以定位超级链接。</p>
<pre><code>&lt;a name=&quot;maomao1&gt;&lt;/a&gt;
</code></pre><p>a不需要有href属性，不需要有内部文本，此时URL中</p>
<blockquote>
<p>#maomao1</p>
<p>就能快速定位浏览器卷动，默认卷动到这里。</p>
<p>hash的更改不会引起页面的刷新，不会重新发送HTTP请求。</p>
</blockquote>
<p>JavaScript得到hash、设置hash都是用：</p>
<pre><code>window.location.hash //读取
window.location.hash = &quot;maomao1&quot;; //设置
</code></pre><p>用百度招聘为例，此时要解决：</p>
<blockquote>
<p>1） 用户输入一个有hash的URL的时候，能够自动加载这个页面的数据，同时分页条也要对应页面有cur；</p>
<p>2） 当用户点击分页条的时候，要改变页面hash</p>
</blockquote>
<p> <img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcx37w2kboj20j809xglu.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> PHP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JSONP跨域详解]]></title>
      <url>http://yoursite.com/2016/12/12/title42/</url>
      <content type="html"><![CDATA[<h2 id="1、Ajax因为安全限制不允许跨域"><a href="#1、Ajax因为安全限制不允许跨域" class="headerlink" title="1、Ajax因为安全限制不允许跨域"></a>1、Ajax因为安全限制不允许跨域</h2><p>Ajax不能跨域，指的是如果你的HTML页面在127.0.0.1上，此时将不能访问127.0.0.2上的文件。如果你的文件在www.iqianduan.cn上，也不能访问www.163.com上的文件。有些浏览器甚至不允许你访问news.58gsl.cn。这是浏览器的安全限制，不允许你随随便便的访问其他服务器上的JSON。</p>
<p><img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcx37voeaaj211y0ildh0.jpg" alt=""></p>
<h2 id="2、JSONP跨域"><a href="#2、JSONP跨域" class="headerlink" title="2、JSONP跨域"></a>2、JSONP跨域</h2><p>JSONP就是JSON with Padding ( JSON和 赘语），指的就是把函数的执行放到外部文件，HTML用script标签引用这个js文件，实际上引用的是对一个函数的执行。此时函数定义在HTML文件里面，数据就通过实参、形参的结合就进入了HTML数据。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    function fun(data){
        alert(data.xingming);
    }
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;haha.txt&quot;&gt;&lt;/script&gt;  → 这个文件执行了fun函数
</code></pre><p>haha.txt文件里面：</p>
<pre><code>fun({&quot;xingming&quot;:&quot;小明&quot;,&quot;nianling&quot;:12,&quot;xingbie&quot;:&quot;男&quot;});
</code></pre><p>红色部分是执行一个函数，就是所谓的“P”。</p>
<p> <img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcx37vvqrfj211x0ebjtg.jpg" alt=""></p>
<p>京东数据的请求：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    function yuanye(data){
        for(var i = 0 ; i &lt; data.comments.length ; i++){
            alert(data.comments[i].content);
        }

    }
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://sclub.jd.com/comment/productPageComments.action?productId=4048938&amp;score=0&amp;sortType=3&amp;page=1&amp;pageSize=10&amp;callback=yuanye&quot;&gt;&lt;/script&gt;
</code></pre><blockquote>
<p>JSONP的缺点：</p>
<p>1） 太不安全，什么时候章泽天和刘强东吵架，刘强东很生气，把JSONP接口换成了</p>
<pre><code>for(var i = 0 ; i &lt; 1000000 ; i++){
alert(&quot;你好&quot;);
}
</code></pre><p>此时你又在用script引用它，此时你的用户也被连带遭殃了。</p>
<p>所以JSONP的提供者，一定要可靠！</p>
<p>2） 没有明显的异步的特点。页面虽然不会假死，但是没有提供回调函数。<br>不过也没关系，页面不假死是重点。</p>
<p>3） 很难控制请求的发出。比如我想点击一个按钮，然后发出请求。<br>不过也很快被解决了，我们可以动态的创建一个script标签，设置了src，一旦上树，上行请求将发出，此时函数将执行！</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var btn = document.getElementById(&quot;btn&quot;);
</code></pre></blockquote>
<pre><code>    //准备一个函数，一会儿外部文件将执行这个函数
    function fun(data){
        alert(data.xingming);
    }

    //事件监听
    btn.onclick = function(){
        var oscript = document.createElement(&quot;script&quot;);
        oscript.src = &quot;haha.txt&quot;;
        document.head.appendChild(oscript);
        document.head.removeChild(oscript);
    }
&lt;/script&gt;
</code></pre><p>甚至我们可以封装一个函数，就不用显式的创建fun函数了，可以把用户传输进来的函数，当做fun函数：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var btn = document.getElementById(&quot;btn&quot;);

    function qingqiu(URL,callback){
        //你第二个传入的参数就是哈哈函数
        window.fun= callback;

        var oscript = document.createElement(&quot;script&quot;);
        oscript.src = URL;
        document.head.appendChild(oscript);
        document.head.removeChild(oscript);
    }

    qingqiu(&quot;haha.txt&quot;,function(data){
        alert(data.nianling);
    });
&lt;/script&gt;
</code></pre><p>jQuery中使用JSONP和使用正经Ajax一样一样的，你完全看不出来，只是些许有些语法不一样。</p>
<h2 id="3、JSONP的jQuery使用"><a href="#3、JSONP的jQuery使用" class="headerlink" title="3、JSONP的jQuery使用"></a>3、JSONP的jQuery使用</h2><p>首先：</p>
<pre><code>$.get(URL,function(data){
});

$.post(URL,function(data){
});
</code></pre><p>jQuery中最全活的API是：</p>
<pre><code>$.ajax();
</code></pre><p>比如：</p>
<pre><code>$.ajax({
    &quot;url&quot; : &quot;php/job.php&quot;,
    &quot;data&quot; : {
        &quot;page&quot; : 2
    },
    &quot;type&quot; : &quot;get&quot;,
    &quot;success&quot; : function(data){
        alert(data);
    }
});
</code></pre><p>等价于：</p>
<pre><code>$.get(&quot;php/job.php?page=2&quot;,function(data){
    alert(data);
})
</code></pre><p>此时jQuery实现JSONP跨域：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.12.3.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    $.ajax({
        //请求的地址，下面是一个域外的地址
        &quot;url&quot; : &quot;http://127.0.0.2/haha.txt&quot;,
        //请求类型是jsonp类型，注意是dataType属性而不是type属性
        &quot;dataType&quot; : &quot;jsonp&quot;,
        //定义我们传进来的success函数叫什么名字
        &quot;jsonpCallback&quot; : &quot;fun&quot;,
        //定义一个函数，这个函数马上会成为window.fun
        &quot;success&quot; : function(data){
            alert(data.xingming);
            alert(data.nianling);
            alert(data.xingbie);
        }
    });
&lt;/script&gt;
</code></pre><p>特别的，如果后台哥哥给你写了callback GET请求参数，可以任意设置调用的函数名字，此时jQuery中可以用？代替这个部分，jQuery会自动帮你填入随机乱码：</p>
<pre><code>$.ajax({
    &quot;url&quot; : &quot;https://sclub.jd.com/comment/productPageComments.action?productId=4048938&amp;score=0&amp;sortType=3&amp;page=1&amp;pageSize=10&amp;callback=?&quot;,
    &quot;dataType&quot; : &quot;jsonp&quot;,
    &quot;success&quot; : function(data){
        alert(data.comments.length);
    }
});
</code></pre><p>此时jQuery就会把请求发往：</p>
<blockquote>
<p><a href="https://sclub.jd.com/comment/productPageComments.action?productId=4048938&amp;score=0&amp;sortType=3&amp;page=1&amp;pageSize=10&amp;callback=jQuery112306426957034965071_1480068166765" target="_blank" rel="external">https://sclub.jd.com/comment/productPageComments.action?productId=4048938&amp;score=0&amp;sortType=3&amp;page=1&amp;pageSize=10&amp;callback=jQuery112306426957034965071_1480068166765</a></p>
</blockquote>
<p>工作中这种模式最最常用。</p>
]]></content>
      
        <categories>
            
            <category> JSONP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JSONP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ajax中的GET请求和POST请求]]></title>
      <url>http://yoursite.com/2016/12/09/title41/</url>
      <content type="html"><![CDATA[<h2 id="1、GET请求"><a href="#1、GET请求" class="headerlink" title="1、GET请求"></a>1、GET请求</h2><p>GET请求参数在URL中，所以参数非常好携带。GET请求没有上行报文体，所以send里面是null。</p>
<pre><code>xhr.open(&quot;get&quot;,&quot;check.php?username=考拉&amp;age=12&quot;,true);
xhr.send(null);
</code></pre><p>研究两个事情：字符转码的问题、用JSON来转为query string。</p>
<p>我们观察一个事情，此时在地址栏中输入你好：</p>
<p><img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcx2sd5ktnj20ac04r746.jpg" alt=""><br>复制出来就是：</p>
<p><a href="http://127.0.0.1/test.txt?%E4%BD%A0%E5%A5%BD" target="_blank" rel="external">http://127.0.0.1/test.txt?%E4%BD%A0%E5%A5%BD</a></p>
<p>也就是说中文汉字就是：%AA%AA%AA</p>
<p>其中AA是一个两位16进制数字。</p>
<p>这个叫做URI转码（Uniform Resource Identifier，统一资源标识符），URI和URL差不多，只不过URL强调的是地址，URI强调的是具体的写法。</p>
<p>因为网址只能是英语字符和数字，不能是中文、日语、韩语、阿拉伯文等等，所以URI就想了个办法，用16进制数字来表示非英语文字。</p>
<p>JavaScript内置了转码的函数，各个浏览器兼容很好：</p>
<blockquote>
<p>从中文 → URI编码：<br>encodeURIComponent(“我爱你”)<br>URL编码 → 中文：<br>decodeURIComponent(“%E4%BD%A0%E5%A5%BD”)</p>
</blockquote>
<p>此时任何后台语言都不需要再次解码就能识别标准URI编码。所以你要知道这个东西不是密码，就是在传输过程中为了防止非英语文字变形，用的临时编码。</p>
<pre><code>&lt;?php
    $ciyu = $_GET[&quot;ciyu&quot;];
    echo $ciyu;
?&gt;
</code></pre><p>为了防止传输过程中变形，所以我们的Ajax程序要：</p>
<pre><code>xhr.open(&quot;get&quot;,&quot;check.php?yonghuming=&quot; + encodeURIComponent(yonghuming) + &quot;&amp;age=&quot; + encodeURIComponent(12));
</code></pre><p>再来研究一个事情，能不能写一个函数，接受一个JSON，返回query string。<br>比如传入：</p>
<pre><code>{
   &quot;yonghuming&quot; : &quot;小明&quot;,
   &quot;age&quot; : 12,
   &quot;sex&quot; : &quot;男&quot;
}
</code></pre><p>返回</p>
<pre><code>&quot;?yonghuming=%E5%B0%8F%E6%98%8E&amp;age=12&amp;sex=%E7%94%B7&quot;
</code></pre><p>函数很好写，利用数组的join方法，是个神器！一旦你遇见让你返回字符串，然后字符串之间有符号，开头、结尾没有符号，就要想到join方法。</p>
<pre><code>function changeJSON2QueryString(JSON){
    var temp = [];
    for(var k in JSON){
        temp.push(k + &quot;=&quot; + encodeURIComponent(JSON[k]));
    }
    return temp.join(&quot;&amp;&quot;);
}
</code></pre><p>所以现在我们Ajax的open语句可以这么玩儿：</p>
<pre><code>var querystring = changeJSON2QueryString({
   &quot;yonghuming&quot; : &quot;小明&quot;,
   &quot;age&quot; : 12,
   &quot;sex&quot; : &quot;男&quot;
});
xhr.open(&quot;get&quot;,&quot;check.php?&quot; + querystring , true);
</code></pre><h2 id="2、POST请求"><a href="#2、POST请求" class="headerlink" title="2、POST请求"></a>2、POST请求</h2><p>POST请求是通过request报文体来传输，所谓open简单，send里面有内容。PHP程序需要我们加上一个Request Header中的Content-type为普通表单，才能在后台用$_POST[]识别。</p>
<p>任何一个post的表单的上行报文头里面，都有这样的K-V对儿：</p>
<blockquote>
<p>Content-Type:application/x-www-form-urlencoded</p>
</blockquote>
<p>所以我们在Ajax中也要设置（今后遇见node.js就不用设置）：</p>
<pre><code>xhr.open(&quot;post&quot;,&quot;dopost.php&quot;,true);
xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);
xhr.send(&quot;yonghuming=%E5%B0%8F%E6%98%8E&amp;age=12&amp;sex=%E7%94%B7&quot;);
</code></pre><h2 id="3、JSON的识别"><a href="#3、JSON的识别" class="headerlink" title="3、JSON的识别"></a>3、JSON的识别</h2><p>JSON是一个通用信息交换格式，比如PHP工程师，可以使用json_encode()函数把别名数组转为标准JSON：</p>
<pre><code>&lt;?php
    $arr = array(
        &quot;result&quot; =&gt; array(
            array(&quot;xingming&quot; =&gt; &quot;小明&quot; , &quot;nianling&quot; =&gt; 12 , &quot;xingbie&quot; =&gt;&quot;男&quot;),
            array(&quot;xingming&quot; =&gt; &quot;小红&quot; , &quot;nianling&quot; =&gt; 15 , &quot;xingbie&quot; =&gt;&quot;女&quot;),
            array(&quot;xingming&quot; =&gt; &quot;小刚&quot; , &quot;nianling&quot; =&gt; 13 , &quot;xingbie&quot; =&gt;&quot;男&quot;)
        )
    );

    echo json_encode($arr);
?&gt;
</code></pre><p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx2sdao8vj20wj05tq30.jpg" alt=""><br>JSON显示在页面上的时候，不方便我们看JSON的结构，此时推荐安装一个浏览器插件，叫做JSONView。</p>
<p>Chrome应用商店打不开，并且网上下载的都不适合现在的Chrome版本。所以我们可以安装QQ浏览器，它的内核也是Chrome内核，中国人没有自己的浏览器内核。在应用中心中，安装“JSONView”。</p>
<p><img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcx2sdhppfj20xd0gjtal.jpg" alt=""><br>安装完插件之后，访问JSON页面：</p>
<p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx2sdnovwj20ee0cb74g.jpg" alt=""></p>
<h2 id="4、JSON识别"><a href="#4、JSON识别" class="headerlink" title="4、JSON识别"></a>4、JSON识别</h2><p>我们使用Ajax读取一个JSON的时候，此时明明是JSON，但是读进来是String。此时就要把String变为JSON。</p>
<pre><code>$.get(&quot;04_JSON.php&quot;,function(data){
    console.log(data);
    console.log(typeof data);
});
</code></pre><p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx2sdz8ikj20l404u74m.jpg" alt=""><br>一共有三种方法。</p>
<blockquote>
<p>方法1：使用内置构造函数JSON的方法</p>
</blockquote>
<pre><code>var dataobj = JSON.parse(data);
console.log(dataobj);
console.log(typeof dataobj);
</code></pre><p>JSON是系统内置的构造函数，和Number、String、Array一样。它IE8才开始有，IE6、7不支持JSON内置构造函数。</p>
<p>它一共就有两个方法：</p>
<blockquote>
<p>JSON.parse() 字符串 → 对象</p>
<p>JSON.stringify() 对象 → 字符串</p>
</blockquote>
<p>JSON.parse()函数里面的字符串必须是标准JSON，必须有双引号引用所有的key。</p>
<blockquote>
<p>方法2：使用eval语句</p>
</blockquote>
<p>eval语句可以把字符串变为语句，是JS中的一个特色。</p>
<pre><code>var str = &quot;alert(1+2+3)&quot;; //字符串
eval(str);  //字符串变为了语句
</code></pre><p>弹出6。</p>
<p>eval()一般都是当做奇淫技巧使用，注意任何文本框都需要用正则表达式阻止eval。比如让你输出一个用户名，你叫做eval(“setInterval(function(){alert(‘哈哈’);},1)”);  极其危险！</p>
<p>我们可以利用eval语句来把JSON字符串变为对象的JSON，但是此时要注意：<br>如果直接eval一个JSON字符串，会报错：</p>
<p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx2se74w1j20dh01ljra.jpg" alt=""><br>语法要求必须用圆括号括起来：</p>
<p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx2sedfy8j208001j3yd.jpg" alt=""><br>所以：</p>
<pre><code>var dataobj = eval(&quot;(&quot; + data + &quot;)&quot;);
console.log(dataobj);
console.log(typeof dataobj);
</code></pre><blockquote>
<p>方法3：借助Function函数</p>
<pre><code>var sum = new Function(&quot;a&quot;,&quot;b&quot;,&quot;return a + b&quot;);
alert(sum(3,4));
</code></pre></blockquote>
<p>Function你仔细琢磨，也可以把字符串变为语句啊！</p>
<pre><code>var dataobj = (new Function(&quot;return &quot; + data))();
console.log(dataobj);
console.log(typeof dataobj);
</code></pre><h2 id="5、复杂JSON的JS处理"><a href="#5、复杂JSON的JS处理" class="headerlink" title="5、复杂JSON的JS处理"></a>5、复杂JSON的JS处理</h2><p>现在拿一个JSON举例子：</p>
<p><img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcx2seks0wj20sa0gx3z0.jpg" alt=""><br>请用Ajax读取它，在HTML页面上枚举所有点击数大于1000的文章标题。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    $.get(&quot;system/baijiayanshi.txt&quot;,function(data){
        //把字符串转为真正的JSON
        var dataobj = eval(&quot;(&quot; + data + &quot;)&quot;);
        //如鱼得水，“JSON回家了”
        var arr = dataobj.data.list;

        for(var i = 0 ; i &lt; arr.length ; i++){
            if(arr[i].hotcount &gt; 1000){
                $(&quot;&lt;p&gt;&quot; + arr[i].m_title + &quot;【点击数：&quot; + arr[i].hotcount + &quot;】&lt;/p&gt;&quot;).appendTo(&quot;#box&quot;);
            }
        }
    });
&lt;/script&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> Ajax </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[原生Ajax的实现]]></title>
      <url>http://yoursite.com/2016/12/08/title40/</url>
      <content type="html"><![CDATA[<h2 id="原生Ajax的实现"><a href="#原生Ajax的实现" class="headerlink" title="原生Ajax的实现"></a>原生Ajax的实现</h2><p>原生Ajax要依赖一个内置构造函数，XMLHttpRequest()，字面理解“XML HTTP 请求者”。这个对象的实例有能力异步发出HTTP请求的能力。</p>
<p>要实例化这个对象：</p>
<pre><code>var xhr = new XMLHttpRequest();
</code></pre><p>此时IE6不兼容这个对象：</p>
<pre><code>//实例化XMLHttpRequest对象，有兼容问题
if(window.XMLHttpRequest){
    //高级浏览器
    var xhr = new XMLHttpRequest();
}else{
    //IE6
    var xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
}
</code></pre><p>我们可以配置它的发送请求：</p>
<pre><code>xhr.open(&quot;get&quot;,&quot;test.txt&quot;,true);
</code></pre><p>三个参数分别是请求的类型、URL、是否是异步。第三个参数一定是true，否则就不是异步读取了。<br>请求没有真正发出，仅仅是配置了打开了发送“窗口”。</p>
<p>此时用send方法发出请求。send就是发送请求，参数是上行请求的报文体。get请求不需要报文体，就是null。</p>
<pre><code>xhr.send(null);
</code></pre><p>原生JS中没有提供给一个明显的回调函数，此时需要监听一个事件，就绪状态改变事件：</p>
<pre><code>xhr.onreadystatechange = function(){
    console.log(&quot;就绪状态改变了&quot; + xhr.readyState);
}
</code></pre><p>对我们有用的两个readyState就是3、4。当readyState为3的时候，已经可以得到服务器的信息，因为header已经回来了，做倒计时秒杀的收，就用3这个状态。4表示所有内容已经成功返回，更有用，因为只有状态是4的时候才能得到完整的文件信息。</p>
<p>接受到的信息是xhr.responesText。</p>
<pre><code>xhr.onreadystatechange = function(){
    if(xhr.readyState == 4){
        info.innerHTML = xhr.responseText;
    }
}
</code></pre><p>有规定，onreadystatechange必须写在open和send前。所以至此代码：</p>
<pre><code>//① 实例化XMLHttpRequest对象，有兼容问题
if(window.XMLHttpRequest){
    //高级浏览器
    var xhr = new XMLHttpRequest();
}else{
    //IE6
    var xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
}

//② 监听一个事件，叫做“就绪状态”改变的事件
xhr.onreadystatechange = function(){
    if(xhr.readyState == 4){
        info.innerHTML = xhr.responseText;
    }
}

// ③ 配置一个请求，open可以理解为打开一个请求“窗口”
xhr.open(&quot;get&quot;,&quot;test.txt&quot;,true);
// ④ 发送请求，send就是发送请求，参数是上行请求的报文体。get请求不需要报文体，就是null。
xhr.send(null);
</code></pre><p>此时我们需要让程序更加鲁棒，当文件不存在的时候，整个页面的错误信息也读到本页面来了：</p>
<p>所以就要用HTTP状态码来验证文件是否已经成功发送。</p>
<p>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。这个代码是后台哥哥可以随便设置的，阿帕奇服务器也会帮我们自动生成状态码。</p>
<p>重要的状态码是：</p>
<blockquote>
<p>200-成功</p>
<p>302-临时移动</p>
<p>304-没有更改</p>
<p>400-错误的请求</p>
<p>401-没有权限</p>
<p>403-禁止</p>
<p>404-页面丢失，没有找到</p>
<p>500-服务器错误</p>
<p>502-错误的网关</p>
<p>503-服务无效</p>
<p>504-访问超时</p>
</blockquote>
<p>xhr对象的status属性可以得到状态码。从而可以用来验证页面是不是真的发过来了，此时验证字头是2开头的或者是304。</p>
<pre><code>xhr.onreadystatechange = function(){
    if(xhr.readyState == 4){
        if(xhr.status.toString().charAt(0) == &quot;2&quot; || xhr.status == &quot;304&quot;){
            info.innerHTML = xhr.responseText;
        }
    }
}
</code></pre><p>也可以：</p>
<pre><code>if(xhr.status == &quot;200&quot; || xhr.status == &quot;304&quot;){
}
</code></pre><p>也可以：</p>
<pre><code>if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){
}
</code></pre><p>Ajax的缓存比较严重，此时可以通过每次访问的时候带一个不同的参数即可。<br>此时可以挂一个随机数，或者时间戳：</p>
<pre><code>xhr.open(&quot;get&quot;,&quot;test.txt?&quot; + Date.parse(new Date()),true);

xhr.open(&quot;get&quot;,&quot;test.txt?&quot; + Math.random(),true);
</code></pre><p>至此，已经学习了xhr的：</p>
<blockquote>
<p>● 一个事件</p>
<p>xhr.onreadystatechange  就绪状态改变事件</p>
<p>● 两个方法 </p>
<p>xhr.open()方法      打开一个发射窗口<br>xhr.send()方法    发送请求</p>
<p>● 三个属性</p>
<p>xhr.responseText        返回的文本<br>xhr.readyState        就绪状态<br>xhr.status            3位数字的状态码number类型</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Ajax </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[游戏开发中canvas常见要点]]></title>
      <url>http://yoursite.com/2016/12/05/title39/</url>
      <content type="html"><![CDATA[<h2 id="1-游戏图片、音乐资源的管理"><a href="#1-游戏图片、音乐资源的管理" class="headerlink" title="1 游戏图片、音乐资源的管理"></a>1 游戏图片、音乐资源的管理</h2><p>不管游戏中有多少元素在运动，游戏仅仅有1个定时器，这1个定时器让所有的演员更新、渲染。<br>实际上，一个游戏需要大量的图片，只有当所有图片都load了，游戏才能开始。换句话说，只有当所有图片都load了，主循环setInterval()才能启动。</p>
<p>所以我们的思路就是用JSON imagesObj 存放所有的资源图片的名字，用循环语句for..in…去创建他们的Image对象，然后监听他们的load事件，load一个计数器加1，当load完一个图片的时候，计数器正好等于了数组总长度，此时表示所有图片加载完毕。比较巧妙的是，我们创建了一个R对象，这个对象和imagesObj 的key是一样的，但是v是图片的Image实体，用图片的时候，要通过R打点来找到图片。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
   //得到画布标签
   var myCanvas = document.querySelector(&quot;#myCanvas&quot;);
   //上下文，就相当于打开Photoshop之后让你新建画布
   var ctx = myCanvas.getContext(&quot;2d&quot;);
   //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。

   //如果要使用图片，必须要创建一个Image的实例，然后监听这个img的load事件
   //只有load的图片才能上画布
   var imagesObj = {
       &quot;shibing&quot; : &quot;images/shibing.png&quot;,
       &quot;baozha&quot; : &quot;images/baozha.png&quot;
   };

   //图片资源对象，k和imagesObj是一样的，v是真正的图片Image对象
   var R = {};

   //已经加载好的图片个数
   var count = 0;

   var cutx = 0;
   var baozhaxuhao = 0;

   for(var k in imagesObj){
       //创建图片节点
       R[k] = new Image();
       //设置src
       R[k].src = imagesObj[k];
       //监听是否load
       R[k].onload = function(){
          count++;
          if(count === 2){
              //全部都加载完毕
              setInterval(function(){
                 cutx ++;
                 baozhaxuhao++;
                 if(cutx &gt; 7){
                     cutx = 0;
                 }
                 if(baozhaxuhao &gt; 11){
                     baozhaxuhao = 0;
                 }

                 //清屏
                 ctx.clearRect(0, 0, 800, 600);

                 ctx.drawImage(R.shibing,120 * cutx,150 * 3,120,150,100,100,120,150);

                 ctx.drawImage(R.baozha,192 * (baozhaxuhao % 5),192 * parseInt(baozhaxuhao / 5),192,192,100,100,192,192);
              },20);
           }
       }
   }
&lt;/script&gt;
</code></pre><h2 id="2、Game类Game类就是中介者模式中的中介者-。"><a href="#2、Game类Game类就是中介者模式中的中介者-。" class="headerlink" title="2、Game类Game类就是中介者模式中的中介者 ##。"></a>2、Game类Game类就是中介者模式中的中介者 ##。</h2><p>中介者就是全局变量！比如我们以前</p>
<pre><code>var idx = 10;
</code></pre><p>信号量，就是全局变量，现在把这个量放入一个类的实例身上，此时这个类就是中介者。</p>
<p>信号量在中介者身上：</p>
<pre><code>var game = new Game();
game.idx = 10;
</code></pre><p>以后所有的元素都是Game类new出来的，我们只需要new出中介者，其他元素都是Game帮我们new出来的。</p>
<p>其他元素如果要互相通信，要通过Game类：</p>
<pre><code>game.bird.y
</code></pre><p>在HTML5游戏中，Game类还将有：主循环、游戏资源管理两个任务。</p>
<p>图片资源管理利用两个对象，RObj和R对象。Robj就是Ajax请求来的文本转为的对象，v是路径； R对象的拥有Robj相同的k，但是v是真实对象：</p>
<h2 id="3-背景类背景类的实例化"><a href="#3-背景类背景类的实例化" class="headerlink" title="3 背景类背景类的实例化"></a>3 背景类背景类的实例化</h2><p>在Game的start函数里面。而start函数的调用的前提是所有资源已经加载完毕了。说白了，背景类里面可以直接使用图片资源。</p>
<p>canvas里面也有猫腻，也有模式。渲染三张，目的是无缝连续滚动，当猫腻图的左边框到达0点，就拉回来。</p>
<h2 id="4、cancas变形"><a href="#4、cancas变形" class="headerlink" title="4、cancas变形"></a>4、cancas变形</h2><p>canvas中，提供了变形属性，需要注意的是，所有的变形都是针对画布上下文ctx对象的，而不是某一个要绘制的元素的。</p>
<p><img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcx1r55msdj206a069dfn.jpg" alt=""><br>    <script type="text/javascript"><br>       var mycanvas = document.getElementById(“mycanvas”);</p>
<pre><code>   var ctx = mycanvas.getContext(&quot;2d&quot;);

   //保存当前的上下文状态
   ctx.save();
    //移动坐标系
   ctx.translate(100,100);
   //画圆
   ctx.fillStyle = &quot;blue&quot;;
   ctx.beginPath();
   ctx.arc(0,0,50,0,Math.PI * 2,true);
   ctx.fill();
   //恢复上下文存档状态
   ctx.restore();

   //画方块
   ctx.fillRect(100, 100, 100, 100);
&lt;/script&gt;
</code></pre><p>坐标系还可以通过</p>
<p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx1r5arbij20kw0ccwg0.jpg" alt=""><br>    ctx.rotate(1);<br>渲染1弧度。同样的，旋转的是整个坐标系，而不是某一个元素。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
   var mycanvas = document.getElementById(&quot;mycanvas&quot;);

   var ctx = mycanvas.getContext(&quot;2d&quot;);

   ctx.rotate(1); //1弧度，顺时针
   ctx.fillStyle = &quot;orange&quot;;
   ctx.fillRect(100, 100, 100, 100);
&lt;/script&gt;
</code></pre><p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx1r5hccaj20sl0c7di8.jpg" alt=""></p>
<p>如果想要让一个元素以自己的几何中心点旋转，此时需要：</p>
<blockquote>
<p>① 先让坐标系的原点移动到它的中心点，此时盒子的渲染位置就是负的自己的宽度的一半，负的自己的高度的一半。</p>
<p>② 旋转</p>
<p>公式：</p>
<p>t指的是开始下落后的时间，此时小鸟就要维护自己的小帧号birdF。</p>
</blockquote>
<pre><code>//物理公式：s = 1/2gt^2
//掉
birdF++;
birdY = 100 + 1.3 * birdF * birdF;
birdRotate+=0.08;
</code></pre><h2 id="5、碰撞检测"><a href="#5、碰撞检测" class="headerlink" title="5、碰撞检测"></a>5、碰撞检测</h2><p>但是游戏中我们一般使用AABB盒检测。</p>
<p>AABB盒是英语Axis Aligned Bounding Box 轴对齐包围盒。</p>
<p>鸟是一个不规则形状，判断碰撞的时候取一个大概，用矩形盒子来判断：</p>
<pre><code>//更新自己的碰撞检测盒
this.A = this.y + 7;
this.B = this.x + 41;
this.C = this.y + 41;
this.D = this.x + 7;
</code></pre><p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx25ury91j20h90c80sx.jpg" alt=""><br>鸟这个图片本身是48宽度，碰撞盒是34，所以两边有误差7。</p>
<p>所谓的ABCD都是边的x或者y，横边就取y值，纵边就取x值。<br>碰撞检测：</p>
<pre><code>if(
    game.bird.A &lt; this.C1 &amp;&amp; game.bird.B &gt; this.D1 &amp;&amp; game.bird.D &lt; this.B1
       ||
    game.bird.C &gt; this.A2 &amp;&amp; game.bird.B &gt; this.D2 &amp;&amp; game.bird.D &lt; this.B2
){
    console.log(&quot;撞！&quot;);
    clearInterval(game.timer);
}
</code></pre><h2 id="6、合成canvas"><a href="#6、合成canvas" class="headerlink" title="6、合成canvas"></a>6、合成canvas</h2><p>ctx.globalCompositeOperation = type</p>
<p>一共有12种值，表示新画的图形和老图形的关系，称为“合成”。</p>
<p><img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcx1r5yi62j20i60gimyb.jpg" alt=""></p>
<p><img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcx1r6m40cj20hx0e2wfe.jpg" alt=""><br>比如：</p>
<pre><code>ctx.fillStyle = &quot;blue&quot;;
ctx.fillRect(100,100,100,100);

ctx.globalCompositeOperation = &quot;source-in&quot;;

ctx.beginPath();
ctx.arc(180,180,50,0,7,false);
ctx.fillStyle = &quot;red&quot;;
ctx.fill();
</code></pre><p>像素操作到目前为止，我们尚未深入了解Canvas画布真实像素的原理，事实上，你可以直接通过ImageData对象操纵像素数据，直接读取或将数据数组写入该对象中。稍后我们也将深入了解如何控制图像使其平滑（反锯齿）以及如何从Canvas画布中保存图像。</p>
<p>得到像素：</p>
<pre><code>var myImageData = ctx.getImageData(0,0,560,300);
</code></pre><p>0,0表示起点位置，560是宽度，300是高度。</p>
<p>得到的值可以被使用作为查看初始像素数据。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是”RGBA”格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。</p>
<h2 id="7、事件监听"><a href="#7、事件监听" class="headerlink" title="7、事件监听"></a>7、事件监听</h2><p>canvas上必须检测范围，因为得不到元素。</p>
<p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx1r6uvngj20hr09qdfr.jpg" alt=""><br>贝塞尔曲线：</p>
<pre><code>ctx.moveTo(100,100);
ctx.bezierCurveTo(200, 50, 400, 50, 400, 100);
ctx.stroke();
</code></pre><p>点击鼠标的时候，要遍历每个元素，看看点击到了谁，点击到的这个元素，就存入变量。然后让变量中的元素x、用、跟随你的鼠标变化即可。</p>
<pre><code>if(x &gt; ctrl1.x - 5 &amp;&amp; x &lt; ctrl1.x + 5 &amp;&amp; y &gt; ctrl1.y - 5 &amp;&amp; y &lt; ctrl1.y + 5){
   diandaodedian = ctrl1;
}

if(x &gt; ctrl2.x - 5 &amp;&amp; x &lt; ctrl2.x + 5 &amp;&amp; y &gt; ctrl2.y - 5 &amp;&amp; y &lt; ctrl2.y + 5){
   diandaodedian = ctrl2;
}

if(x &gt; start.x - 5 &amp;&amp; x &lt; start.x + 5 &amp;&amp; y &gt; start.y - 5 &amp;&amp; y &lt; start.y + 5){
   diandaodedian = start;
}

if(x &gt; end.x - 5 &amp;&amp; x &lt; end.x + 5 &amp;&amp; y &gt; end.y - 5 &amp;&amp; y &lt; end.y + 5){
   diandaodedian = end;
}
</code></pre><h2 id="8、场景Scene管理"><a href="#8、场景Scene管理" class="headerlink" title="8、场景Scene管理"></a>8、场景Scene管理</h2><p>开始画面、游戏过程、结束画面。</p>
<p>场景现在开始接手管理自己的演员！！<br>但是，场景还是应该把演员注册到game身上，但是管理的权限、谁上台、谁下台，是场景管理器的任务。</p>
<p>监听都是场景管理器负责注册！！</p>
<p><a href="http://squishybird.com/">http://squishybird.com/</a></p>
<p><a href="http://so2.4399.com/">http://so2.4399.com/</a></p>
</script></p>]]></content>
      
        <categories>
            
            <category> Canvas </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Canvas </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[移动端缓冲ease事件]]></title>
      <url>http://yoursite.com/2016/11/30/title37/</url>
      <content type="html"><![CDATA[<h2 id="1、缓冲ease"><a href="#1、缓冲ease" class="headerlink" title="1、缓冲ease"></a>1、缓冲ease</h2><p>CSS中的transition第三个参数就是缓冲描述：</p>
<pre><code>transition:all 1s linear 0s;  
transition:all 1s ease 0s;
</code></pre><p>JS也有，但是要自己推理：</p>
<p>让div用100帧，从left100变化到left800。匀速的话，非常好计算：</p>
<p>总变化量就是700，所以每帧的变化量应该是7。</p>
<p>帧编号t    距起点的增量t<em>c/d    绝对位置b + t</em>c/d</p>
<p><img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcx117g54qj20hr097wek.jpg" alt=""></p>
<blockquote>
<p>假设帧编号为t（本例中t自增），t就是time的意思</p>
<p>起点成为b（本例中b为100），b就是begin起点的意思</p>
<p>总变化量c（本例中c为700），c就是change变化量的意思</p>
<p>总帧数d（本例中d为100），d就是duration持续时间的意思</p>
</blockquote>
<p>所以刚才的推理就变为了一个函数：</p>
<pre><code>function linear(t,b,c,d){
    return b + t * c / d;
}
</code></pre><p>此时这个函数接受四个参数的意义，上面已经说明了，返回的是绝对位置。此时观察这个函数，</p>
<blockquote>
<p>t=0的时候，返回值是b （运动没有开始） ； </p>
<p>t= d的时候，返回值就是b+c　（运动结束）。</p>
</blockquote>
<p>所以我们就可以自己写一些函数，比如二次的：</p>
<pre><code>function haha(t,b,c,d){
    return b + t * t * c / (d *d);
}
</code></pre><p>Excel中做图：<br> <img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcx117mk4gj20vq0f5dhk.jpg" alt=""></p>
<p>上网能下载到很多t、b、c、d的函数</p>
<p> <img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx117vwgoj20oq0gx0tl.jpg" alt=""></p>
<p>jQuery中实现缓冲，下载jQuery.easing.js的包</p>
<pre><code>$().animate({},1000,&quot;easeInOut&quot;);
</code></pre><h2 id="2、手指滚滚屏"><a href="#2、手指滚滚屏" class="headerlink" title="2、手指滚滚屏"></a>2、手指滚滚屏</h2><p>手机滚滚屏中，希望有一个loading界面，当所有图片都加载好支持，再从容给用户观看。<br>所以我们要管理好资源，我们的想法就是使用一个JSON列出所有的图片资源：</p>
<pre><code>{
    &quot;tu1&quot; : &quot;images/1.jpg&quot;,
    &quot;tu2&quot; : &quot;images/2.jpg&quot;,
    &quot;tu3&quot; : &quot;images/3.jpg&quot;
}
</code></pre><p>用JS写程序创建一个个孤儿节点，图片对象存储在和这个JSON相同的另一个对象中：</p>
<pre><code>{
    &quot;tu1&quot; : Image(),
    &quot;tu2&quot; : Image(),
    &quot;tu3&quot; : Image()
}
</code></pre><p>此时HTML页面上，仅仅用img标签的“模板”来占位，用JS的真实图片孤儿节点，替换这个节点。</p>
<pre><code>&lt;img data-name=&quot;tu1&quot; /&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> 移动web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 移web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[移动端JS事件]]></title>
      <url>http://yoursite.com/2016/11/30/title36/</url>
      <content type="html"><![CDATA[<p>##1、触摸事件 ##<br>移动端JS事件，重要就是触摸事件。触摸事件和鼠标事件完全不一样，因为鼠标不可能离开屏幕，鼠标在屏幕上可以点击可以不点击；但是手指可以离开屏幕，手指一旦碰到屏幕，就被视为点击了。所以，JS设计了一套完整的触摸事件系列，适应移动端web开发。</p>
<blockquote>
<p>touchstart 开始触摸</p>
<p>touchmove 手指移动</p>
<p>touchend 结束触摸</p>
<p>touchstart 在手指触摸的一瞬间发生，如果有多个手指触摸，每个手指触摸的时候都会发生。</p>
<p>touchend 在手指离开屏幕的一瞬间发生，如果有多个手指离开，每个手指离开的时候都是触发这个事件。</p>
<p>绑定他们的时候，只能用DOM2级来绑定，不能用window.on<em>*</em>来绑定。</p>
</blockquote>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var box = document.querySelector(&quot;#box&quot;);

    box.addEventListener(&quot;touchstart&quot;, function(){
        box.innerHTML = &quot;你触摸了我&quot;;
    }, true);

    box.addEventListener(&quot;touchend&quot;, function(){
        box.innerHTML = &quot;你结束触摸了我&quot;;
    }, true);
&lt;/script&gt;
</code></pre><p>注意，touchstouch事件和touchmove事件中event事件对象中有一个属性叫做touches是一个数组，里面封装了每个手指的信息，包括手指的位置、手指的粗细、力度（仅仅iPhone7提供）都有：<br> <img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx0rleo7yj2093096dfz.jpg" alt=""><br>手指的数量：</p>
<pre><code>var fingers = event.touches.length;
</code></pre><p>每根手指的位置信息：</p>
<pre><code>//触摸移动
box.addEventListener(&quot;touchmove&quot;, function(event){
    //阻止默认事件
    event.preventDefault();
    //得到每个手指的信息
    var fingers = event.touches;
    //清空
    box.innerHTML = &quot;&quot;;
    //遍历每个手指，显示信息
    for(var i = 0 ; i &lt; fingers.length ; i++){
        box.innerHTML += &quot;第&quot; + i + &quot;根手指位置&quot; + fingers[i].clientX + &quot;,&quot; + fingers[i].clientY + &quot;&lt;br /&gt;&quot;;
    }
}, true);
</code></pre><p>touchend事件中比较特殊，touches属性是一个数组，表示现在仍然在屏幕上的手指；而changedTouches属性也是一个数组，表示离开的手指的信息。先离开屏幕的手指，先被push进入数组。</p>
<p>事件比较简单就是三个事件，和里面的event.touches属性。难点在于程序，在于三个事件的配合。手机端，要注意几个模型：拖拽、轮播图、抛掷、滑动拖出。</p>
<blockquote>
<p>最后说一个问题，就是手机中也有click事件，但是click事件比touchstart要晚触发200ms到300ms左右，因为浏览器有默认的一些手指快捷操作，比如双击两次放大视口。如果你用click写了一个div的单击事件，此时点击之后浏览器会等待200~300ms时间看看你有没有第二次点击，如果200~300ms以内没有点击，此时触发你的click事件，如果有点击，则你的click事件业务不发生，而是放大视口。但是touchstart不会等待，只要你碰到了屏幕一定会执行touchstart事件。</p>
</blockquote>
<p>注意，a标签执行的是类似click事件，等于说a标签被延迟了200~300触发，所以手机web中越来越不使用a标签跳转了，而是touchstart事件跳转。方法就是让元素携带data-href属性，然后用js批量给他们绑定的touchstart事件，让window.location切换为自己携带的data-href属性的值。</p>
<pre><code>&lt;div id=&quot;box&quot; data-herf=&quot;http://m.taobao.com&quot;&gt;&lt;/div&gt;
&lt;div id=&quot;box&quot; data-herf=&quot;http://m.dangdang.com&quot;&gt;&lt;/div&gt;

var herfBoxs = document.querySelectorAll(&quot;[data-herf]&quot;);
for(var i = 0 ; i &lt; herfBoxs.length ; i++){
    herfBoxs[i].index = i;
    herfBoxs[i].addEventListener(&quot;touchstart&quot;, function(){
        window.location = this.getAttribute(&quot;data-herf&quot;);
    }, true);
}
</code></pre><h2 id="2、拖拽"><a href="#2、拖拽" class="headerlink" title="2、拖拽"></a>2、拖拽</h2><p>拖拽是一切的基础，我们之前在鼠标的事件中已经学习过，但是你会发现：</p>
<pre><code>box.onmousedown = function(){
    document.onmousemove = function(){

    }
}

document.onmouseup = function(){
    document.onmousemove = null;
}
</code></pre><p>鼠标事件和触摸事件不一样，因为手指移动一定是在屏幕上的。所以touchmove事件不需要写在touchstart事件里面。其他的原理完全一致。</p>
<p>三个事件各自有各自的用处：<br> <img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcx0rlmbvwj20ns0ihadj.jpg" alt=""></p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var img = document.querySelector(&quot;#yangyang&quot;);

    //信号量
    var x = 100;
    var y = 100;

    var startX,startY,dx,dy;

    //触摸开始
    img.addEventListener(&quot;touchstart&quot;, function(event){
        //阻止页面有默认事件
        event.preventDefault();
        //拿到这个手指
        var thefinger = event.touches[0];
        //记录开始触摸的位置
        startX = thefinger.clientX;
        startY = thefinger.clientY;

        console.log(startX,startY);
    }, true);


    //触摸移动
    img.addEventListener(&quot;touchmove&quot;, function(event){
        //阻止页面有默认事件
        event.preventDefault();
        //拿到这个手指
        var thefinger = event.touches[0];
        //记录开始触摸的位置
        dx = thefinger.clientX - startX;
        dy = thefinger.clientY - startY;

        img.style.left = x + dx + &quot;px&quot;;
        img.style.top = y + dy + &quot;px&quot;;
    }, true);


    //触摸结束
    img.addEventListener(&quot;touchend&quot;, function(event){
        //阻止页面有默认事件
        event.preventDefault();
        //改变信号量
        x += dx;
        y += dy;
    }, true);
&lt;/script&gt;
</code></pre><h2 id="3、指滑轮播图"><a href="#3、指滑轮播图" class="headerlink" title="3、指滑轮播图"></a>3、指滑轮播图</h2><p>有人研究过，top、left属性的效率，不如transform属性的效率。所以要进行移动什么东西，多考虑transform属性。<br> <img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx0rlu3s1j20k608sjvc.jpg" alt=""></p>
<p> <img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx0rm1q5wj20r60dy0t5.jpg" alt=""></p>
<p>屏幕旋转的时候触发window的onresize事件，HTML5也提供了事件onorientationchange，但是这个事件不好用，有些浏览器不支持。所以onresize还是不错的。</p>
<h2 id="4、惯性抛掷"><a href="#4、惯性抛掷" class="headerlink" title="4、惯性抛掷"></a>4、惯性抛掷</h2><p>拖拽，但是停不下来，有惯性，会慢慢停下来。主要制作方法有两大种：</p>
<blockquote>
<p>方法1：overflow:auto; 很智能的就把移除的内容就变成可以滑动、抛掷、惯性的了。</p>
</blockquote>
<p>触摸的时候的颜色：</p>
<pre><code>-webkit-tap-highlight-color: rgba(0,0,0,0);
</code></pre><blockquote>
<p>方法2：自己写函数，自己模拟</p>
<p>比如新浪首页：<a href="https://sina.cn/" target="_blank" rel="external">https://sina.cn/</a>:<br> <img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcx0rml1abj20yu07j78q.jpg" alt=""><br>比如我们现在按住了图片，拖拽，松手的地方是-500px，此时它应该根据我们的速度继续让这个盒子运动到终点，每一次都有衰减。</p>
</blockquote>
<p>难点就是在获得用户的抛掷速度上面，我们都是使用touchmove事件的最后两个点的距离间隔。</p>
<p>touchmove事件不是移动1px就触发一次！不是！而是CPU有一个时钟周期，3.5GHz，每秒钟再玩命的检测你的鼠标位置，所以你的鼠标的位置值，不是连续的。</p>
<p>很快的抛掷的最后几个点的横坐标：<br> <img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcx0rmqhbcj208o055748.jpg" alt=""><br>很慢的抛掷的最后几个点的横坐标：<br> <img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx0rmwbu7j20a004r0sn.jpg" alt=""></p>
<p>取最后两个点的间隔，间隔越大表示用户抛掷的速度越快，间隔越小，就是抛掷的慢。</p>
<p>就是用定时器去模拟几次滑动即可，模拟几帧？衰减多快？</p>
<blockquote>
<p>模拟几帧：50帧以上，跟速度成正比</p>
<p>衰减多块：速</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 移动web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 移web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[移动web百分比布局]]></title>
      <url>http://yoursite.com/2016/11/28/title35/</url>
      <content type="html"><![CDATA[<h2 id="1-百分比布局"><a href="#1-百分比布局" class="headerlink" title="1 百分比布局"></a>1 百分比布局</h2><p>手机web页面都没有版心，都是撑满的，这是因为：</p>
<blockquote>
<p>手机本身就小，你再留白边，寸土寸金的地方都浪费了；</p>
<p>APP一般都是撑满的，大家手机上网的时候，也希望撑满。<br>     <img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcx0c1n65zj20so0bi7dt.jpg" alt="">           </p>
</blockquote>
<p>此时就会给制作带来难度，因为尺寸不能写px单位了，比如版心设置为360px，此时iPhone6plus的414视口会看见白色边：<br> <img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx0c20shdj20bq0dfaa4.jpg" alt="">     </p>
<h2 id="2-百分比布局基础"><a href="#2-百分比布局基础" class="headerlink" title="2 百分比布局基础"></a>2 百分比布局基础</h2><p>用百分比设置宽度、高度（绝大多数高度可以写为px）、padding、margin的布局方式，叫做流式布局，页面有弹性，所以也叫弹性布局。</p>
<pre><code>&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;  → div是body的亲儿子，60%指的是窗口宽度的60%
&lt;/body&gt;

&lt;body&gt;
    &lt;div&gt; 
        &lt;main&gt; → 60%指的是div的width的60%，无视div的padding。
            &lt;p&gt;&lt;/p&gt; → 60%指的是main的width的60%，无视div的padding。
        &lt;/main&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre><p>看看padding，都参考父亲的width。注意，竖直方向上的padding也是看父亲的width，而不是height。</p>
<pre><code>&lt;div&gt;
    &lt;main&gt;&lt;/main&gt;  → padding-left:10%;指的是父亲的width的10%，而不是父亲的padding。
                       padding-top:10%;指的是父亲的width的10%，而不是父亲的height。
&lt;/div&gt;
</code></pre><p>再来看border，不能用百分比写。</p>
<pre><code>border: 10% solid #000;
</code></pre><p>再来看margin，一律参考父亲width，不参考父亲的margin和height。<br><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx0c2hty9j206j05w745.jpg" alt=""></p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
    *{
        margin: 0;
        padding: 0;
    }
    div{
        width: 200px;
        height: 600px;
        border: 10% solid #000;
    }
    p{
        margin: 10%;
    }
&lt;/style&gt;
</code></pre><blockquote>
<p>总结：</p>
<p>无论margin、padding、width、height，无论竖直方向还是水平方向，参考的都是父亲的width。</p>
<h2 id="3-边框带来的麻烦"><a href="#3-边框带来的麻烦" class="headerlink" title="3 边框带来的麻烦"></a>3 边框带来的麻烦</h2><p>因为边框不能用百分比来写，所以会带来麻烦：</p>
</blockquote>
<pre><code>&lt;div&gt;
    &lt;p&gt;1&lt;/p&gt;  → float: left;width:50%; border:1px solid red;
    &lt;p&gt;2&lt;/p&gt;  → float: left;width:50%; border:1px solid red;
&lt;/div&gt;
</code></pre><p>p就不能浮动成功，因为总宽度已经是100%多了4个px。</p>
<p>此时边框不能写成百分比，所以就不好减！</p>
<pre><code>div{
    width: 80%;
    height: 200px;
    margin: 0 auto;
    background-color: #eee;
}
p{
    float: left;
    width: 50%;  → 这里不能轻松减去2px
    height: 200px;
    background: orange;
    border: 1px solid #000;
}
</code></pre><p>谁说不能？！CSS3中增加了calc函数：<br>        div{<br>            width: 80%;<br>            height: 200px;<br>            margin: 0 auto;<br>            background-color: #eee;<br>        }<br>        p{<br>            float: left;<br>            width: calc(50% - 2px);  → 谁说不能？！CSS3中增加了calc函数<br>            height: 200px;<br>            background: orange;<br>            border: 1px solid #000;<br>        }</p>
<p>使用的时候一定要在运算符前后加上空格：</p>
<pre><code>calc(50%-2px);
</code></pre><p>应该是</p>
<pre><code>calc(50% - 2px);
</code></pre><p>兼容性不好，至少安卓4.4还不是特别兼容。<br><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx0c2p6igj211y0k10ux.jpg" alt=""></p>
<h2 id="4-CSS3新的盒模型"><a href="#4-CSS3新的盒模型" class="headerlink" title="4 CSS3新的盒模型"></a>4 CSS3新的盒模型</h2><p>我们之前的盒模型padding、border、margin都是外扩的，</p>
<pre><code>div{
    width : 200px; 
    height : 200px;
    padding:10px 20px 30px 40px;
}
</code></pre><p>此时真实面积： 260 × 240 </p>
<p>此时加上：</p>
<pre><code>div{
    width : 200px; 
    height : 200px;
    padding:10px 20px 30px 40px;
    box-sizing:border-box;
}
</code></pre><p>box表示“盒子”，sizing“尺寸”，“border-box”表示border这一圈的宽度、高度。</p>
<p>此时padding就是内减的，而不是外扩的了：</p>
<p>但是border还是在外面：</p>
<pre><code>div{
    width : 200px; 
    height : 200px;
    box-sizing:border-box;
    padding:10px 20px 30px 40px;
    border-top:10px solid red;
    border-left:20px solid red;
    border-right:30px solid red;
    border-bottom:40px solid red;
    margin: 10px;
}
</code></pre>]]></content>
      
        <categories>
            
            <category> 移动web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 移web </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Less语法的使用简介]]></title>
      <url>http://yoursite.com/2016/11/27/title32/</url>
      <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>PHP和HTML的关系就是LESS和CSS的关系。</p>
<p>PHP是超文本预处理器</p>
<pre><code>&lt;h1&gt;好高兴啊，我买了一个iPhone&lt;?php echo 3+4; ?&gt;&lt;/h1&gt;
</code></pre><p>编译为：</p>
<pre><code>&lt;h1&gt;好高兴啊，我买了一个iPhone7&lt;/h1&gt;
</code></pre><p>LESS也是CSS预处理器：</p>
<pre><code>@a : 100px;
div{
  width:@a;
}
编译为：
div{
  width:100px;
}
</code></pre><p>用的时候还是用CSS！浏览器不能直接渲染PHP、不能直接渲染Less，必须转为HTML、CSS之后才能渲染。但是写的时候PHP就是比HTML厉害，Less就是比CSS厉害。</p>
<h2 id="2-浏览器编译"><a href="#2-浏览器编译" class="headerlink" title="2 浏览器编译"></a>2 浏览器编译</h2><p>试着写一个a.less文件：</p>
<pre><code>@a : 200px;

div{
    width:@a;
}
</code></pre><p>@a表示定义一个变量。</p>
<p>Less现在先解决编译的问题，然后再学习语法！</p>
<blockquote>
<p>编译有两种，浏览器编译是最简单的：</p>
</blockquote>
<pre><code>&lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;a.less&quot;&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;js/less.js&quot;&gt;&lt;/script&gt;
</code></pre><p>此时这个js文件就会发出Ajax请求，去请求a.less文件，此时会把返回的文本，用正则表达式进行编译。编译好的内容，直接内嵌到当前HTML文件中。</p>
<h2 id="3、服务器端编译"><a href="#3、服务器端编译" class="headerlink" title="3、服务器端编译"></a>3、服务器端编译</h2><p>使用nodejs编译less。</p>
<p>nodejs是一个js的运行环境，可以让js运行在服务器端。原来js运行在浏览器中，JS现在开始可以和PHP、ASP、JSP平起平坐！</p>
<h2 id="4-less编译工具的安装（手动编译）"><a href="#4-less编译工具的安装（手动编译）" class="headerlink" title="4 less编译工具的安装（手动编译）"></a>4 less编译工具的安装（手动编译）</h2><p>所以有很多人发明了一些工具，发布出去了，发布到了npm的世界中，nodejs package management，nodejs包管理器。安装完node之后，npm已经被自动安装了。我们可以使用npm命令，轻松的从互联网上下载各式各样的nodejs程序。</p>
<blockquote>
<p>npm install命令表示通过连接互联网，从网上下载工具，我们下载的就是less工具。</p>
<p>npm install表示安装，-g表示安装到全局，每个人的全局地址都不一样，请通过</p>
<p>npm root -g来查看</p>
</blockquote>
<p>装好less处理器之后，就能通过lessc命令来编译less文件了。</p>
<h2 id="5-利用Grunt自动监控less文件自动编译"><a href="#5-利用Grunt自动监控less文件自动编译" class="headerlink" title="5 利用Grunt自动监控less文件自动编译"></a>5 利用Grunt自动监控less文件自动编译</h2><p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcw82puhsoj20ut0imdib.jpg" alt=""></p>
<p>Grunt是一个自动化构建工具，依赖NodeJS，说白了就是NodeJS程序而已<br>。<br>要使用Grunt必须现在系统的全局安装grunt-cli程序，cli就是命令行界面的意思。</p>
<p>需要先安装grunt-cli程序，打开系统CMD，输入下面的命令（保证计算机已经联网）：</p>
<blockquote>
<p>npm install -g grunt-cli</p>
<p>不要忘记-g，必须装在全局。</p>
<p>此时，你的神秘全局文件夹中就有了，此时你就可以在CMD中输入grunt命令而不会报错了。</p>
</blockquote>
<p>现在，我们要安装grunt，刚才安装的是grunt-cli，此时来到你的项目文件夹中，注意这句话，来到你的项目文件夹中。</p>
<blockquote>
<p>cd 你的项目路径</p>
</blockquote>
<p>然后在这个文件夹中安装grunt，不要加-g。</p>
<blockquote>
<p>npm install grunt</p>
</blockquote>
<p>此时你的项目文件夹中就会出node_modules文件夹：</p>
<p>接下来我们就要告诉Grunt你要做什么，所以我们建立一个Gruntfile.js的文件，告诉Grunt你的任务。注意这个文件的名字不能换！</p>
<p>下面就是这个Gruntfile.js的代码清单：<br> 配置任务，列出了三个任务：pkg、less、watch。pkg任务是必须写的；less任务就是编译less的任务，watch任务就是监控任务。</p>
<p>部分在罗列插件。grunt-contrib-less、grunt-contrib-watch。</p>
<p>部分是事务队列、清单。</p>
<pre><code>module.exports = function (grunt) {
//任务配置,所有插件的配置信息
grunt.initConfig({
    pkg: grunt.file.readJSON(&apos;package.json&apos;),
    //less插件配置
    less: {
        main: {
            expand: true,
            src: [&apos;less/*.less&apos;],   //核心语句，编译less
            dest: &apos;desc&apos;,
            ext: &apos;.css&apos;
        },
        dev: {
            options: {
                compress: true,
                yuicompress:false
            }
        }
    },
    watch: {
        scripts: {
            files: [&apos;less/*.less&apos;],
            tasks: [&apos;less&apos;]
        }
    }
});

//告诉grunt我们将使用插件
grunt.loadNpmTasks(&apos;grunt-contrib-less&apos;);
grunt.loadNpmTasks(&apos;grunt-contrib-watch&apos;);

//告诉grunt当我们在终端中输入grunt时需要做些什么(注意先后顺序)
grunt.registerTask(&apos;default&apos;, [&apos;less&apos;,&apos;watch&apos;]);
};
</code></pre><p>在项目文件夹里面再次放入一个package.json的文件：</p>
<pre><code>{
  &quot;name&quot;: &quot;text&quot;,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;devDependencies&quot;: {
  &quot;grunt&quot;: &quot;~0.4.5&quot;,
  &quot;grunt-contrib-less&quot;: &quot;~0.10.0&quot;
  }
}
</code></pre><p>插件还没有装呢！所以要在项目文件夹中，</p>
<pre><code>npm install grunt-contrib-less

npm install grunt-contrib-watch
</code></pre><p>如果全部操作都正确的话，此时你可以在项目文件的CMD中，输入grunt一个单词，可以实时监控你的less文件夹中的less文件。实时编译到dest文件夹中。</p>
<h2 id="6、Less语法"><a href="#6、Less语法" class="headerlink" title="6、Less语法"></a>6、Less语法</h2><p><a href="http://less.bootcss.com/" target="_blank" rel="external">http://less.bootcss.com/</a></p>
<p>变量：</p>
<pre><code>@hong : rgb(252,0,0);

div{
    background: @hong;
    border-top: 1px solid @hong;
    box-shadow: 1px 1px 1px 1px @hong;
}
</code></pre><p>选择器也可以用变量：</p>
<pre><code>@dahezideleiming : container;
.@{dahezideleiming}{
    width:100px;
}
</code></pre><p>文件路径：</p>
<pre><code>@imagesURL : &quot;../images&quot;;
background: url(&quot;@{imagesURL}/1.jpg no-repeat center center&quot;);
</code></pre><p>导入文件：</p>
<pre><code>@import &quot;01.less&quot;;
@import &quot;02.less&quot;;
</code></pre><p>属性也能用变量：</p>
<pre><code>@property: color;

.widget {
  @{property}: #0ee;
  background-@{property}: #999;
}
</code></pre><p>混合：</p>
<pre><code>.xiao{
    width: 200px;
    height: 200px;
}
.cu{
    font-weight: 500;
}
.xian{
    text-decoration: underline;
}

.zhongyao{
    .cu();
    .xian();
}
</code></pre><p>嵌套：</p>
<pre><code>nav{
    width:100px;
    height:100px;

    ul{
        float:left;
    }
}
</code></pre><p>可以接受参数，类似一个函数：</p>
<pre><code>.yuanjiao(@dushu){
    -webkit-border-radius: @dushu;
    -moz-border-radius: @dushu;
    -ms-border-radius: @dushu;
    -o-border-radius: @dushu;
    border-radius: @dushu;
}
</code></pre><p>when逻辑判断：</p>
<pre><code>.haha(@a) when (@a &gt; 100){
    width:300px;
    height: 300px;
}

.haha(@a) when (@a &lt; 100){
    width:200px;
    height: 200px;
}

div{
    .haha(900);
}
</code></pre><p>编译之后：</p>
<pre><code>div {
  width: 300px;
  height: 300px;
}
</code></pre><p>循环语句：</p>
<pre><code>.zihao(@n) when (@n =&lt; 60) {
  .fs@{n}{
    font-size:1px * @n;
  }
  .zihao(@n + 1);
}

.zihao(10);
</code></pre>]]></content>
      
        <categories>
            
            <category> Less </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Less </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP操作SQL语言]]></title>
      <url>http://yoursite.com/2016/11/26/title34/</url>
      <content type="html"><![CDATA[<h2 id="1-SQL语言"><a href="#1-SQL语言" class="headerlink" title="1 SQL语言"></a>1 SQL语言</h2><p>数据库的增删改查操作，CRUD操作。</p>
<blockquote>
<p>C create增加，创建</p>
<p>R read 查找，访问</p>
<p>U update 更改</p>
<p>D delete 删除<br>要使用SQL语言对数据库进行CRUD操作。SQL就是Structure Query Language结构化查询语言。是操作数据库的语言，注意，这个语言是使用的软件平台无关。比如你用ASP、PHP、JSP都要使用相同的SQL语言。</p>
</blockquote>
<h2 id="2-查询"><a href="#2-查询" class="headerlink" title="2 查询"></a>2 查询</h2><p>看好SQL语句在哪里输入：<br> <img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcwztx3qjij20tb0hctax.jpg" alt=""></p>
<p>查询所有表中的条目：</p>
<blockquote>
<p>SELECT * FROM 表名字<br> <img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcwztxaff3j20di03rmx7.jpg" alt=""><br>比如：</p>
</blockquote>
<p>查询banji0910表中的所有条目：</p>
<blockquote>
<p>SELECT * FROM banji0910<br> <img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcwztxfe8rj20bc03xjrd.jpg" alt=""></p>
</blockquote>
<p>查询banji0910表中的所有条目的姓名：</p>
<blockquote>
<p>SELECT xingming FROM banji0910<br> <img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcwztxnwzgj20de03pq2z.jpg" alt=""></p>
</blockquote>
<p>可以后缀WHERE子句，查找banji0910中所有男生</p>
<blockquote>
<p>SELECT * FROM banji0910 WHERE xingbie = “男”</p>
</blockquote>
<p>可以加上与或逻辑，AND表示且，OR表示或查找banji0910中所有男生且年龄大于11岁</p>
<p>SELECT * FROM banji0910 WHERE xingbie = ‘男’ AND nianling 11</p>
<p>注意，字符串用单引号包裹；注意，等号就是相等的意思。</p>
<p>可以排序，查找banji0910中所有男生，并按年龄倒叙：</p>
<blockquote>
<p>SELECT * FROM banji0910 WHERE xingbie = “男” ORDER BY nianling DESC</p>
</blockquote>
<h2 id="3-增加条目"><a href="#3-增加条目" class="headerlink" title="3 增加条目"></a>3 增加条目</h2><p>用INSERT语句插入条目：</p>
<blockquote>
<p>INSERT INTO banji0910 VALUE (‘小青’,9,’女’,324234);<br> <img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcwztxtdbzj20e8059dfu.jpg" alt=""></p>
</blockquote>
<p> <img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcwzty0gstj20of06lt8z.jpg" alt=""><br>如果不是想插入所有的字段，必须罗列所有的字段：</p>
<blockquote>
<p>INSERT INTO banji0910 (xingming,nianling,xingbie) VALUE (‘小宝’,9,’男’)</p>
</blockquote>
<h2 id="3-改变条目"><a href="#3-改变条目" class="headerlink" title="3 改变条目"></a>3 改变条目</h2><p>更改小红的性别为男：</p>
<blockquote>
<p>UPDATE banji0910 SET xingbie = “男” WHERE xingming = “小红”<br> <img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcwzty7i4fj20eb04xjrf.jpg" alt=""></p>
</blockquote>
<p>更改所有年龄大于等于10的人性别为女：</p>
<blockquote>
<p>UPDATE banji0910 SET xingbie = “女” WHERE nianling &gt;= 10</p>
</blockquote>
<h2 id="4-删除条目"><a href="#4-删除条目" class="headerlink" title="4 删除条目"></a>4 删除条目</h2><p>删除小明：</p>
<blockquote>
<p>DELETE FROM banji0910 WHERE xingming = “小明”</p>
</blockquote>
<p>删除所有女生：</p>
<blockquote>
<p>DELETE FROM banji0910 WHERE xingbie = ‘女’</p>
</blockquote>
<h2 id="5-SQL的备份和恢复"><a href="#5-SQL的备份和恢复" class="headerlink" title="5 SQL的备份和恢复"></a>5 SQL的备份和恢复</h2><p>我的数据库想给你，不能通过U盘直接把数据库拷贝走，因为数据库在计算机的多个文件夹中分布。<br>只能在我的电脑里面把数据库备份为SQL文件，传递给你SQL文件，你执行SQL文件就行了。</p>
<p>备份数据库为SQL文件<br> <img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcwztydu2hj20z90ikgov.jpg" alt=""></p>
<p>从SQL文件恢复：<br> <img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcwztyojegj20rz0jjjxq.jpg" alt=""></p>
<blockquote>
<p>记住要刷新</p>
</blockquote>
<h2 id="6、PHP操作数据库"><a href="#6、PHP操作数据库" class="headerlink" title="6、PHP操作数据库"></a>6、PHP操作数据库</h2><p>数据库自己用没有意义，可以提供给多种语言使用，SQL就是中间的一层。</p>
<p>LAMP沆瀣一气，Linux、Apache、MySQL、PHP，他们四个非常亲，彼此非常打通。PHP中仅仅几条语句就能操作数据库：</p>
<pre><code>&lt;?php
    //链接数据库。参数：数据库地址、用户名、密码
    mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;);
    //选择操作哪个数据库
    mysql_select_db(&quot;student&quot;);
    //识别中文
    mysql_query(&quot;SET NAMES UTF8&quot;);
    //写SQL语句
    $sql = &quot;INSERT INTO banji0910 VALUE (&apos;宝宝&apos;,12,&apos;男&apos;,1932434)&quot;;
    //执行SQL
    mysql_query($sql);
?&gt;
</code></pre><p>使用了里面的诸多内置函数，他们都是mysql<em>开头的。php就是这样，把内置函数都加上了前缀，比如数组的方法，都是array</em>开头，关于数据库的函数都是mysql_开头。</p>
<blockquote>
<p>mysql_connect : 链接数据库</p>
<p>mysql_select_db : 选择数据库</p>
<p>mysql_query : 执行查询</p>
</blockquote>
<p>比较复杂的是，从数据库中读取数据：</p>
<pre><code>&lt;?php
    mysql_connect(&quot;localhost&quot;,&quot;root&quot;,123456);
    mysql_select_db(&quot;student&quot;);
    mysql_query(&quot;SET NAMES UTF8&quot;);

    //准备一条sql
    $sql = &quot;SELECT * FROM banji0910&quot;;
    //执行sql语句，此时的结果是类数组对象
    $result = mysql_query($sql);

    //把结果转为数组
    $row = mysql_fetch_array($result);
    //输出
    print_r($row);
    //把结果转为数组
    $row = mysql_fetch_array($result);
    //输出
    print_r($row);
    //把结果转为数组
    $row = mysql_fetch_array($result);
    //输出
    print_r($row);
?&gt;
</code></pre><p>如果是SELECT语句执行，此时的结果是类数组对象。必须使用mysql_fetch_array()来转为数组。此时比较坑的是，转的时候只能转一条，此时如果想转第二条，必须再来一次mysql_fetch_array();<br>执行完毕SQL之后拿到类数组对象，我们一般来说用while语句去循环得到所有数组：</p>
<pre><code>&lt;?php
    mysql_connect(&quot;localhost&quot;,&quot;root&quot;,123456);
    mysql_select_db(&quot;student&quot;);
    mysql_query(&quot;SET NAMES UTF8&quot;);

    //准备一条sql
    $sql = &quot;SELECT * FROM banji0910&quot;;
    //执行sql语句，此时的结果是类数组对象
    $result = mysql_query($sql);

    //把结果转为数组
    while($row = mysql_fetch_array($result)){
        //输出
        print_r($row);
    }
?&gt;
</code></pre><p> <img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcwzyt7kp5j20y10acwfe.jpg" alt=""></p>
<p>注意，每个$row都是一个数组，并且里面有数字下标，也有别名下标。</p>
<pre><code>&lt;?php
    mysql_connect(&quot;localhost&quot;,&quot;root&quot;,123456);
    mysql_select_db(&quot;student&quot;);
    mysql_query(&quot;SET NAMES UTF8&quot;);

    //准备一条sql
    $sql = &quot;SELECT * FROM banji0910&quot;;
    //执行sql语句，此时的结果是类数组对象
    $result = mysql_query($sql);

    //把结果转为数组
    while($row = mysql_fetch_array($result)){
        //输出
        echo $row[&quot;xingming&quot;] . &quot;&lt;br /&gt;&quot;;
    }
?&gt;
</code></pre><p>主键的概念，姓名能够重复，但是id不能重复。id就是主键，不重复的字段就是主键。<br> <img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcwzytcytwj211y0epdhx.jpg" alt=""></p>
<p>查看信息的超级链接，是样子写的：</p>
<pre><code>&lt;td&gt;&lt;a href=&quot;ziliao.php?id=&lt;?php echo $row[&apos;id&apos;]; ?&gt; &quot;&gt;查看信息&lt;/a&gt;&lt;/td&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> SQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[PHP后台语言介绍]]></title>
      <url>http://yoursite.com/2016/11/25/title31/</url>
      <content type="html"><![CDATA[<h2 id="1-从一个实验说开去"><a href="#1-从一个实验说开去" class="headerlink" title="1 从一个实验说开去"></a>1 从一个实验说开去</h2><p>我们做一个实验，新建一个php文件（就是由txt变的）：</p>
<pre><code>&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;

    &lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h1&gt;好高兴啊，我买了一个iPhone&lt;?php echo 1+2+3+1;?&gt;啊，真开心！&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>我们直接在本地拖到浏览器里面查看，我么你发现红色部分浏览器没有渲染：<br><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcw7gywrb0j20j504tt8t.jpg" alt=""></p>
<p>这是因为浏览器把&lt;?php ?&gt;当做注释了：<br> <img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcw7gz2ngkj20fp06njri.jpg" alt=""></p>
<p>此时把1.php上传到服务器上，然后通过浏览器输入网址访问发现这个7被算出来了。此时我们查看源代码：<br> <img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcw7gz8mj1j20ep06q74e.jpg" alt=""></p>
<p>你会发现之前的&lt;?php ?&gt;里面的内容，变成了7，此时你根本察觉不到这个7从何而来。</p>
<h2 id="2-后台语言"><a href="#2-后台语言" class="headerlink" title="2 后台语言"></a>2 后台语言</h2><p>后台语言就是执行在服务器上的语言，以php为例，在服务器上执行&lt;?php ?&gt;里面的语句，这个操作我们称为“预处理”。当php执行完毕之后，会发回给浏览器纯的、平的HTML文件。<br> <img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcw7gziih3j20o20a6tb5.jpg" alt=""></p>
<p> <img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcw7gzoh9kj20nk0au0v8.jpg" alt=""></p>
<p> <img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcw7gzyubxj20nk09976q.jpg" alt=""></p>
<p> <img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcw7h07vasj20o90amq5b.jpg" alt=""><br>PHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。它是一个后台语言，后台语言：<br>● 在服务器上运行<br>● 运行之后，发给浏览器就是不带任何后台标记的纯HTML了<br>● 可以操作数据库</p>
<p>常见后台语言：PHP、JSP、ASP、.net、python、scala、node.js等等。</p>
<h2 id="3、在自己的电脑上运行PHP"><a href="#3、在自己的电脑上运行PHP" class="headerlink" title="3、在自己的电脑上运行PHP"></a>3、在自己的电脑上运行PHP</h2><p>PHP是后台语言，必须运行在服务器上，所以我们不便于调试，只能让自己的电脑也变为服务器。</p>
<p>Apache是世界上第一名的服务器软件，如果你安装了Apache你的电脑就是服务器了。</p>
<p>光安装Apache没有用，还要安装PHP的语言解析引擎。</p>
<p>MySQL是著名的数据库之一，免费开源。</p>
<p>中国人发明了三合一的安装包，叫做phpnow或者WampServer。我们学习phpnow，如果你电脑装不上phpnow，此时就安装wampserver。</p>
<h2 id="4-运行php"><a href="#4-运行php" class="headerlink" title="4 运行php"></a>4 运行php</h2><p>所有的php文件必须放到根目录运行，一定要通过127.0.0.1来运行，而不能直接把php拖入浏览器。</p>
<p> 4.1 壳子<br>所有的php程序要写在：</p>
<pre><code>&lt;?php ?&gt;
</code></pre><p>的壳子里面。</p>
<p> 4.1 echo输出</p>
<pre><code>&lt;h1&gt;我买了一个iPhone&lt;?php echo 3.5 * 2; ?&gt;我很开心&lt;/h1&gt;
</code></pre><p>注意echo是一个关键字，不是函数，所以不要加圆括号：</p>
<pre><code>echo();
</code></pre><p>注意，php要求所有语句必须有分号结尾，没有分号致命。和JS一样，所有的字符串都要有引号包裹。</p>
<pre><code>&lt;p&gt;&lt;?php echo &quot;你好&quot;; ?&gt;&lt;/p&gt;
</code></pre><p> 4.3 变量<br>PHP中的变量不需要定义，可以直接使用，变量必须以$开头，剩余部分的命名规范和JS一样。</p>
<pre><code>&lt;?php
    $a = 100;
    echo $a;
?&gt;
</code></pre><p>注释和js一样。</p>
<pre><code>&lt;?php
    // $a = 100;
    // $b = 200;
    // echo $a + $b;
?&gt;
</code></pre><p>连字符是.而不是加号。<br>    &lt;?php<br>        $year = 2016;<br>        echo “今年是” . $year . “年”;<br>    ?&gt;</p>
<p>而在双引号中，用{$}的形式，可以不用连字符，来拼接变量和字符串：</p>
<pre><code>echo &quot;今年是{$year}年&quot;;
</code></pre><p> 4.4 for语句、if语句、switch语句、while、do while语句<br>   和js一样一样的,讲讲壳子：</p>
<pre><code>&lt;?php
    for($i = 0 ; $i &lt; 100 ; $i++){
?&gt;
        &lt;p&gt;★&lt;/p&gt;
&lt;?php
    }
?&gt;
</code></pre><p>页面上出现100个星星</p>
<p>4.5 函数<br>和js一样一样。php中的函数不是构造函数，不能被new调用。</p>
<p>编写函数，检查一个数字是不是质数，并且用数字88来测试：</p>
<pre><code>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;?php
    function checkZhishu($num){
        $count = 0;
         for($j = 1 ; $j &lt;= $num ; $j++){
             if($num % $j == 0){
                 $count ++;
             }
         }
         if($count == 2){
             return true;
         }else{
             return false;
         }
    }

    if(checkZhishu(88)){
        echo &quot;是&quot;;
    }else{
        echo &quot;不是&quot;;
    }
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p> 4.6 数组<br>array()函数创建数组：</p>
<pre><code>&lt;?php
    $arr = array(&quot;东风&quot;,&quot;二条&quot;,&quot;大饼&quot;,&quot;幺鸡&quot;,&quot;六万&quot;);
    echo $arr[3];
?&gt;
</code></pre><p>php是所有语言中，方法第一多的语言！</p>
<p>数组可以有别名，和js的json很像：</p>
<pre><code>&lt;?php
       $arr = array(&quot;xingming&quot; =&gt; &quot;小明&quot; , &quot;age&quot; =&gt; 12 , &quot;sex&quot; =&gt; &quot;男&quot;);
    echo $arr[&quot;sex&quot;];
?&gt;
</code></pre><p>输出男。</p>
]]></content>
      
        <categories>
            
            <category> PHP </category>
            
        </categories>
        
        
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Canvas基本用法]]></title>
      <url>http://yoursite.com/2016/11/24/title29/</url>
      <content type="html"><![CDATA[<h2 id="1、Canvas概述"><a href="#1、Canvas概述" class="headerlink" title="1、Canvas概述"></a>1、Canvas概述</h2><blockquote>
<p> Canvas和Flash的思路完全不一样，Flash是上屏幕之后还是对象，编程语言叫做Action Script也是ECMAScript范畴。Canvas上屏幕之后像素化了，再也不能得到这个对象了，所以要想让这个元素运动，必须擦除整个屏幕、重绘这个元素。Canvas更流畅，手机端也嗷嗷流畅。</p>
</blockquote>
<p>canvas是一个双标签，里面的内容是不支持canvas浏览器显示的内容：</p>
<pre><code>&lt;canvas width=&quot;800&quot; height=&quot;600&quot;&gt;对不起，你的浏览器不支持画布，请升级浏览器！&lt;/canvas&gt;
宽度、高度写在标签里面，如果写在css中，就变形、扭曲了。
</code></pre><p>编程：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
   //得到画布标签
   var myCanvas = document.querySelector(&quot;#myCanvas&quot;);
   //上下文，就相当于打开Photoshop之后让你新建画布
   var ctx = myCanvas.getContext(&quot;2d&quot;);
   //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。
   ctx.fillStyle = &quot;lightseagreen&quot;;
   ctx.fillRect(100,100,300,200);
&lt;/script&gt;
</code></pre><p>坐标系：</p>
<p> <img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx1bbhka6j211y0kiwfj.jpg" alt=""></p>
<blockquote>
<pre><code>API：
ctx.fillStyle = &quot;red&quot;;   //设置填充颜色
ctx.fillRect(100,100,300,200);  //绘制一个填充矩形
</code></pre></blockquote>
<h2 id="2、笔触"><a href="#2、笔触" class="headerlink" title="2、笔触"></a>2、笔触</h2><p>填充笔触也叫作“描边”，Canvas中的任何形状都是由这两个部分组成的。</p>
<p>笔触在canvas中视为一个“Path”的实例，必须stroke之后才能上屏幕；填充用fill才能上屏幕。</p>
<p>制作一个笔触需要用到的API：</p>
<blockquote>
<pre><code>ctx.beginPath();  //开始绘制路径
ctx.closePath();  //自动封闭路径
ctx.moveTo(100,200);  //将画笔移动到某一个点
ctx.lineTo(200,200);  //用画笔划线，此时的参数是终点位置，起点就是画笔此时的位置
ctx.stroke();  //划线
</code></pre></blockquote>
<p>比如：<br>    <script type="text/javascript"><br>       //得到画布标签<br>       var myCanvas = document.querySelector(“#myCanvas”);<br>       //上下文，就相当于打开Photoshop之后让你新建画布<br>       var ctx = myCanvas.getContext(“2d”);<br>       //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。<br>       //开始绘制路径<br>       ctx.beginPath();<br>       ctx.moveTo(100,100);<br>       ctx.lineTo(300,300);<br>       ctx.lineTo(600,300);<br>       ctx.moveTo(600,400);<br>       ctx.lineTo(700,400);<br>       ctx.stroke();<br>    </script></p>
<p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx1bboz42j20po0het9l.jpg" alt=""><br>在划线之前可以设置线的宽度和颜色：</p>
<blockquote>
<pre><code>ctx.lineWidth = &quot;10&quot;;
ctx.strokeStyle = &quot;red&quot;;
ctx.stroke();
</code></pre></blockquote>
<p><img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcx1bbwuibj20n60ge3yn.jpg" alt=""><br>当ctx上已经有一些path之后，此时调用fill()将自动填充。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
   //得到画布标签
   var myCanvas = document.querySelector(&quot;#myCanvas&quot;);
   //上下文，就相当于打开Photoshop之后让你新建画布
   var ctx = myCanvas.getContext(&quot;2d&quot;);
   //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。
   //开始绘制路径
   ctx.beginPath();
   ctx.moveTo(100,100);
   ctx.lineTo(300,300);
   ctx.lineTo(600,300);
   ctx.closePath();
   ctx.lineWidth = &quot;10&quot;;
   ctx.strokeStyle = &quot;red&quot;;
   ctx.stroke();
   ctx.fillStyle = &quot;lightseagreen&quot;;
   ctx.fill();
&lt;/script&gt;
</code></pre><p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx1bc2k68j20nv0gzjrj.jpg" alt=""><br>绘制新的形状的时候，要重新beginPath()</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
   //得到画布标签
   var myCanvas = document.querySelector(&quot;#myCanvas&quot;);
   //上下文，就相当于打开Photoshop之后让你新建画布
   var ctx = myCanvas.getContext(&quot;2d&quot;);
   //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。
   //开始绘制路径
   ctx.beginPath();
   ctx.moveTo(100,100);
   ctx.lineTo(300,300);
   ctx.lineTo(600,300);
   ctx.closePath();
   ctx.lineWidth = &quot;10&quot;;
   ctx.strokeStyle = &quot;red&quot;;
   ctx.stroke();
   ctx.fillStyle = &quot;lightseagreen&quot;;
   ctx.fill();

   ctx.beginPath();
   ctx.moveTo(600,100);
   ctx.lineTo(600,200);
   ctx.lineTo(750,200);
   ctx.lineTo(790,40);
   ctx.closePath();
   ctx.fillStyle = &quot;orange&quot;
   ctx.fill();
   ctx.stroke();
&lt;/script&gt;
</code></pre><p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx1bc7xffj20nb0gaweo.jpg" alt=""><br>fillRect()是一个快捷方法，让你省略了beginPath、moveTo、lineTo。所以fillRect    (100,100,300,200)等价于：</p>
<pre><code>ctx.move(100,100);
ctx.lineTo(400,100);
ctx.lineTo(400,300);
ctx.lineTo(100,300);
ctx.closePath();
ctx.fill();
</code></pre><h2 id="3、弧和圆形画弧线"><a href="#3、弧和圆形画弧线" class="headerlink" title="3、弧和圆形画弧线"></a>3、弧和圆形画弧线</h2><p>用arc方法，它属于Path。所以画弧之前要beginPath()一下。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
   //得到画布标签
   var myCanvas = document.querySelector(&quot;#myCanvas&quot;);
   //上下文，就相当于打开Photoshop之后让你新建画布
   var ctx = myCanvas.getContext(&quot;2d&quot;);
   //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。
   //开始绘制路径
   ctx.beginPath();
   ctx.arc(200,200,100,0,1,true);  //圆心坐标200,200。100是半径。0开始角度，1终止角度，true表示逆时针
   ctx.stroke();
&lt;/script&gt;
</code></pre><p>坐标系，Canvas中的角度都是弧度制，1弧度等于57.3度：</p>
<p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fcx1bcentqj20nv0ght92.jpg" alt=""></p>
<p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx1bckjkuj20nv0ght92.jpg" alt=""></p>
<p><img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcx1bcq6ltj20or0gjwer.jpg" alt=""></p>
<p>完整的圆终止角度就是Mathi.PI * 2</p>
<pre><code>ctx.arc(200,200,200,0,Math.PI*2,false);
</code></pre><p>画20个同心圆。</p>
<pre><code>for(var i = 10 ; i &lt;= 400 ; i+=5){
   ctx.beginPath();
   ctx.arc(200,200,i,0,Math.PI * 2,true);
   ctx.strokeStyle = &quot;rgb(&quot; + i + &quot;,&quot; + i + &quot;,&quot; + i + &quot;)&quot;;
   ctx.stroke();
}
</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors</a></p>
<h2 id="4、文字fillText函数"><a href="#4、文字fillText函数" class="headerlink" title="4、文字fillText函数"></a>4、文字fillText函数</h2><p>用来写字，参数是：文字内容、坐标位置</p>
<pre><code>ctx.fillText(&quot;文字内容&quot;,100,100);
</code></pre><p>可以使用font属性来调整字号和字形：</p>
<pre><code>ctx.font = &quot;50px 微软雅黑&quot;;
ctx.fillText(&quot;你好&quot;,100,100);
</code></pre><h2 id="5、new-Image"><a href="#5、new-Image" class="headerlink" title="5、new Image()"></a>5、new Image()</h2><p>使用图片使用图片有一个固定的语法，必须new Image()然后设置src，监听load事件，使用ctx.drawImage()函数上画布。</p>
<pre><code>var img = new Image();
img.src = &quot;images/0.jpg&quot;;

img.onload = function(){
ctx.drawImage(img,100,100);
}
</code></pre><p>ctx.drawImage()里面的参数是图片对象、左上角的坐标。<br><img src="http://wx2.sinaimg.cn/mw690/a579329cly1fcx1bczk7nj20na0gggxm.jpg" alt=""></p>
<p>ctx.drawImage()里面可以有四个数字参数，增加了宽度、高度的设置，此时图片会被扭曲：</p>
<pre><code>var img = new Image();
img.src = &quot;images/0.jpg&quot;;

img.onload = function(){
    ctx.drawImage(img,100,100,250,80);
}
</code></pre><p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx1h54rtrj20oi0g8abu.jpg" alt=""><br>如果要使用切片，就是9个参数：</p>
<pre><code>var img = new Image();
img.src = &quot;images/0.jpg&quot;;

img.onload = function(){
    ctx.drawImage(img,168,150,126,141,100,100,300,300);
}
</code></pre><p>红色部分描述的是切片的事儿：</p>
<p><img src="http://wx4.sinaimg.cn/mw690/a579329cly1fcx1h5l8fbj211t0kfgzx.jpg" alt=""></p>
<p>蓝色部分是上屏幕之后的事儿：</p>
<p><img src="http://wx3.sinaimg.cn/mw690/a579329cly1fcx1h5verjj20oy0gpn3y.jpg" alt=""><br>公式：</p>
<pre><code>ctx.drawImage(img,切片x,切片y,切片w,切片h,上屏x,上屏y,上屏w,上屏h);
</code></pre><h2 id="6、运动"><a href="#6、运动" class="headerlink" title="6、运动"></a>6、运动</h2><p>canvas中元素不能运动的，因为上屏幕之后就再也得不到它了，没有任何变量能够持有一个:</p>
<pre><code>var box = ctx.fillRect(100,100,200,200);
</code></pre><p>必须重绘一个新的矩形！利用视觉暂留，形成运动！</p>
<p>清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 →清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 →……</p>
<blockquote>
<p>清屏：</p>
</blockquote>
<pre><code>ctx.clearRect(0,0,800,600);
</code></pre><p>实际上是清除一个矩形区域，我们一般清除整个画布。</p>
<p>面向对象制作运动，结构：</p>
<pre><code>function Circle(){

}
Circle.prototype.render = function(){

}
Circle.prototype.update = function(){

}

var yuan = new Circle();

setInterval(function(){
    ctx.clearRect(0,0,800,600);
    yuan.update();
    yuan.render();
},20);
</code></pre><p>每一帧都要更新演员、渲染演员。只要这个东西是演员，它必须提供update、render方法。</p>
<p>面向接口编程，接口就是具有一定方法的类的集合。说白了，就比如说很多类都有render、update方法，此时Actor（演员）就是一个接口，Circle和Fang类都是这个接口的实现。“接口就是类的类”。</p>
<p>说白了：我们要制作Actor类，Actor类提供update、render方法，并且会把自己放入总数组中。所有演员类，都必须继承这个类，重写Actor和render方法。</p>
]]></content>
      
        <categories>
            
            <category> Canvas </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Canvas </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[游戏开发中canvas常见要点]]></title>
      <url>http://yoursite.com/2016/11/24/title30/</url>
      <content type="html"><![CDATA[<h2 id="1-游戏图片、音乐资源的管理"><a href="#1-游戏图片、音乐资源的管理" class="headerlink" title="1 游戏图片、音乐资源的管理"></a>1 游戏图片、音乐资源的管理</h2><p>不管游戏中有多少元素在运动，游戏仅仅有1个定时器，这1个定时器让所有的演员更新、渲染。<br>实际上，一个游戏需要大量的图片，只有当所有图片都load了，游戏才能开始。换句话说，只有当所有图片都load了，主循环setInterval()才能启动。</p>
<p>所以我们的思路就是用JSON imagesObj 存放所有的资源图片的名字，用循环语句for..in…去创建他们的Image对象，然后监听他们的load事件，load一个计数器加1，当load完一个图片的时候，计数器正好等于了数组总长度，此时表示所有图片加载完毕。比较巧妙的是，我们创建了一个R对象，这个对象和imagesObj 的key是一样的，但是v是图片的Image实体，用图片的时候，要通过R打点来找到图片。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
   //得到画布标签
   var myCanvas = document.querySelector(&quot;#myCanvas&quot;);
   //上下文，就相当于打开Photoshop之后让你新建画布
   var ctx = myCanvas.getContext(&quot;2d&quot;);
   //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。

   //如果要使用图片，必须要创建一个Image的实例，然后监听这个img的load事件
   //只有load的图片才能上画布
   var imagesObj = {
       &quot;shibing&quot; : &quot;images/shibing.png&quot;,
       &quot;baozha&quot; : &quot;images/baozha.png&quot;
   };

   //图片资源对象，k和imagesObj是一样的，v是真正的图片Image对象
   var R = {};

   //已经加载好的图片个数
   var count = 0;

   var cutx = 0;
   var baozhaxuhao = 0;

   for(var k in imagesObj){
       //创建图片节点
       R[k] = new Image();
       //设置src
       R[k].src = imagesObj[k];
       //监听是否load
       R[k].onload = function(){
          count++;
          if(count === 2){
              //全部都加载完毕
              setInterval(function(){
                 cutx ++;
                 baozhaxuhao++;
                 if(cutx &gt; 7){
                     cutx = 0;
                 }
                 if(baozhaxuhao &gt; 11){
                     baozhaxuhao = 0;
                 }

                 //清屏
                 ctx.clearRect(0, 0, 800, 600);

                 ctx.drawImage(R.shibing,120 * cutx,150 * 3,120,150,100,100,120,150);

                 ctx.drawImage(R.baozha,192 * (baozhaxuhao % 5),192 * parseInt(baozhaxuhao / 5),192,192,100,100,192,192);
              },20);
           }
       }
   }
&lt;/script&gt;
</code></pre><h2 id="2、Game类Game类就是中介者模式中的中介者-。"><a href="#2、Game类Game类就是中介者模式中的中介者-。" class="headerlink" title="2、Game类Game类就是中介者模式中的中介者 ##。"></a>2、Game类Game类就是中介者模式中的中介者 ##。</h2><p>中介者就是全局变量！比如我们以前</p>
<pre><code>var idx = 10;
</code></pre><p>信号量，就是全局变量，现在把这个量放入一个类的实例身上，此时这个类就是中介者。</p>
<p>信号量在中介者身上：</p>
<pre><code>var game = new Game();
game.idx = 10;
</code></pre><p>以后所有的元素都是Game类new出来的，我们只需要new出中介者，其他元素都是Game帮我们new出来的。</p>
<p>其他元素如果要互相通信，要通过Game类：</p>
<pre><code>game.bird.y
</code></pre><p>在HTML5游戏中，Game类还将有：主循环、游戏资源管理两个任务。</p>
<p>图片资源管理利用两个对象，RObj和R对象。Robj就是Ajax请求来的文本转为的对象，v是路径； R对象的拥有Robj相同的k，但是v是真实对象：</p>
<h2 id="3-背景类背景类的实例化"><a href="#3-背景类背景类的实例化" class="headerlink" title="3 背景类背景类的实例化"></a>3 背景类背景类的实例化</h2><p>在Game的start函数里面。而start函数的调用的前提是所有资源已经加载完毕了。说白了，背景类里面可以直接使用图片资源。</p>
<p>canvas里面也有猫腻，也有模式。渲染三张，目的是无缝连续滚动，当猫腻图的左边框到达0点，就拉回来。</p>
<h2 id="4、cancas变形"><a href="#4、cancas变形" class="headerlink" title="4、cancas变形"></a>4、cancas变形</h2><p>canvas中，提供了变形属性，需要注意的是，所有的变形都是针对画布上下文ctx对象的，而不是某一个要绘制的元素的。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
   var mycanvas = document.getElementById(&quot;mycanvas&quot;);

   var ctx = mycanvas.getContext(&quot;2d&quot;);

   //保存当前的上下文状态
   ctx.save();
    //移动坐标系
   ctx.translate(100,100);
   //画圆
   ctx.fillStyle = &quot;blue&quot;;
   ctx.beginPath();
   ctx.arc(0,0,50,0,Math.PI * 2,true);
   ctx.fill();
   //恢复上下文存档状态
   ctx.restore();

   //画方块
   ctx.fillRect(100, 100, 100, 100);
&lt;/script&gt;
</code></pre><p>坐标系还可以通过</p>
<pre><code>ctx.rotate(1);
</code></pre><p>渲染1弧度。同样的，旋转的是整个坐标系，而不是某一个元素。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
   var mycanvas = document.getElementById(&quot;mycanvas&quot;);

   var ctx = mycanvas.getContext(&quot;2d&quot;);

   ctx.rotate(1); //1弧度，顺时针
   ctx.fillStyle = &quot;orange&quot;;
   ctx.fillRect(100, 100, 100, 100);
&lt;/script&gt;
</code></pre><p>如果想要让一个元素以自己的几何中心点旋转，此时需要：</p>
<blockquote>
<p>① 先让坐标系的原点移动到它的中心点，此时盒子的渲染位置就是负的自己的宽度的一半，负的自己的高度的一半。</p>
<p>② 旋转</p>
<p>公式：</p>
<p>t指的是开始下落后的时间，此时小鸟就要维护自己的小帧号birdF。</p>
</blockquote>
<pre><code>//物理公式：s = 1/2gt^2
//掉
birdF++;
birdY = 100 + 1.3 * birdF * birdF;
birdRotate+=0.08;
</code></pre><h2 id="5、碰撞检测"><a href="#5、碰撞检测" class="headerlink" title="5、碰撞检测"></a>5、碰撞检测</h2><p>AABB盒是英语Axis Aligned Bounding Box 轴对齐包围盒。</p>
<p>//更新自己的碰撞检测盒</p>
<pre><code>this.A = this.y + 7;
this.B = this.x + 41;
this.C = this.y + 41;
this.D = this.x + 7;
</code></pre><p>所谓的ABCD都是边的x或者y，横边就取y值，纵边就取x值。<br>碰撞检测：</p>
<pre><code>if(
    game.bird.A &lt; this.C1 &amp;&amp; game.bird.B &gt; this.D1 &amp;&amp; game.bird.D &lt; this.B1
       ||
    game.bird.C &gt; this.A2 &amp;&amp; game.bird.B &gt; this.D2 &amp;&amp; game.bird.D &lt; this.B2
){
    console.log(&quot;撞！&quot;);
    clearInterval(game.timer);
}
</code></pre><h2 id="6、合成canvas"><a href="#6、合成canvas" class="headerlink" title="6、合成canvas"></a>6、合成canvas</h2><p>ctx.globalCompositeOperation = type</p>
<p>一共有12种值，表示新画的图形和老图形的关系，称为“合成”。</p>
<p>比如：</p>
<pre><code>ctx.fillStyle = &quot;blue&quot;;
ctx.fillRect(100,100,100,100);

ctx.globalCompositeOperation = &quot;source-in&quot;;

ctx.beginPath();
ctx.arc(180,180,50,0,7,false);
ctx.fillStyle = &quot;red&quot;;
ctx.fill();
</code></pre><p>像素操作到目前为止，我们尚未深入了解Canvas画布真实像素的原理，事实上，你可以直接通过ImageData对象操纵像素数据，直接读取或将数据数组写入该对象中。稍后我们也将深入了解如何控制图像使其平滑（反锯齿）以及如何从Canvas画布中保存图像。</p>
<p>得到像素：</p>
<pre><code>var myImageData = ctx.getImageData(0,0,560,300);
</code></pre><p>0,0表示起点位置，560是宽度，300是高度。</p>
<p>得到的值可以被使用作为查看初始像素数据。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是”RGBA”格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。</p>
<h2 id="7、事件监听"><a href="#7、事件监听" class="headerlink" title="7、事件监听"></a>7、事件监听</h2><p>canvas上必须检测范围，因为得不到元素。</p>
<p>贝塞尔曲线：</p>
<pre><code>ctx.moveTo(100,100);
ctx.bezierCurveTo(200, 50, 400, 50, 400, 100);
ctx.stroke();
</code></pre><p>点击鼠标的时候，要遍历每个元素，看看点击到了谁，点击到的这个元素，就存入变量。然后让变量中的元素x、用、跟随你的鼠标变化即可。</p>
<pre><code>if(x &gt; ctrl1.x - 5 &amp;&amp; x &lt; ctrl1.x + 5 &amp;&amp; y &gt; ctrl1.y - 5 &amp;&amp; y &lt; ctrl1.y + 5){
   diandaodedian = ctrl1;
}

if(x &gt; ctrl2.x - 5 &amp;&amp; x &lt; ctrl2.x + 5 &amp;&amp; y &gt; ctrl2.y - 5 &amp;&amp; y &lt; ctrl2.y + 5){
   diandaodedian = ctrl2;
}

if(x &gt; start.x - 5 &amp;&amp; x &lt; start.x + 5 &amp;&amp; y &gt; start.y - 5 &amp;&amp; y &lt; start.y + 5){
   diandaodedian = start;
}

if(x &gt; end.x - 5 &amp;&amp; x &lt; end.x + 5 &amp;&amp; y &gt; end.y - 5 &amp;&amp; y &lt; end.y + 5){
   diandaodedian = end;
}
</code></pre><h2 id="8、场景Scene管理"><a href="#8、场景Scene管理" class="headerlink" title="8、场景Scene管理"></a>8、场景Scene管理</h2><p>开始画面、游戏过程、结束画面。</p>
<p>场景现在开始接手管理自己的演员！！<br>但是，场景还是应该把演员注册到game身上，但是管理的权限、谁上台、谁下台，是场景管理器的任务。</p>
<p>监听都是场景管理器负责注册！！</p>
<p><a href="http://squishybird.com/" target="_blank" rel="external">http://squishybird.com/</a></p>
<p><a href="http://so2.4399.com/" target="_blank" rel="external">http://so2.4399.com/</a></p>
]]></content>
      
        <categories>
            
            <category> Canvas </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Canvas </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见字符串、数组算法]]></title>
      <url>http://yoursite.com/2016/11/22/title28/</url>
      <content type="html"><![CDATA[<h1 id="常见字符串算法"><a href="#常见字符串算法" class="headerlink" title="常见字符串算法"></a>常见字符串算法</h1><h2 id="1、短横变驼峰"><a href="#1、短横变驼峰" class="headerlink" title="1、短横变驼峰"></a>1、短横变驼峰</h2><p>把单词border-left-color变为borderLeftColor。</p>
<p>此时有两种方法：</p>
<blockquote>
<p>方法1：border-left-color用字符串的split方法变为数组：[“border”,”left”,”color”]，然后遍历这个数组第1项开始的每项，把首字母toUpperCase()变为大写然后与剩余字母连接，然后join到一起，就是borderLeftColor。</p>
</blockquote>
<pre><code>// 短横变驼峰函数
function change(str){
    //拆为数组
    var strArr = str.split(&quot;-&quot;);

    //遍历数组
    for(var i = 1 ; i &lt; strArr.length ; i++){
        var chars = strArr[i];
        //将数组的这一项的字符串变为首字母变为大写，与剩余字母做拼接
        strArr[i] = chars[0].toUpperCase() + chars.slice(1);
    }
    //拼接
    return strArr.join(&quot;&quot;);
}
</code></pre><blockquote>
<p>方法2：正则表达式。border-left-color用正则表达式去replace替换，替换什么？替换所有(-字母)变为大写字母。</p>
</blockquote>
<pre><code>    var str = &quot;我爱周杰伦，周杰伦很帅，我要和周杰伦生猴子&quot;;
    str = str.replace(/周杰伦/g,&quot;杨洋&quot;);
    console.log(str);

    var str = &quot;我买了一个手机3000元，电脑5000元，电饭锅100元。今天很热，18度。&quot;;

    str = str.replace(/(\d+)元/g,function(match,$1,index){
        return parseInt($1 / 6) + &quot;美元&quot;;
    });

    console.log(str);

var str = &quot;border-left-color&quot;;
str = str.replace(/\-(\w)/g,function(match,$1){
return $1.toUpperCase();
});
console.log(str);
</code></pre><h2 id="2-、寻找连续三项相同字符串"><a href="#2-、寻找连续三项相同字符串" class="headerlink" title="2 、寻找连续三项相同字符串"></a>2 、寻找连续三项相同字符串</h2><p>现在给你一个字符串，判断里面有没有连续三位或者三位以上相同，如果有，就返回下标数组。</p>
<p>比如： “aabbbccddddee” 返回[2,3,4,7,8,9,10]。</p>
<p>双指针法。在字符串的题目中，基本99%都能用双指针法，比如最大连续相同子串、最大连续重复子串等等，都能用双指针法。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var str = &quot;aabbbccddddee&quot;;

    //位置是0、1
    var i = 0;
    var j = 1;
    //结果
    var result = [];

    while(i &lt; str.length){
        if(str[i] != str[j]){
            //判断是不是到了3位
            if(j - i &gt;= 3){
                //为位号推入数组
                for(var m = i; m &lt;= j-1 ; m++){
                    result.push(m);
                }
            }
            //i追上j，j后移一位
            i = j;
        }
        //不管怎么样j都要后移
        j++;
    }

    console.log(result);
&lt;/script&gt;
</code></pre><h2 id="3-给数字加上千分位符"><a href="#3-给数字加上千分位符" class="headerlink" title="3 给数字加上千分位符"></a>3 给数字加上千分位符</h2><p>输入12345678901，返回”12,345,678,901”。</p>
<p>数组和字符串的相互转换方法很好用，要敏感一些！实际上就是[12,345,678,901]进行join(“,”)就是结果。所以问题就简化为把12345678901这个数字拆分为数组！数组长度11。</p>
<blockquote>
<p>找找规律：</p>
<p>12345678901    str.slice(-3)  → 很特殊，没有第二个参数</p>
<p>12345678901    str.slice(-6,-3)</p>
<p>12345678901    str.slice(-9,-6)</p>
<p>12345678901    str.slice(-12,-9)</p>
</blockquote>
<p>程序：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var num = 12433245245432;
    //除了null、undefined之外的任何字面量都有toString()方法，表示变为字符串
    var length = num.toString().length;

    //循环终点
    var end = -Math.ceil(length / 3) * 3;
    //结果数组，把特殊的末尾三位放入数组
    var result = [num.toString().slice(-3)];
    //遍历-6、-9、-12、-15……
    //截取的是slice(-6,-3) slice(-9,-6)  slice(-12,-9)
    for(var i = -6 ; i &gt;= end ; i-=3){
        result.unshift(num.toString().slice(i,i+3));
    }
    //把数组变为字符串
    console.log(result.join(&quot;,&quot;));
&lt;/script&gt;
</code></pre><p>还可以用正则表达式，我们慢慢推导：</p>
<p>\B是一个特殊的正则的东西，表示字母边界，非单词边界。\b表示单词边界。</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    var str = &quot;abc,adsf haha xixi&quot;;
    str = str.replace(/\B/g,&quot;★&quot;);
    console.log(str);
&lt;/script&gt;
</code></pre><p>出现★的地方就是字母边界</p>
<p>然后说正则中的(?=)语法，表示定语从句，位置描述。</p>
<p>比如，我们想替换字符串中所有后面是“你”字的“爱”字.</p>
<pre><code>var str = &quot;我爱你，你却爱着他&quot;;
str = str.replace(/爱(?=你)/g,&quot;★&quot;);
console.log(str);
</code></pre><p>替换字符串中所有后面有“3位数字”的字母\B ：</p>
<pre><code>var str = &quot;12324324324&quot;;
str = str.replace(/\B(?=\d{3})/g,&quot;★&quot;);
console.log(str);
</code></pre><p>   比较乱，因为我们没有限制边界</p>
<p>替换字符串中所有后面到单词结尾有“3位数字”的\B ：</p>
<pre><code>var str = &quot;12324324324&quot;;
str = str.replace(/\B(?=\d{3}$)/g,&quot;★&quot;);
console.log(str);
</code></pre><p>替换字符串中所有后面到单词结尾有一个或多个“3位数字”的\B ：</p>
<pre><code>var str = &quot;12324324324&quot;;
str = str.replace(/\B(?=(\d{3})+$)/g,&quot;★&quot;);
console.log(str);
</code></pre><p>这就是答案，只需要把★改为逗号即可。</p>
<h1 id="常见数组算法"><a href="#常见数组算法" class="headerlink" title="常见数组算法"></a>常见数组算法</h1><p>数组没有indexOf方法，也就是说我给你一个数组，问你这个数组中没有一个项是数字6，你必须遍历所有项目，一个项目一个项目的比对，是不是数字6。</p>
<h2 id="1-数组的去重"><a href="#1-数组的去重" class="headerlink" title="1 数组的去重"></a>1 数组的去重</h2><p>给你一个数组[3,4,6,32,2,3,4,57,6] 返回去掉重复项的数组[3,4,6,32,2,57]。难点就是验证数字是不是已经在数组中了，而如果要遍历，产生的时间复杂度是很高的。</p>
<p>大家的普遍算法就是，创建一个新的空数组[]，然后遍历原数组，遍历到原数组的每一项的时候，再遍历新的这个数组依次比对，如果新数组中没有这个项，就push进去。</p>
<pre><code>var arr = [3,4,6,32,2,3,4,57,57,6];
    var result = [];

    for(var i = 0 ; i &lt; arr.length ; i++){
        for(var j = 0 ; j &lt; result.length ; j++){
            //如果遇见相同的数字，立即终止内层循环
            if(arr[i] == result[j]) break;
        }
        //验收，看看是不是result中的每一项都不等于arr[i]
        if(j == result.length){
            result.push(arr[i]);
        }
    }

    console.log(result);
</code></pre><p>我们可以升级，升级为可以对原来的数组排序，把[3,4,6,32,2,3,4,57,6] 先排序，变为[2, 3, 3, 4, 4, 6, 6, 32, 57]。</p>
<p>再次做一个结果空数组[]，把数组中的每一项和结果数组中的最后一项进行比较，如果不同就说明真的不同了。</p>
<blockquote>
<p>方法3是我们要着重介绍的，就是给数组简历一个索引对象。我们创建一个空对象，{}。每次验证对象中有没有这个项，如果没有就push进入result数组，同时把对象中创建一个属性就是你这个数字，值设为1。</p>
</blockquote>
<pre><code>{&quot;3&quot; : 1 , &quot;4&quot; : 1 , &quot;6&quot; :1 , &quot;32&quot;:1 , &quot;2&quot;:1 , &quot;57&quot;:1}
</code></pre><p>哲学就是用对象弥补数组没有indexOf的缺陷！</p>
<pre><code>var arr = [3,4,6,32,2,3,4,57,6];
var temp = {};
var result = [];

for(var i = 0 ; i &lt; arr.length ; i++){
    //检查对象中有没有这个属性，如果没有这个属性，那么推入结果数组，并且让对象添加这个属性。属性值设置为1。
    if(!temp[arr[i]]){
        result.push(arr[i]);
        temp[arr[i]] = 1;
    }
}

console.log(result);
console.log(temp);
</code></pre><h2 id="2-数组的差集"><a href="#2-数组的差集" class="headerlink" title="2 数组的差集"></a>2 数组的差集</h2><p>返回在arr1里面但是不在arr2里面的项，比如：</p>
<pre><code>arr1是[1,2,3,4,5,3]
arr2是[3,4,5,6,7]
</code></pre><p>返回[1,2]</p>
<p>根据我们刚才数组去重的经验，我们可以先遍历arr2，设置一个空对象，把arr2的所有值作为这个对象的属性添加上。然后遍历arr1的时候，只需要看对象身上有没有这个属性即可。</p>
]]></content>
      
        <categories>
            
            <category> 字符串 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery节点关系]]></title>
      <url>http://yoursite.com/2016/11/20/title25/</url>
      <content type="html"><![CDATA[<h1 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h1><p>jQuery控制元素时，都是批量控制。</p>
<p>添加事件，元素本身运动、或者其他元素运动，都想跟事件元素找一些关系。</p>
<p>jQuery帮我们简化了这个找关系的过程，封装了一系列的方法可以帮我们找到父亲、儿子、兄弟、祖先、孙子等元素。</p>
<h2 id="1、-this-自己"><a href="#1、-this-自己" class="headerlink" title="1、$(this)自己"></a>1、$(this)自己</h2><p>事件内部有一个$(this)的对象，指向的就是触发事件的这个元素本身。</p>
<p>就是原生js里的事件函数内的那个this，用$()将this转成jQuery对象，就能调用jQuery的方法。this不要加引号。</p>
<pre><code>1    // 谁触发事件谁动
2    $(&quot;p&quot;).click(function(){
3        $(this).animate({&quot;left&quot;:1000},1000);
4    });
</code></pre><h2 id="2、parent-父亲"><a href="#2、parent-父亲" class="headerlink" title="2、parent()父亲"></a>2、parent()父亲</h2><p>寻找元素父级的方法：必须加小括号，找到的也是亲生的父亲。爷爷和叔叔都不能。</p>
<p>案例：点击一个元素，让他的父亲背景变色。</p>
<pre><code>1    $(&quot;p&quot;).click(function(){
2        $(this).parent().css(&quot;background&quot;,&quot;lightblue&quot;);
3    });
</code></pre><p>说明：方法返回的是某一个元素的父亲的jQuery对象，继续打点调用jQuery方法。</p>
<h2 id="3、children-儿子"><a href="#3、children-儿子" class="headerlink" title="3、children()儿子"></a>3、children()儿子</h2><p>寻找子级元素的方法：必须加小括号，选中的是元素的所有儿子级元素。孙子级的元素选不中。</p>
<p>案例：点击一个元素，让他的子级全部消失。</p>
<pre><code>1    //让点击元素的子级全部消失
2            $(&quot;div&quot;).click(function(){
3                $(this).children().hide(300);
4            });    
</code></pre><p>方法可以传递参数：还是一个选择器，指的是我要选择儿子级里面还要满足选择器要求的那些元素。</p>
<pre><code>1    //要选择儿子级元素中符合选择器要求的部分
2    $(&quot;div&quot;).click(function(){
3        $(this).children(&quot;.cur&quot;).hide(300);
4    });    

4、siblings()兄弟
</code></pre><p>寻找的是同级的兄弟元素：方法必须加小括号，找到的是亲兄弟元素。</p>
<p>案例：点击一个元素，让他的兄弟都变色，自身不变色。</p>
<pre><code>1    $(&quot;div&quot;).children().click(function(){
2        $(this).siblings().css(&quot;background&quot;,&quot;red&quot;);
3    });
</code></pre><p>可以通过参数进行选择器筛选.</p>
<pre><code>1    //筛选h2的兄弟元素
2            $(&quot;div&quot;).children().click(function(){
3                $(this).siblings(&quot;h2&quot;).css(&quot;background&quot;,&quot;red&quot;);
4            });
</code></pre><p>指的是选中的是兄弟元素中的h2标签。</p>
<h2 id="5、连续打点调用"><a href="#5、连续打点调用" class="headerlink" title="5、连续打点调用"></a>5、连续打点调用</h2><p>案例：点击一个元素，让他自己变红，让他的兄弟编绿，父亲变蓝，父亲的兄弟变紫色，兄弟的儿子变金色。</p>
<pre><code>1    $(&quot;div&quot;).children().click(function(){
2        $(this).css(&quot;background&quot;,&quot;red&quot;) //自己
3        .siblings().css(&quot;background&quot;,&quot;green&quot;)   //自己的兄弟
4        .parent().css(&quot;background&quot;,&quot;blue&quot;)//自己和兄弟的父亲
5        .siblings().css(&quot;background&quot;,&quot;purple&quot;)  //父亲的兄弟
6        .children().css(&quot;background&quot;,&quot;gold&quot;);  //父亲兄弟的儿子
7    });
</code></pre><p>原理：一个jQuery对象打点调用完自己的任何方法，都会return一个对象，就是jQuery对象本身。</p>
<pre><code>1    $(&quot;p&quot;).html(&quot;哈哈&quot;).css(&quot;background&quot;,&quot;skyblue&quot;);
</code></pre><h2 id="6、其他节点关系"><a href="#6、其他节点关系" class="headerlink" title="6、其他节点关系"></a>6、其他节点关系</h2><p>find()：找的是元素的后代的一些元素，根据参数的选择器去选择。</p>
<pre><code>1    $(&quot;div&quot;).find(&quot;span&quot;).css(&quot;background&quot;,&quot;#00f&quot;)
</code></pre><p>next()：选中的是当前元素的下一个元素，必须是同级的。</p>
<pre><code>1    $(&quot;div&quot;).children().click(function(){
2        $(this).next().css(&quot;background&quot;,&quot;#f00&quot;);
3    })
</code></pre><p>nextAll()：选中的是当前元素后面的所有兄弟元素。内部可以传参数，选择符合选择器的后面的兄弟。</p>
<pre><code>1    $(&quot;div&quot;).children().click(function(){
2        $(this).nextAll().css(&quot;background&quot;,&quot;#f00&quot;);
3    })
</code></pre><p>prev()：选中的是当前元素的上一个元素，必须是同级的。</p>
<pre><code>1    $(&quot;div&quot;).children().click(function(){
2        $(this).prev().css(&quot;background&quot;,&quot;#f00&quot;);
3    })
</code></pre><p>prevAll()：选中的是当前元素前面的所有兄弟元素。内部可以传参数，选择符合选择器的后面的兄弟</p>
<pre><code>1    $(&quot;div&quot;).children().click(function(){
2        $(this).prevAll().css(&quot;background&quot;,&quot;#f00&quot;);
3    })
</code></pre><p>parents()：选择的是包含html标签在内的所有祖先元素。内部可以传参数，选择符合选择器的祖先元素。</p>
<pre><code>1    $(&quot;p&quot;).parents(&quot;div&quot;).css(&quot;background&quot;,&quot;pink&quot;)
</code></pre>]]></content>
      
        <categories>
            
            <category> jQuery </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[animate常见知识]]></title>
      <url>http://yoursite.com/2016/11/20/title27/</url>
      <content type="html"><![CDATA[<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>animate是动画的意思。是jQuery自己的一个运动方法。非常好用的方法。</p>
<p>原生js动画必须依靠setInterval，根据步长和间隔时间来操作运动。</p>
<p>animate动画方法内部给我们用setInterval已经封装好了。不用自己去计算步长。</p>
<p>方法通过两个参数决定运动的结束位置和总时间。</p>
<p>语法：</p>
<pre><code>1    .animate(结束位置JSON，运动总时间)
</code></pre><p>第一个参数必须是JSON对象：即便只有一个属性变化也需要写在JSON。</p>
<p>第二个参数是总时间：经过多长时间运动停止，习惯给一个变量during。</p>
<p>原来JS的代码：</p>
<pre><code>1    var demo = document.getElementById(&quot;demo&quot;);
2            var now = 100;
3            var timer = setInterval(function(){
4                now += 10;
5                if(now &gt;= 400){
6                    now = 400;
7                    clearInterval(timer);
8                }
9                demo.style.width = now + &quot;px&quot;;
10            },50);
</code></pre><p>jQuery的方法：</p>
<pre><code>1    $(&quot;.demo&quot;).animate({&quot;width&quot;:400},1500);
</code></pre><p>什么样的css属性能够做animate动画。</p>
<p>很多属性值为数值的属性可以参与运动。css3里面也有一部分可以参与，大部分不能参与的。</p>
<p>不能参与的：<br>    “background-color” : “red”    //css3的过渡动画可以完成<br>    “background-position”:”0 0”<br>    1    //jQuery的运动函数方法<br>    2            $(“.demo”).animate({<br>    3                “width”:200,<br>    4                “height”:200,<br>    5                “opacity”:0.5,<br>    6                “border-width”:20,<br>    7                “left”:200,<br>    8                “top”:200,<br>    9                “padding”:50,<br>    10                “border-radius”:”50%”,<br>    11                //不能参与动画<br>    12                //“background-color” : “red”//css3的过渡动画可以完成<br>    13                //“background-position”:”0 0”<br>    14            },400);</p>
<h2 id="2、动画排序"><a href="#2、动画排序" class="headerlink" title="2、动画排序"></a>2、动画排序</h2><p>①同一个元素身上的运动有一个叫做“动画排队”的现象。</p>
<p>如果同一个元素，身上加了多个运动函数，会进行排队，谁先写的，谁先动。</p>
<pre><code>1    $(&quot;.demo&quot;).animate({&quot;left&quot;:600},during);
2    $(&quot;.demo&quot;).animate({&quot;top&quot;:400},during);
3    $(&quot;.demo&quot;).animate({&quot;left&quot;:0},during);
4    $(&quot;.demo&quot;).animate({&quot;top&quot;:0},during);
</code></pre><p>给一个元素添加事件中有运动函数，多次触发事件也会造成动画排队。知道最后一个事件动画结束。</p>
<pre><code>1    $(&quot;.demo&quot;).mouseenter(function(){
2                $(this).children(&quot;p&quot;).slideDown(during);
3            });
4            $(&quot;.demo&quot;).mouseleave(function(){
5                $(this).children(&quot;p&quot;).slideUp(during);
6            });
</code></pre><p>②不同元素之间都有动画，不会排队。</p>
<p>原理：animate函数封装时，用的是setInterval异步语句。同一个元素的动画有一个函数节流操作。</p>
<p>animate就是一个异步语句，异步语句在执行的时候，不会影响后面语句的执行。</p>
<pre><code>1    $(&quot;.demo1&quot;).animate({&quot;left&quot;:600},during);
2    $(&quot;.demo1&quot;).animate({&quot;top&quot;:400},during);
3    $(&quot;.demo1&quot;).animate({&quot;left&quot;:0},during);
4    $(&quot;.demo1&quot;).animate({&quot;top&quot;:0},during);
5    $(&quot;.demo2&quot;).animate({&quot;left&quot;:600,&quot;top&quot;:400},during);
</code></pre><p>③不是动画的语句，也不会等待。</p>
<pre><code>1    $(&quot;div p&quot;).css(&quot;display&quot;,&quot;block&quot;);
</code></pre><h2 id="3、异步语句和回调函数"><a href="#3、异步语句和回调函数" class="headerlink" title="3、异步语句和回调函数"></a>3、异步语句和回调函数</h2><p>animate运动方法就是一个异步语句，我们也可以给它一个回调函数，告诉我们运动结束之后我可以做什么事。</p>
<p>animate方法有一个回调函数的参数，第三个参数可以传递一个回调函数。</p>
<pre><code>1    $(&quot;.demo1&quot;).animate({&quot;top&quot;:0},during,function(){
2        $(&quot;.demo1 p&quot;).css(&quot;display&quot;,&quot;block&quot;);
3    });
4    $(&quot;.demo2&quot;).animate({&quot;left&quot;:600,&quot;top&quot;:400},during,function(){
5        $(&quot;.demo2 p&quot;).css(&quot;display&quot;,&quot;block&quot;);
6    });
</code></pre><p>其他的运动方法也有回调函数：</p>
<blockquote>
<p>slideDown()、slideUp()、fadeIn()、fadeOut()、show(1000)、hide(1000)这几个方法也是运动的方法，都有一个回调函数。</p>
<pre><code>1    $(&quot;.demo1 p&quot;).slideDown(500,function(){
2        alert(&quot;出现啦&quot;);
3    });
</code></pre></blockquote>
<h2 id="4、delay-延迟动画"><a href="#4、delay-延迟动画" class="headerlink" title="4、delay()延迟动画"></a>4、delay()延迟动画</h2><p>所有的动画语句都可以在前面有一个延迟语句。表示这条语句执行之后，动画不是立即执行，要等待一段时间再执行。</p>
<p>书写位置：在动画语句之前。</p>
<p>参数：规定的是延迟时间。</p>
<pre><code>1    $(&quot;.demo2&quot;).delay(2000).animate({&quot;left&quot;:600,&quot;top&quot;:400},during,function(){
2        $(&quot;.demo2 p&quot;).css(&quot;display&quot;,&quot;block&quot;);
3    });
</code></pre><p>只要是动画方法都可以写delay延迟。</p>
<blockquote>
<p>slideDown()、slideUp()、fadeIn()、fadeOut()、show(1000)、hide(1000)都可以进行延迟。</p>
</blockquote>
<pre><code>1    $(&quot;.demo2 p&quot;).delay(1000).slideDown(1000);
2    $(&quot;.demo2 p&quot;).delay(1000).slideUp(1000);
</code></pre><p>要想延迟一个运动，前面必须每次都加delay。</p>
<p>写法等价于：</p>
<pre><code>1    $(&quot;.demo2 p&quot;).delay(1000).slideDown(1000).delay(1000).slideUp(1000);
</code></pre><h2 id="5、stop-停止动画"><a href="#5、stop-停止动画" class="headerlink" title="5、stop()停止动画"></a>5、stop()停止动画</h2><p>可以停止我们的动画。</p>
<p>两个参数：都是布尔值。</p>
<blockquote>
<p>第一个参数：表示是否清空排队的动画。true表示清空，false表示不清。</p>
<p>第二个参数：表示是否立即完成当前动画。true表示立即完成，false表示立即停止不动。</p>
</blockquote>
<p>默认不写：两个参数都是false。</p>
<pre><code>1    //如果参数都是false，不清空动画队列，立即停止当前动画，进入下一个排队的动画
2            $(&quot;#ff&quot;).click(function(){            
3                $(&quot;.demo1&quot;).stop();
4            });
5            //第一个是true，第二个是false，清空后面的动画，立即停止当前动画
6            $(&quot;#tf&quot;).click(function(){            
7                $(&quot;.demo1&quot;).stop(true);
8            });
9            //第一个是true，第二个是true，清空后面的动画，立即走完当前动画
10            $(&quot;#tt&quot;).click(function(){            
11                $(&quot;.demo1&quot;).stop(true,true);
12            });
13            //第一个是false，第二个是true，不清空后面的动画，立即走完当前动画，并且进入下一个排队的动画
14            $(&quot;#ft&quot;).click(function(){            
15                $(&quot;.demo1&quot;).stop(false,true);
16            });
</code></pre><h2 id="6、解决动画排队问题"><a href="#6、解决动画排队问题" class="headerlink" title="6、解决动画排队问题"></a>6、解决动画排队问题</h2><p>我希望新的动画被触发时，希望前面的这个元素动画全部清空，立即停止。</p>
<p>防止用户频繁触发事件，动画等待。</p>
<p>方法1：</p>
<blockquote>
<p>用stop()。清空前面所有动画队列，立即停止当前。参数值需要传第一个true。</p>
</blockquote>
<pre><code>1    $(&quot;.demo&quot;).mouseenter(function(){
2        $(this).children(&quot;p&quot;).stop(true).slideDown(during);
3    });
4    $(&quot;.demo&quot;).mouseleave(function(){
5        $(this).children(&quot;p&quot;).stop(true).slideUp(during);
6    });
</code></pre><p>为了防止频繁流氓操作，只要添加一个运动动画，前面都必须加一个stop(true)。</p>
<p>方法2：</p>
<blockquote>
<p>节流方法：判断元素是否在运动过程中，如果是，就不执行后面的其他操作，如果不是，就执行后面的动画。</p>
</blockquote>
<p>元素都有一个方法叫做is（）,判断是否处于某种状态。</p>
<p>1    $(“p”).is(“:animated”);   返回true和false。</p>
<pre><code>1    var during = 500;
2            $(&quot;.demo&quot;).mouseenter(function(){
3                if($(this).children(&quot;p&quot;).is(&quot;:animated&quot;)){
4                    return;
5                }
6                $(this).children(&quot;p&quot;).slideDown(during);
7            });
8            $(&quot;.demo&quot;).mouseleave(function(){
9                if($(this).children(&quot;p&quot;).is(&quot;:animated&quot;)){
10                    return;
11                }
12                $(this).children(&quot;p&quot;).slideUp(during);
13            });
</code></pre>]]></content>
      
        <categories>
            
            <category> jQuery </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery排序常见方法]]></title>
      <url>http://yoursite.com/2016/11/20/title26/</url>
      <content type="html"><![CDATA[<h1 id="jQuery排序"><a href="#jQuery排序" class="headerlink" title="jQuery排序"></a>jQuery排序</h1><h2 id="1、eq（）整体排序"><a href="#1、eq（）整体排序" class="headerlink" title="1、eq（）整体排序"></a>1、eq（）整体排序</h2><p>通过$()得到jQuery对象，可以继续通过eq()获得某一个元素。</p>
<p>下标问题：jQuery对象得到的原生对象会进行一个自己的排列，组成一个队列。eq()方法是从这个队列里去进行排序。与原来页面的结构无关。</p>
<pre><code>1    //不能用一个下标1全部选中，选中的仅仅是所有被选中的p组成的队列里的第一个
2            // $(&quot;div p&quot;).eq(1).css(&quot;background&quot;,&quot;red&quot;);
3            // $(&quot;div p&quot;).eq(5).css(&quot;background&quot;,&quot;red&quot;);
4            // $(&quot;div p&quot;).eq(9).css(&quot;background&quot;,&quot;red&quot;);
5            // $(&quot;div p&quot;).eq(13).css(&quot;background&quot;,&quot;red&quot;);
</code></pre><p>上面的排序：将所有的p选出来之后，进行新的排序，新顺序是eq方法的下标。</p>
<pre><code>1    $(&quot;div p.cur&quot;).eq(1).css(&quot;background&quot;,&quot;red&quot;);
</code></pre><p>上面的排序：将所有类名叫做cur的元素全部选取出来，进行排序，新顺序是我们的eq的下标顺序，与原来节点关系的排序没关系。</p>
<h2 id="2、index-在兄弟关系中的排序"><a href="#2、index-在兄弟关系中的排序" class="headerlink" title="2、index()在兄弟关系中的排序"></a>2、index()在兄弟关系中的排序</h2><p>Index()这个方法获得的是元素在html结构中，在自己的同级元素中的位置，与获得的jQuery新队列没关系。</p>
<pre><code>1    //给p标签绑定事件，点击输出自己的index（）
2            $(&quot;div p&quot;).click(function(){
3                console.log($(this).index());
4            });

1    //给p标签绑定事件，点击输出自己的index（）
2    $(&quot;div p.cur&quot;).click(function(){
3        console.log($(this).index());
4    });
</code></pre><p>与新队列无关，与兄弟中的排行有关。</p>
<h2 id="3、对应和排他"><a href="#3、对应和排他" class="headerlink" title="3、对应和排他"></a>3、对应和排他</h2><p>tab栏效果：给上面的元素添加事件，对应的下面的新闻显示。</p>
<p>可以通过相同的index（）得到的兄弟之间的排序，找到对应关系。</p>
<p>排他：将不是与我对应的内容设置成默认，与我对应的元素设置特殊。</p>
<pre><code>1    $(&quot;.top span&quot;).mouseenter(function(){
2        //自己的排他
3        $(this).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;);
4        //具体信息的排他
5        $(&quot;.bottom ul&quot;).eq($(this).index()).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;);
6            });
</code></pre><p>出现一个问题：就是我们所有的ul元素的一个大排队，我们选中的永远是第一个tab栏的ul。</p>
<p>解决方法：不要拆开去选择元素，所有的元素都是通过节点关系，从自身出发。</p>
<pre><code>1    //避免所有的tab栏大排序，所有的代码都是从事件元素自身出发去找关系            $(this).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;).parent().siblings().children().eq($(this).index()).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;);
</code></pre><h2 id="4、each-遍历jQuery对象"><a href="#4、each-遍历jQuery对象" class="headerlink" title="4、each()遍历jQuery对象"></a>4、each()遍历jQuery对象</h2><p>each()遍历我们jQuery对象里的元素队列。</p>
<p>有一个参数：function，函数参数，规定了遍历过程中对每一个元素做的工作。</p>
<pre><code>1    $(“p”).each(function(){
2     对每一个元素的操作。
3    });
</code></pre><p>function函数内部有一个默认的参数：i，指的就是这一次遍历的元素在整体队列里的下标。</p>
<pre><code>1    $(&quot;div&quot;).each(function(i){
2        //i就是每次进来遍历的元素的下标
3        //this指向的就是每次进来的那个元素
4        $(this).children().eq(1).css(&quot;background&quot;,&quot;red&quot;);
5    });
</code></pre><p>如果遇到：每一个元素内怎么样，一定要用each方法。</p>
<pre><code>1    $(&quot;div&quot;).each(function(i){
2        //i就是每次进来遍历的元素的下标
3        //this指向的就是每次进来的那个元素
4        $(this).children().eq(1).css(&quot;background&quot;,&quot;red&quot;);
5    });
</code></pre><p>制作：折叠选项卡的效果</p>
<pre><code>1    //获取h2元素，每一个添加点击事件
2            // ＋号和-号切换，兄弟元素展开或收起
3            $(&quot;.box h2&quot;).each(function(){
4                var $h2 = $(this).parent().siblings().children(&quot;h2&quot;);
5                $(this).click(function(){
6                    //自己的兄弟展开
7                    var $span = $(this).children(&quot;span&quot;);
8                    $span.html($span.html() == &quot;+&quot; ? &quot;-&quot; : &quot;+&quot;);
9                    $(this).siblings().slideToggle(300);
10                    //其他h2的兄弟隐藏
11                    $h2.children(&quot;span&quot;).html(&quot;+&quot;);
12                    $h2.siblings().slideUp(300);
13                })
14            })
</code></pre>]]></content>
      
        <categories>
            
            <category> jQuery </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jQuery常用方法]]></title>
      <url>http://yoursite.com/2016/11/18/title24/</url>
      <content type="html"><![CDATA[<h1 id="jQuery常用方法"><a href="#jQuery常用方法" class="headerlink" title="jQuery常用方法"></a>jQuery常用方法</h1><h2 id="1、html"><a href="#1、html" class="headerlink" title="1、html()"></a>1、html()</h2><p>相当于我们原生js里面的innerHTML方法。给元素内部添加内容。</p>
<p>参数必须是字符串。</p>
<pre><code>1    $(&quot;div&quot;).html(&quot;你好，这是一个div&quot;);
</code></pre><p>手动的给标签内部加其他标签。</p>
<pre><code>1    $(&quot;div&quot;).html(&quot;&lt;p&gt;&lt;a href=\&quot;#\&quot;&gt;你好&lt;/a&gt;&lt;/p&gt;&quot;);
</code></pre><p>读取内容：只能读取第一个元素内的内容。</p>
<pre><code>1    console.log($(&quot;div&quot;).html());
</code></pre><h2 id="2、addClass-和removeClass"><a href="#2、addClass-和removeClass" class="headerlink" title="2、addClass()和removeClass()"></a>2、addClass()和removeClass()</h2><p>增加类名：addClass</p>
<p>移除类名：removeClass</p>
<p>要添加或移除的类名作为参数传入小括号内。</p>
<pre><code>1    $(&quot;.ad&quot;).click(function(){
2        $(&quot;.box&quot;).addClass(&quot;demo&quot;);
3    });
4    $(&quot;.re&quot;).click(function(){
5        $(&quot;.box&quot;).removeClass(&quot;demo&quot;);
6    });
</code></pre><p>操作过程中，不会影响元素原有的类名或其他类名。</p>
<h2 id="3、attr"><a href="#3、attr" class="headerlink" title="3、attr()"></a>3、attr()</h2><p>调用或更改html元素的属性和属性值。</p>
<pre><code>1    //获取某一个属性值
2    // console.log($(&quot;.ad&quot;).attr(&quot;type&quot;));
3    //添加属性，传两个参数，第一个属性名，第二个属性值
4    // $(&quot;.box&quot;).attr(&quot;id&quot;,&quot;demo&quot;);
</code></pre><p>修改属性值。</p>
<pre><code>1    $(&quot;input&quot;).click(function(){
2        $(&quot;img&quot;).attr(&quot;src&quot;,&quot;images/cat2.jpg&quot;);
3    });
</code></pre><h2 id="4、常用的事件"><a href="#4、常用的事件" class="headerlink" title="4、常用的事件"></a>4、常用的事件</h2><p>jQuery的事件不需要写on。</p>
<p>单击事件：click()；</p>
<pre><code>1    $(&quot;input&quot;).click(function(){
2        $(&quot;img&quot;).attr(&quot;src&quot;,&quot;images/cat2.jpg&quot;);
3    });
</code></pre><p>鼠标移上：mouseenter鼠标进入</p>
<pre><code>1    //鼠标移上元素添加类名
2    $(&quot;.box&quot;).mouseenter(function(){
3        $(&quot;.box&quot;).addClass(&apos;demo&apos;);
4    });
</code></pre><p>鼠标移出：mouseleave鼠标离开方法</p>
<pre><code>1    //鼠标移出元素移除类名
2    $(&quot;.box&quot;).mouseleave(function(){
3        $(&quot;.box&quot;).removeClass(&apos;demo&apos;);
4    });
</code></pre><p>还有一种on的写法：本身也是一个方法，有两个参数，第一个参数是事件类型，第二个参数是事件函数。</p>
<pre><code>1    //on方法添加事件
2            $(&quot;input&quot;).on(&quot;click&quot;,function(){
3                $(&quot;img&quot;).attr(&quot;src&quot;,&quot;images/cat2.jpg&quot;);
4            });
</code></pre><h2 id="5、css"><a href="#5、css" class="headerlink" title="5、css()"></a>5、css()</h2><p>作用：调用和更改css 样式。</p>
<p>css()方法可以传递两个参数：如果只传一个参数，调用属性计算后的样式，如果传递两个参数，就是修改这个样式。</p>
<pre><code>1    语法：jQuery.css(属性名，属性值);
</code></pre><p>传递一个参数，表示调用属性值：</p>
<blockquote>
<p>得到的值是一个字符串形式的数据，不能直接参与运算。</p>
</blockquote>
<pre><code>1    console.log($(&quot;.box&quot;).css(&quot;width&quot;));
</code></pre><p>传递两个参数，表示赋值：</p>
<pre><code>1    $(&quot;img&quot;).css(&quot;width&quot;,&quot;200px&quot;);
</code></pre><p>属性名既可以写驼峰也可以写css写法：</p>
<pre><code>1    //既可以写驼峰也可以写css写法
2    // $(&quot;div&quot;).css(&quot;background-color&quot;,&quot;yellowgreen&quot;);
3    $(&quot;div&quot;).css(&quot;backgroundColor&quot;,&quot;skyblue&quot;);
</code></pre><p>属性值很灵活，可以直接写数字不带单位，还可以写带单位或不带单位的字符串。</p>
<pre><code>1    $(&quot;div&quot;).css(&quot;width&quot;,200);
2    $(&quot;div&quot;).css(&quot;height&quot;,&quot;200px&quot;);
3    $(&quot;div&quot;).css(&quot;border-width&quot;,&quot;5&quot;);
</code></pre><p>数值甚至可以写成加等的形式：</p>
<pre><code>1    $(&quot;div&quot;).click(function(){
2        $(&quot;div&quot;).css(&quot;width&quot;,&quot;+=20px&quot;);
3    });
</code></pre><p>如果我们设置多个属性，将多个属性写在JSON对象。</p>
<pre><code>1    //同时设置多个属性
2            $(&quot;div&quot;).css({
3                &quot;width&quot; : 200,
4                &quot;height&quot; : 200,
5                &quot;border-width&quot; : 5
6            });
</code></pre><h2 id="6、hide-和show"><a href="#6、hide-和show" class="headerlink" title="6、hide()和show()"></a>6、hide()和show()</h2><p>就是隐藏和显示某一个元素。</p>
<pre><code>1    $(&quot;.hide&quot;).click(function(){
2        $(&quot;img&quot;).hide();   隐藏
3    })
4    $(&quot;.show&quot;).click(function(){
5        $(&quot;img&quot;).show();   显示
6    })
</code></pre><p>可以传递一个时间参数，控制隐藏和显示的中间时间。</p>
<pre><code>1    $(&quot;.hide&quot;).click(function(){
2        $(&quot;img&quot;).hide(1000);
3    })
4    $(&quot;.show&quot;).click(function(){
5        $(&quot;img&quot;).show(1000);
6    })
</code></pre><p>隐藏：伴随着透明度从设置透明度到0的变化，还有宽高从设置值到0的动画。</p>
<p>方法可以在显示和隐藏之间进行切换：toggle()；</p>
<pre><code>1    $(&quot;.toggle&quot;).click(function(){
2        $(&quot;img&quot;).toggle(1000);
3    });
</code></pre><h2 id="7、slideDown和slideUp"><a href="#7、slideDown和slideUp" class="headerlink" title="7、slideDown和slideUp"></a>7、slideDown和slideUp</h2><p>slideDown()：滑动显示（方向不一定）；</p>
<p>slideUp()：滑动隐藏；</p>
<p>本身就有运动过程。默认运动时间400毫秒。</p>
<pre><code>1    $(&quot;.up&quot;).click(function(){
2        $(&quot;img&quot;).slideUp();
3    });
4    $(&quot;.down&quot;).click(function(){
5        $(&quot;img&quot;).slideDown();
6    });
</code></pre><p>隐藏的前提：必须是display:block;</p>
<p>显示的前提：必须是display:none;</p>
<p>中间有自己定义的动画：内部的结构，说明我们以什么方式隐藏和显示。</p>
<p>切换：slideToggle()。可以自定义运动时间：</p>
<pre><code>1    $(&quot;.up&quot;).click(function(){
2                $(&quot;img&quot;).slideUp(1000);
3            });
4            $(&quot;.down&quot;).click(function(){
5                $(&quot;img&quot;).slideDown(1000);
6            });
7            $(&quot;.toggle&quot;).click(function(){
8                $(&quot;img&quot;).slideToggle(1000);
9            });
</code></pre><h2 id="8、fadeIn和fadeOut"><a href="#8、fadeIn和fadeOut" class="headerlink" title="8、fadeIn和fadeOut"></a>8、fadeIn和fadeOut</h2><p>表示淡入和淡出：透明度发生的变化。</p>
<blockquote>
<p>fadeIn：透明度变大，显示元素，淡入。</p>
<p>fadeOut：透明度变到0，隐藏元素，淡出。</p>
</blockquote>
<p>默认运动时间是400毫秒，可以自定义时间。</p>
<pre><code>1    $(&quot;.out&quot;).click(function(){
2                $(&quot;img&quot;).fadeOut(1000);
3            });
4            $(&quot;.in&quot;).click(function(){
5                $(&quot;img&quot;).fadeIn(1000);
6            });
7            $(&quot;.toggle&quot;).click(function(){
8                $(&quot;img&quot;).fadeToggle(1000);
9            });
</code></pre><p>淡入淡出到某一个透明度：fadeTo（）。有两个参数，第一个叫做速度参数。第二个透明度的终点。</p>
<pre><code>1    $(&quot;.to&quot;).click(function(){
2        $(&quot;img&quot;).fadeTo(&quot;slow&quot;,0.5);
3    });

1    $(&quot;.out&quot;).click(function(){
2        $(&quot;img:first&quot;).fadeOut(3000);
3        $(&quot;img:last&quot;).fadeIn(3000);
4    });
</code></pre>]]></content>
      
        <categories>
            
            <category> jQuery </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[call和apply]]></title>
      <url>http://yoursite.com/2016/11/18/title22/</url>
      <content type="html"><![CDATA[<h2 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h2><p>了解普通函数内部有没有this关键，指向是谁。</p>
<pre><code>1    var box = document.getElementById(&quot;box1&quot;);
2            animate(box,{&quot;left&quot;:300},1000,function(){
3                console.log(this);
4            });
5            function move(){
6                console.log(this);
7            }
</code></pre><p>普通函数（事件函数除外）内部的this默认指向window对象。</p>
<p>call方法和apply方法能够帮我们制定函数内部this的指向。</p>
<pre><code>1    fun.call(obj);
2    fun.apply(obj);
</code></pre><p>obj就是内部this规定的指向元素。</p>
<pre><code>1    //作用：第一个执行函数，第二个指定this。
2            move.call(box);
3            move.apply(box);
</code></pre><p>两种方法都能用。</p>
<p>区别：就是函数传参的方式不同。</p>
<pre><code>1    fn.call(obj,参数1,参数2,参数3……);
2    fn.apply(obj,[参数1,参数2,参数3……]);3    

1    // call方法直接传递
2            sum.call(box,1,2,3);
3            //apply必须将参数放在一个数组
4            sum.apply(box,[2,3,4]);
</code></pre><p>对封装的函数制定内部的回调函数的this。</p>
<pre><code>1    move(box1);
2            function move(obj){
3                animate(obj,{&quot;left&quot;:400},1000,function(){
4                //运动执行完，回调函数内执行的语句
5                    this.style.background = &quot;#0f0&quot;;
6                    animate(this,{&quot;top&quot;:400},1000,function(){
7                        this.style.background = &quot;#00f&quot;;
8                        //在调用运动函数
9                        animate(this,{&quot;left&quot;:0},1000,function(){
10                            this.style.background = &quot;#0ff&quot;;
11                            //在调用运动函数
12                            animate(this,{&quot;top&quot;:100},1000,function(){
13                                this.style.background = &quot;#f00&quot;;
14                                move(this);
15                            });
16                        });
17                    });
18                });
19            }
</code></pre>]]></content>
      
        <categories>
            
            <category> callpply </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[延时器setTimeout讲解]]></title>
      <url>http://yoursite.com/2016/11/18/title23/</url>
      <content type="html"><![CDATA[<h2 id="1、延时器"><a href="#1、延时器" class="headerlink" title="1、延时器"></a>1、延时器</h2><p>延时器：setTimeout()。在指定时间之后，执行1次函数。</p>
<p>window方法，可以省略书写。</p>
<p>比喻定时炸弹：在多少时间之后，炸弹爆炸。</p>
<p>1    语法：setTimeout(函数，等待时间);</p>
<pre><code>1    console.log(1);
2    console.log(2);
3    console.log(3);
4    setTimeout(function(){
5     console.log(&quot;booom shakalaka&quot;);
6    },1000);
7    console.log(4)
</code></pre><p>使用情况：setTimeout，如果需要在一段时间之后才执行某一个函数。只执行一次。<br>setInterval，如果需要每隔一段时间执行函数一次，反复执行。</p>
<h2 id="2、函数节流"><a href="#2、函数节流" class="headerlink" title="2、函数节流"></a>2、函数节流</h2><p>函数被调用的时候，最好有一个时间间隔，现在函数不具备这个功能。</p>
<p>事件被频繁触发，事件函数就会频繁调用。</p>
<p>解决方法：函数节流。用一个变量限制函数后面的语句到底能不能走到。定义一个延时器，将变量的限制解开。</p>
<pre><code>1    //给函数上一把锁，锁开的时候，执行函数的语句，锁关上之后，不能执行函数
2            var lock = true ;  //表示锁是开的能够执行事件函数
3            btn.onclick = function(){
4                //如果锁开着可以执行后面的语句，如果关闭，直接return返回，不执行后面的代码
5                if(lock == false){
6                    return;
7                }
8                //给函数上一把锁
9                lock = false;
10                //隔一段时间打开锁
11                setTimeout(function(){
12                    lock = true;
13                },2000);
14                console.log(Math.random());
15            }
</code></pre>]]></content>
      
        <categories>
            
            <category> setTimeout </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[异步和回调函数]]></title>
      <url>http://yoursite.com/2016/11/16/title21/</url>
      <content type="html"><![CDATA[<h2 id="1、异步"><a href="#1、异步" class="headerlink" title="1、异步"></a>1、异步</h2><p>异步（Asynchronous），是计算机多线程的异步处理。与同步处理相对，异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。</p>
<p>js如果没有特殊语句：都是单线程，必须等到前面语句执行完之后，才能执行下面的语句。</p>
<p>同步：</p>
<pre><code>1    console.log(1);    
2            console.log(2);    
3            console.log(3);    
4            console.log(4);
5            //for循环，必须跳出循环才能走后面的语句
6            for(var i = 0 ; i &lt;= 100000 ; i++){
7                console.log(1);
8            }    
9    //后面的语句必须等到前面执行完才嫩执行，否则，只能排队等待。
10            console.log(5);    
</code></pre><blockquote>
<p>同步：工作中，完成一个demo，拿给项目经理去看，你就在旁边站着等，经理看完之后，告诉你这个可以了，继续下一个工作。</p>
<p>异步：工作中，完成一个demo，拿给项目经理去看，在经理看的过程，你回工位做下一个demo，经理同时也在检查你的原demo，他做完了之后告诉你，你这个可以了，继续工作。</p>
</blockquote>
<p>如果要做异步：必须有异步语句的参与，setInterval、setTimeout、Ajax、node.js。</p>
<pre><code>1    //定时器做异步
2            console.log(1);    
3            console.log(2);    
4            console.log(3);    
5            console.log(4);
6            setInterval(function(){
7                console.log(1);
8            },30)
9            console.log(5);
</code></pre><h2 id="2、回调函数"><a href="#2、回调函数" class="headerlink" title="2、回调函数"></a>2、回调函数</h2><p>回调函数：定时器走完，可以利用一个回调函数告诉我的程序，某一个线程走完了，可以做什么工作了。</p>
<pre><code>1    var timer;
2            var sum = 0;
3            timer = setInterval(function(){
4                sum++;            
5                console.log(1);
6                if(sum == 100){
7                    //清除定时器
8                    clearInterval(timer);
9                    //可以告诉程序下一步做什么
10                    //回调函数，告诉我们定时器结束之后要做的工作
11                    end();
12                }
13            },30);
14            function end(){
15                alert(&quot;定时器走完了&quot;);
16            }
</code></pre><p>一般有一个固定的写法：将结束后的回调函数作为一个参数。每次执行可以传递函数参数。</p>
<pre><code>1       function yundong(callback){
2                var timer;
3                var sum = 0;
4                timer = setInterval(function(){
5                    sum++;            
6                    console.log(1);
7                    if(sum == 100){
8                        //清除定时器
9                        clearInterval(timer);
10                        //可以告诉程序下一步做什么
11                        //回调函数，告诉我们定时器结束之后要做的工作
12                        callback();   //必须写函数的调用
13                    }
14                },30);
15            }
</code></pre><p>某一段代码结束后，继续执行的下一个内容。</p>
<pre><code>1    animate(box1,{&quot;left&quot;:400},1000,function(){
2                //运动执行完，回调函数内执行的语句
3                box1.style.background = &quot;#0f0&quot;;
4                animate(box1,{&quot;top&quot;:400},800,function(){
5                    box1.style.background = &quot;#00f&quot;;
6                });
7            });
</code></pre>]]></content>
      
        <categories>
            
            <category> 回调函数 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS封装简单运动框架]]></title>
      <url>http://yoursite.com/2016/11/14/title20/</url>
      <content type="html"><![CDATA[<p>##1 封装简单运动框架 ##</p>
<p>两个属性要变动：left从0变到400，width从100变到300，间隔时间50毫秒。</p>
<p>可以随意定义left的步长，可以计算次数，同样可以计算宽度的步长</p>
<pre><code>1 △left = 20；

2 次数 = （400 - 0） / 20 = 20

3 △width = (300 - 100) / 20 = 10
</code></pre><p>傻瓜版程序：给固定的值进行运动，耦合性太强。</p>
<pre><code>1 //两个属性要变动：left从0变到400，width从100变到300，间隔时间50毫秒。

2//  全局信号量

3var nowleft = box.offsetLeft;

4var nowwidth = box.offsetWidth;

5var interval = 50;

6var timer;

7start.onclick = function(){

           8 timer = setInterval(function(){

            9  //全局信号量变动

        10 nowleft += 20;

        11 nowwidth += (300 - 100) / ((400 - 0) / 20 );

        12 //判断

        13  if(nowleft &gt;= 400){

        14 //同时拉到终点

        15 nowleft = 400;

        16 nowwidth = 300;

        17 clearInterval(timer);

        18 }

        19 //赋值

        20 box.style.left = nowleft + &quot;px&quot;;

        21 box.style.width = nowwidth + &quot;px&quot;;

        22  },interval);

23  };
</code></pre><h2 id="封装一个运动框架："><a href="#封装一个运动框架：" class="headerlink" title="封装一个运动框架："></a>封装一个运动框架：</h2><p>运动：运动元素，运动的结束位置以及运动的属性，运动总时间，间隔时间可以在内部定义一个具体值。</p>
<p>多个属性变动结束位置，可以一个JSON对象。</p>
<pre><code>1 var jieshujson = {

2 “width” : 300,

3 “left” : 400

4 }
</code></pre><p>封装一个函数：animate(obj,jieshuJson,time);</p>
<pre><code>1   // 封装运动函数

2   function animate(obj,jieshuJson,time){

3   //准备三个数据，开始的JSON，结束的JSON，还有步长JSON

4   //开始JSON有多少个属性，由jieshuJson决定

5   //给开始JSON添加新属性，来源于jieshuJson。

6   var kaishiJson = {};

7   for(var k in jieshuJson){

8   //通过赋初始值，用到计算后样式，将字符串转数字

9   //结束后的样式名k

10   kaishiJson[k] = parseFloat(getStyle(obj,k));

11  }

12  //console.log(kaishiJson);

13  //步长JSON = （jieshuJson - kaishiJson） / 总次数

14  //总次数 = 总时间 / 间隔时间

15  var interval = 50;

16  var zongcishu = time / interval;

17  //获得步长JSON

18  var buchangJson = {};

19  for(var k in jieshuJson){

20   //避免输入的是字符串，先转数字

21   jieshuJson[k] = parseFloat(jieshuJson[k]);

22   buchangJson[k] = (jieshuJson[k] - kaishiJson[k]) / zongcishu;

23   }

24  // console.log(buchangJson);

25  //============三个JSON都准备完了===============

26  //程序部分

27  //全局信号量接收初始值，每次的步长

28  //定义信号量JSON

29  var xinhaoliangJson = {};

30  for(var k in kaishiJson){

31  xinhaoliangJson[k] = kaishiJson[k];

32  }

33  //执行次数等于总次数，停止运动

34  //累加器

35  var cishu = 0;

36  var timer ;

37  timer = setInterval(function(){

38  //每执行一次，次数增加

39  cishu++;

40  //信号量JSON每次加一个步长

41  for(var k in xinhaoliangJson){

42  xinhaoliangJson[k] += buchangJson[k];

43  }

44  //验收，停止定时器

45  if(cishu &gt;= zongcishu){

46  //拉终停表

47  for(var k in xinhaoliangJson){

48  xinhaoliangJson[k] = jieshuJson[k];

49  }

50   clearInterval(timer);

51  }

52  //赋值,如果是透明度属性，需要单独设置

53  for(var k in xinhaoliangJson){

54  if(k == &quot;opacity&quot;){

55  obj.style.opacity = xinhaoliangJson[k];

56  obj.style.filter = &quot;alpha(opacity=&quot; + xinhaoliangJson[k] * 100 +&quot;)&quot;;

57  }else{

58  obj.style[k] = xinhaoliangJson[k] + &quot;px&quot;;

59  }

60  }

61  },interval);

62  }
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JSON对象使用方法]]></title>
      <url>http://yoursite.com/2016/11/12/title19/</url>
      <content type="html"><![CDATA[<p>概述</p>
<p>数组：存储的是一组数据，可以操作每一项内容，有自己的局限性，通过具体下标才能获得某一项。</p>
<p>数据多的时候，数组的使用效率变低。</p>
<p>JSON对象可以解决这个问题。也可以存多个数据，每个数据都有自己的名字。可以通过数据的名字得到数据的值。</p>
<p>JSON叫做JavaScript Object Notation， JavaScript对象表示法。</p>
<p>JSON对象创建的最简单的方式，就是字面量，一对大括号{}。</p>
<p>语法：{}内部包括多个数据，每个数据之间用逗号隔开，最后一个数据后不能写逗号。每一项数据都包含属性名和属性值，属性名必须用引号包括，属性值根据数据类型单独设置，键值对写法”k”:v。</p>
<pre><code>1    语法：{“k”: v, “k”: v}
创建一个最简单的JSON对象。
1    var json = {
2                &quot;name&quot; : &quot;kaola&quot;,
3                &quot;age&quot; : 18,
4                &quot;sex&quot; : &quot;男&quot;,
5                &quot;tall&quot; : 100,
6                &quot;weight&quot; : 178
7            };
8            console.log(typeof json);
</code></pre><p>数据类型：对象型。引用类型数据，变量存的是地址。</p>
<p>调用每一项数据的方法：JSON对象点语法调用属性名即可，或者用[属性名]。</p>
<pre><code>1    //调用
2            console.log(json.name);
3            console.log(json.age);
4            console.log(json.sex);
5            console.log(json.tall);
6            console.log(json[&quot;weight&quot;]);
</code></pre><p>JSON对象内部还能嵌套JSON对象。</p>
<pre><code>1    var json = {
2                &quot;name&quot; : &quot;kaola&quot;,
3                &quot;age&quot; : 18,
4                &quot;sex&quot; : &quot;男&quot;,
5                &quot;tall&quot; : 100,
6                &quot;weight&quot; : 178,
7                &quot;couple&quot; : {
8                    &quot;name&quot; : &quot;daishu&quot;,
9                    &quot;age&quot; : 17,
10                    &quot;sex&quot; : &quot;女&quot;,
11                    &quot;tall&quot; : 160,
12                    &quot;weight&quot; : 90
13                }
14            };
</code></pre><p>如果想调用内部JSON的属性，继续打点调用即可。</p>
<pre><code>1    console.log(json.couple.tall);
</code></pre><p>修改某一个属性：给调用的属性名去直接赋值。</p>
<pre><code>1    json.tall = 170;
2    console.log(json);
</code></pre><p>删除：用到一个delete关键字，后面必须加空格，书写他的属性。</p>
<pre><code>1    //删除
2            delete json.couple;
3            console.log(json);
</code></pre><p>添加：直接给JSON对象打点添加属性，属性值同时赋值。</p>
<pre><code>1    //添加
2            json.hobby = &quot;台球&quot;;
3            console.log(json);
</code></pre><h2 id="2、JSON的遍历for……in"><a href="#2、JSON的遍历for……in" class="headerlink" title="2、JSON的遍历for……in"></a>2、JSON的遍历for……in</h2><p>语法：通过属性名去遍历所有属性，从前到后依次去遍历，直到最后一个数据被遍历完。循环结束。</p>
<pre><code>1    for(var k in json){
2    语句3    }
</code></pre><p>k：表示属性名</p>
<p>json：你要遍历的那个JSON对象。输出每一个属性值：</p>
<pre><code>1    //输出每一个属性值，需要遍历JSON对象
2            for(var k in json){
3                console.log(json[k]);
4            }
</code></pre><p>复制一个JSON对象：</p>
<p>属性名都一样，属性值也一样。</p>
<p>过程：新的JSON对象接收复制来的数据。给新对象添加新属性，新属性等于原对象属性，再给新属性赋值，值等于原对象属性的值。</p>
<pre><code>1    var newJson = {};   //必须是空的JSON对象
2            for(var k in json){
3                //定义新属性并赋值
4                newJson[k] = json[k];  //红色是添加属性，绿色是调用原JSON的属性值
5            }
6            //循环完之后得到一个新的JSON
7            console.log(newJson);
</code></pre>]]></content>
      
        <categories>
            
            <category> JSON </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JSON </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[setInterval定时器]]></title>
      <url>http://yoursite.com/2016/11/10/title18/</url>
      <content type="html"><![CDATA[<h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>window给我们提供的一个方法，setInterval定时器。</p>
<pre><code>1    window.setInterval(函数,间隔时间);

1    //获得div标签
2            var box = document.getElementsByTagName(&quot;div&quot;)[0];
3            //全局变量累加
4            var nowleft = 0;
5            window.setInterval(function(){
6                //每次执行函数都让nowleft递加
7                nowleft += 20;
8                //赋值给left属性值
9                box.style.left = nowleft + &quot;px&quot;;
10            },100)
</code></pre><p>定时器执行的功能由第一个参数，函数来决定：</p>
<pre><code>1    window.setInterval(function(){
2                console.log(1);
3            },100);
</code></pre><p>第一个参数可以是一个匿名函数，也可以是一个函数的函数名。</p>
<pre><code>1    window.setInterval(shuchu,100);
2    function shuchu(){
3        console.log(1);4    }
</code></pre><p>第二种方法是工作中常用的。</p>
<p>定时器第二个参数：间隔时间。单位：毫秒，1000毫秒等于1秒。规定的是我们函数执行间隔。</p>
<pre><code>1    window.setInterval(function(){
2                //每次执行函数都让nowleft递加
3                nowleft += 20;
4                //赋值给left属性值
5                box.style.left = nowleft + &quot;px&quot;;
6            },10);
</code></pre><p>时间间隔可以决定运动的速度。间隔时间越短，函数在一秒钟内执行的次数越多，变量变动的越快。</p>
<p>运动内：时间越短，速度越快。</p>
<p>定时器的启动是不需要其他条件，只要遇到setInterval语句就会立即开启一个定时器。</p>
<p>常用的形式：会省略window对象。</p>
<pre><code>1    setInterval(move,50);
</code></pre><h2 id="2、简单运动"><a href="#2、简单运动" class="headerlink" title="2、简单运动"></a>2、简单运动</h2><p>原理：利用定时器，每个多长时间，走多少步。</p>
<p>不需要知道要走多远，只要知道每隔多长时间走多长。</p>
<p>视觉暂留：视觉残留。人的视觉有一个残留时间０.１秒－０.４秒。</p>
<pre><code>1    //定义定时器，让宽度每隔100毫秒变宽一点
2            setInterval(move,100);
3            function move(){
4                now += 10;
5                //给元素宽度赋值
6                box.style.width = now + &quot;px&quot;;
7            }
</code></pre><p>间隔时间在一秒钟内让函数执行几次，次数可以叫做帧频，frame percent second，每秒执行几帧，简称fps。一个运动的帧频是24fps，指的是一秒钟动24次。</p>
<p>控制运动速度：帧频越大，1秒运动的次数越多。间隔时间变短，帧频变大。</p>
<p>第一种方法：缩短间隔时间。</p>
<pre><code>1    setInterval(move,20);
</code></pre><p>第二种方法：增大步长。</p>
<pre><code>1    now += 30;
</code></pre><h2 id="3、清除定时器clearInterval"><a href="#3、清除定时器clearInterval" class="headerlink" title="3、清除定时器clearInterval"></a>3、清除定时器clearInterval</h2><p>又叫停止定时器。</p>
<p>clearInterval：清空一个定时器的作用。</p>
<p>方法：将定时器setInterval给一个变量，要停止的时候，将变量传给clearInterval的参数。</p>
<pre><code>1    var timer;
2    start.onclick = function(){
3        timer = setInterval(move,100);
4    };
5    end.onclick = function(){
6                //关闭定时器
7        clearInterval(timer);
8    };
</code></pre><h2 id="4、存在的问题"><a href="#4、存在的问题" class="headerlink" title="4、存在的问题"></a>4、存在的问题</h2><p>第一个问题：</p>
<blockquote>
<p>如果多次点击一个运动开始的按钮，会开启多个定时器，在一个时间内有多个定时器都在隔一段时间执行函数。造成一个现象，运动的变量每一个间隔时间变动的值是多个定时器累加的效果。运动速度回越来越快。</p>
</blockquote>
<p>防骚扰操作：每开启一个定时器之前，先停止一次定时器。设表先关。</p>
<pre><code>1    var timer;
2    start.onclick = function(){
3        //设表先关
4        clearInterval(timer);
5        timer = setInterval(move,100);
6    };
7    end.onclick = function(){
8        //关闭定时器
9        clearInterval(timer);
10    };
</code></pre><p>第二个问题：</p>
<blockquote>
<p>有时需要元素停在一个固定位置，如果步长给的不合理，不会正好停在这个位置，有误差。<br>解决方法：先将变量判断，if语句的后验收，如果大于终点值，强制给变量赋值，再停止定时器。拉终停表。</p>
</blockquote>
<pre><code>1    start.onclick = function(){
2        timer = setInterval(function(){
3            //设置步长
4            now += 13;
5            // 给元素属性赋值
6            //后验收
7            if(now &gt; 500){
8            //拉回到终点，然后停止定时器
9                now = 500;
10                clearInterval(timer);
11            }
12            box.style.left = now + &quot;px&quot;;
13            console.log(now);
14    
15        }, 50);16    }
</code></pre>]]></content>
      
        <categories>
            
            <category> setInterva </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[获取尺寸和位置的方法]]></title>
      <url>http://yoursite.com/2016/11/08/title17/</url>
      <content type="html"><![CDATA[<p>前面封装的函数得到的值都是字符串，使用的时候，一部分需要转成数字取计算。JS提供了几个常用的快捷尺寸，得到的就是数字类型的数据。</p>
<blockquote>
<p>offsetLeft</p>
<p>offsetTop</p>
<p>offsetWidth</p>
<p>offsetHeight</p>
<p>clientWidth</p>
<p>clientHeight</p>
</blockquote>
<h2 id="1、offsetLeft和offsetTop"><a href="#1、offsetLeft和offsetTop" class="headerlink" title="1、offsetLeft和offsetTop"></a>1、offsetLeft和offsetTop</h2><p>严重的兼容性问题。以offsetLeft为例。offset具有偏移量的含义。元素天生具有一个属性，认识一个叫做offsetParent的元素，偏移参考元素。</p>
<p>调用方法：打点调用offsetLeft。</p>
<p>兼容IE9以上及高级浏览器</p>
<pre><code>1    &lt;div class=&quot;box1&quot;&gt;
2            &lt;div class=&quot;box2&quot;&gt;
3                &lt;div class=&quot;box3&quot;&gt;
4                    &lt;p&gt;&lt;/p&gt; //本身不管有没有定位，祖先元素都没有定位，偏移参考元素就是body
5                &lt;/div&gt;
6            &lt;/div&gt;
7        &lt;/div&gt;

8    &lt;div class=&quot;box1&quot;&gt;//有定位
9        &lt;div class=&quot;box2&quot;&gt;   //有定位  距离p元素最近且有定位，是offsetParent
10            &lt;div class=&quot;box3&quot;&gt;  //无定位
11                &lt;p&gt;&lt;/p&gt; //本身不管有没有定位，祖先元素有定位，偏移参考元素就是距离最近的box2
12            &lt;/div&gt;
13        &lt;/div&gt;
1    &lt;/div&gt;
</code></pre><blockquote>
<p>offsetParent：不管元素自身有没有定位，如果祖先元素有定位，偏移参考元素就是距离该元素最近的有定位的祖先元素。如果祖先元素都没有定位，偏移参考元素变成body。</p>
<p>offsetLeft：就是自身元素的左边框外到offsetParent的左边框内部的距离。</p>
<p>offsetTop与offsetLeft一样：自身元素的上边框外到offsetParent的上边框内部的距离。</p>
</blockquote>
<p>IE6/7浏览器：</p>
<p>区分两种情况，元素自身有没有定位：</p>
<blockquote>
<p>第一种：元素自身没有定位。</p>
<p>offsetParent：距离最近的有宽高的祖先元素，如果都没有宽高，参考body。</p>
<p>offsetLeft：与高级浏览器一样，元素左边框外到offsetParent的左边框内部的距离。</p>
<p>1    <div 2="" 3="" 4="" class="box1" 无宽高="" <div="" 有宽高，就是offsetparent="" <p=""><br>6            </div><br>7        </p>
<p>第二种情况：元素自身有定位。</p>
<p>offsetParent：与高级浏览器一样，距离最近的有定位的祖先元素，没有的话参考body。</p>
<p>offsetLeft：与高级浏览器一样，自身的左边框外到offsetParent的左边框内部的距离。</p>
<p>8    <div 9="" 10="" 11="" class="box1" 有宽高，有定位="" <div="" ，offsetparent="" 有宽高，无定位="" <p=""><br>13            </div><br>1        </p>
</blockquote>
<p>IE8浏览器：</p>
<p>offsetParent：与高级浏览器选择方法一样。</p>
<p>offsetLeft：自身的左边框外到offsetParent的左边框外，多了一条offsetParent的左边框宽度。</p>
<p>总结：<br>    高级浏览器    IE8    IE6/7</p>
<pre><code>offsetParent    不论自身有没有定位，距离元素最近的有定位的祖先元素，如果都没有定位，参考body    与高级浏览器一样    如果自身没定位，距离元素最近的有宽高的祖先元素，如果都没有宽高，参考body。

如果自身有定位，与高级浏览器一样

offsetLeft    自身的左边框外到offsetParent的左边框内部的距离    比高级浏览器多一条

offsetParent的左边框宽度    与高级浏览器一样
</code></pre><p>写法：元素自身定位，祖先元素定位无边。</p>
<h2 id="2、offsetWidth和offsetHeight"><a href="#2、offsetWidth和offsetHeight" class="headerlink" title="2、offsetWidth和offsetHeight"></a>2、offsetWidth和offsetHeight</h2><p>与offsetParent没有关系。自身的实际占有的宽度和高度。</p>
<blockquote>
<p>offsetWidth = width + padding + border；</p>
<p>offsetHeight = height + padding + border；</p>
</blockquote>
<p>全线浏览器兼容。</p>
<p>特殊情况：</p>
<blockquote>
<p>不写宽度：会去继承父亲的宽度，得到的offsetWidth是具体的像素值。不会返回100%。</p>
<p>不写高度：靠内部的内容撑高，具体的像素值。</p>
</blockquote>
<p>谷歌浏览器的加载机制：在加载图片的时候，不会等待，先去加载JS。得到撑高的高度时，没有图片撑高的部分，js加载完了之后，图片才会显示。</p>
<p>解决方法：window.onload事件去解决。</p>
<pre><code>1    window.onload = function(){
2                var op = document.getElementsByTagName(&quot;p&quot;)[0];
3                var h = document.getElementsByTagName(&quot;h1&quot;)[0];            
4                alert(op.offsetHeight);
5            }
</code></pre><h2 id="3、clientWidth和clientHeight"><a href="#3、clientWidth和clientHeight" class="headerlink" title="3、clientWidth和clientHeight"></a>3、clientWidth和clientHeight</h2><p>基本全线兼容，只有IE6有一点小问题。</p>
<blockquote>
<p>clientWidth = width + padding；</p>
<p>clientHeight = height +padding；</p>
<p>特殊情况：</p>
<p>不写宽度：会去继承父亲的宽度，得到的ｃｌｉｅｎｔWidth是具体的像素值。不会返回100%。ＩＥ６返回０.</p>
<p>不写高度：靠内部的内容撑高，具体的像素值。ＩＥ６返回０.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> offsetLeft </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[getComputedStyle使用方法]]></title>
      <url>http://yoursite.com/2016/11/05/title16/</url>
      <content type="html"><![CDATA[<h1 id="计算后样式"><a href="#计算后样式" class="headerlink" title="计算后样式"></a>计算后样式</h1><p>点语法不能得到计算后样式，只能得到和更改行内样式。计算后样式：其实是多个选择器叠加的最终样式。</p>
<h2 id="1、高级浏览器"><a href="#1、高级浏览器" class="headerlink" title="1、高级浏览器"></a>1、高级浏览器</h2><pre><code>1    var box = document.getElementById(&quot;box&quot;);
2    console.log(box.style.width); 
</code></pre><p>W3C制定的标准API，所有现代浏览器（包括IE9，但不包括之前的版本）都window.getComputedStyle()，该方法接收一个要进行样式计算的元素，并返回一个可以进行属性查询的接口。返回接口提供了一个名为getPropertyValue()的方法，用于检索特定样式属性的计算样式。getPropertyValue方法接收css属性名称，而不是驼峰式的名称。getPropertyValue()可以不写，直接用方括号来检索属性也可以。</p>
<p>兼容问题：在高级浏览器和IE9以上才能使用。</p>
<p>window.getComputedStyle：window指的是浏览器对象，可以省略window。内部有一个获得计算后样式的方法。</p>
<p>传入一个元素对象，返回时这个元素的所有计算后样式。直接写在参数位置，不需要加引号，因为我是传的是元素对象的变量。</p>
<pre><code>1    console.log(window.getComputedStyle(box));
</code></pre><p>进一步可以打点调用getPropertyValue：获得属性值。</p>
<blockquote>
<p>第一种方法：小括号内的参数直接写css属性名，直接在小括号内的引号内书写，必须写css内的名字格式，不能用驼峰。</p>
</blockquote>
<pre><code>1    //var a = window.getComputedStyle(box).getPropertyValue(&quot;width&quot;);
2    var a = window.getComputedStyle(box).getPropertyValue(&quot;backgroundColor&quot;);
</code></pre><p>必须使用css的写法。</p>
<blockquote>
<p>第二种方法：不用小括号调用，用中括号调用，将属性名写在中括号内部。不需要getPropertyValue。属性名必须用引号包裹。这种方法可以用驼峰命名法。</p>
</blockquote>
<pre><code>1    var a = window.getComputedStyle(box)[&quot;width&quot;];
</code></pre><p>复合属性既能用css写法，也能用驼峰。</p>
<pre><code>1    var a = window.getComputedStyle(box)[&quot;backgroundColor&quot;];
</code></pre><h2 id="2、低版本浏览器IE6-7-8"><a href="#2、低版本浏览器IE6-7-8" class="headerlink" title="2、低版本浏览器IE6/7/8"></a>2、低版本浏览器IE6/7/8</h2><p>IE9之前的版本提供了一个专有API访问计算后样式：附加在元素身上的currentStyle属性，它表现和style点语法一样，使用驼峰式访问。</p>
<p>使用方法与点语法调用style一模一样。点语法继续调用属性。</p>
<pre><code>1    //低版本浏览器
2    var a = box.currentStyle.width;
1    //var b = box.currentStyle.backgroundColor;
3    
4    box.innerHTML = a;
</code></pre><p>也可以用中括号的方式调用：只能用驼峰，不能用css写法。</p>
<pre><code>2    var a = box.currentStyle[&quot;width&quot;];
3    var b = box.currentStyle[&quot;background-color&quot;];
</code></pre><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>3、兼容写法 ##</p>
<p>不是去测试浏览器版本，检测浏览器能力。如果浏览器具备调用某一个方法的能力，就使用。</p>
<p>能力检测：将方法作为判断条件。</p>
<pre><code>1    var box = document.getElementById(&quot;box&quot;);
2            //通过能力检测写兼容
3            if(window.getComputedStyle){
4                //高级浏览器
5                var a = window.getComputedStyle(box)[&quot;background-color&quot;];
6            }else if(box.currentStyle){
7                var a = box.currentStyle[&quot;backgroundColor&quot;]
8            }
9            box.innerHTML = a;
</code></pre><p>去封装一个函数，输入一个属性名，输出一个兼容后的属性值。</p>
<pre><code>1    //封装一个函数，兼容高级浏览器和低版本浏览器
2            function fetchComputedStyle(ele,property){
3                //判断是高级浏览器还是低版本
4                //能力测试判断
5                if(window.getComputedStyle){
6                    //针对用户输入的属性名进行兼容写法，不管是不是驼峰，都改成横线写法
7                    property = property.replace(/([A-Z])/g,function(match,$1){
8                        return &quot;-&quot; + $1.toLowerCase();
9                    });
10                    return window.getComputedStyle(ele)[property];
11                }else if(ele.currentStyle){
12                    //针对用户输入的属性名进行兼容写法，不管是不是驼峰，都改成驼峰
13                    property = property.replace(/\-([a-z])/gi,function(match,$1){
14                        return $1.toUpperCase();
15                    });
16                    return ele.currentStyle[property];
17                }
18            }
</code></pre>]]></content>
      
        <categories>
            
            <category> getComputedStyle </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[getElementsByTagName使用方法]]></title>
      <url>http://yoursite.com/2016/11/03/title15/</url>
      <content type="html"><![CDATA[<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>getElementsByTagName：get获取  elements多个元素  by 通过    tagname标签名字。</p>
<p>参数：引号包裹标签名。</p>
<p>通过p标签获得元素：查找所有页面上的p标签，得到的是所有标签元素对象组成的数组。</p>
<pre><code>1    &lt;p&gt;1&lt;/p&gt;
2        &lt;p&gt;2&lt;/p&gt;
3        &lt;p&gt;3&lt;/p&gt;
4        &lt;p&gt;4&lt;/p&gt;
5        &lt;p&gt;5&lt;/p&gt;
6        &lt;p&gt;6&lt;/p&gt;
7        &lt;script&gt;
8            //通过p标签获取元素
9            var ps = document.getElementsByTagName(&quot;p&quot;);
10            console.log(ps);
11            console.log(typeof ps);
12        &lt;/script&gt;


1    //得到的是数组，得到一个具体的p元素
2            console.log(ps[0]);
3            console.log(ps.innerHTML);
4            console.log(ps[0].innerHTML);
</code></pre><p>通过数组下标得到的数据才是我们的具体的元素对象，才有控制元素的属性和方法。</p>
<p>操作内部的每个元素对象，必须遍历元素</p>
<pre><code>1    //我要看得到的元素内部的html内容
2            //遍历对象数组，得到每一个元素对象，打点调用属性和方法
3            for(var i = 0 ; i &lt; ps.length ; i++){
4                console.log(ps[i].innerHTML);
5            }
</code></pre><p>通过标签名获得元素，是页面内所有的这个名的元素，不论嵌套多深。</p>
<pre><code>1    &lt;div&gt;
2            &lt;div&gt;
3                &lt;p&gt;7&lt;/p&gt;
4            &lt;/div&gt;
5        &lt;/div&gt;
</code></pre><p>数组有下标，下标顺序按照什么来排序：按照元素出现的顺序排序，首标签出现靠前，在数组里位置靠前。跟嵌套关系无关。</p>
<pre><code>1    &lt;div class=&quot;box1&quot;&gt;
2            &lt;div class=&quot;box2&quot;&gt;
3                &lt;div class=&quot;box3&quot;&gt;
4                    &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt;
5                    &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt;
6                &lt;/div&gt;
7                &lt;div class=&quot;box6&quot;&gt;&lt;/div&gt;
8            &lt;/div&gt;
9        &lt;/div&gt;
10    //遍历得到的div数组的单个元素的class。
11            for(var i = 0 ; i &lt; divs.length ; i++){
12                console.log(divs[i].className);
13            }
</code></pre><p>如果得到元素在页面内只有一个，使用元素对象时也必须用数组的方法得到这个对象。</p>
<pre><code>1    //选中的如果只有一个p元素
2    console.log(ps);
3    ps[0].style.background = &quot;yellowgreen&quot;;
</code></pre><p>连续打点调用：不仅仅document可以使用这个方法， 任何HTML元素也能调用这个方法。可以连续打点调用get系列方法。</p>
<pre><code>1    //连续打点调用方法
2            //将范围缩小到id为box1的标签内部
3            var ps = document.getElementById(&quot;box1&quot;).getElementsByTagName(&quot;p&quot;);
4            for(var i = 0 ; i &lt; ps.length ; i++){
5                ps[i].style.background = &quot;#f00&quot;;
6            }    
</code></pre><p>等价写法：</p>
<pre><code>1    var box1 = document.getElementById(&quot;box1&quot;);
2            //在box1里去找p 元素
3    var ps = box1.getElementsByTagName(&quot;p&quot;);
</code></pre><p>还可以对getElementsByTagName连续打点调用。</p>
<pre><code>1    //连续使用getElementsByTagName获得元素，不用id。
2            var spans = document.getElementsByTagName(&quot;div&quot;)[1].getElementsByTagName(&quot;p&quot;)[2].getElementsByTagName(&quot;span&quot;);
3            spans[2].style.color = &quot;#f00&quot;;
</code></pre><p>错误写法：</p>
<pre><code>1    var spans = document.getElementsByTagName(&quot;div&quot;)[1].document.getElementsByTagName(&quot;p&quot;)[2].getElementsByTagName(&quot;span&quot;);
</code></pre><p>更加好用的方法：先用id限制范围，用标签选元素。</p>
<pre><code>1    var spans = document.getElementById(&quot;p1&quot;).getElementsByTagName(&quot;span&quot;);
</code></pre><h2 id="2、批量控制"><a href="#2、批量控制" class="headerlink" title="2、批量控制"></a>2、批量控制</h2><p>①批量添加事件</p>
<p>通过标签名得到的是一个元素对象的数组，对数组遍历，里面每一项分别添加事件。批量添加过程。<br>过程中注意闭包影响：</p>
<pre><code>第一种解决方法：IIFE
1    // 选取第一个盒子的所有p
2            var box1 = document.getElementById(&quot;box1&quot;);
3            var ps = box1.getElementsByTagName(&quot;p&quot;);
4            
5            //批量添加，for循环
6            //闭包对函数内部语句的影响
7            for(var i = 0 ; i &lt; ps.length ; i++){
8                //用IIFE解决闭包问题
9                (function(a){
10                    ps[a].onclick = function(){
11                        ps[a].style.background = &quot;yellowgreen&quot;;
12                        // console.log(ps[i].innerHTML);
13                    };    
14                })(i);            
15            }
</code></pre><p>第二种方法：我们可以给一个对象自定义属性，用这个属性存储每次循环是传进来的变量的值。<br>事件函数内部有一个关键字叫做this，它本身就是指代的触发事件的对象本身。</p>
<pre><code>1    //用自定义属性和事件函数内部的this来解决闭包问题
2            for(var i = 0 ; i &lt; ps.length ; i++){
3                //自定义一个属性存储下标
4                ps[i].index = i;
5                //绑定事件
6                ps[i].onclick = function(){
7                    //谁触发事件，它就有一个this指向他自身，this本身就是这个对象
8                    //this.index的值就是触发的这个对象的index。
9                    ps[this.index].style.background = &quot;yellowgreen&quot;;
10                }
11            }
</code></pre><p>第二种方法较为常用。</p>
<p>②批量控制</p>
<p>第一种：用两个按钮控制</p>
<pre><code>1    //选中所有input标签
2            var checks = document.getElementById(&quot;box&quot;).getElementsByTagName(&quot;input&quot;);
3            var all = document.getElementById(&quot;all&quot;);
4            var none = document.getElementById(&quot;none&quot;);
5    
6            //批量全选
7            all.onclick = function(){
8                //遍历每一个多选框，添加checked属性
9                for(var i = 0 ; i &lt; checks.length ; i++ ){
10                    checks[i].checked = &quot;checked&quot;;
11                }
12            };
13            none.onclick = function(){
14                //遍历每一个多选框，更改checked属性
15                for(var i = 0 ; i &lt; checks.length ; i++ ){
16                    checks[i].checked = &quot;&quot;;
17                }
18            }
</code></pre><p>第二种方法：一个按钮控制。</p>
<pre><code>1    //给all这个元素添加点击事件
2            all.onclick = function(){
3                //判断all的value值如果是全选，将前面全部选中，将自己的value改成全不选
4                // 如果是全不选，将前面全部取消选择，将自己改成全选
5                if(all.value == &quot;全选&quot;){
6                    //全部选中
7                    for(var i = 0 ; i &lt; checks.length ; i++ ){
8                        checks[i].checked = &quot;checked&quot;;
9                    }
10                    // value改为全不选
11                    all.value = &quot;全不选&quot;;
12                }else{
13                    //全部不选中
14                    for(var i = 0 ; i &lt; checks.length ; i++ ){
15                        checks[i].checked = &quot;&quot;;
16                    }
17                    // value改为全选
18                    all.value = &quot;全选&quot;;
19                }
20            };
</code></pre><p>第三种：一个按钮。用一个全局信号量当做一个中间值。全选和全不选作为两种状态。</p>
<pre><code>1    //信号量方法
2            //如果信号量为1，表示我要全选，0表示全不选
3            var sema = 1;
4            var str = &quot;&quot;;
5            //添加点击事件
6            all.onclick = function(){
7                //判断信号量是谁，如果是1，表示全选，str变成checked选中，信号量要改为0，value要变成全不选
8                //如果是1，str变成checked选中，如果不是变成“”
9                str = sema == 1 ? &quot;checked&quot; : &quot;&quot;;
10                //信号量更改
11                sema = sema == 1 ? 0 : 1;
12                //改按钮的value
13                all.value = sema == 0 ? &quot;全不选&quot; : &quot;全选&quot;;
14                //调用变动函数
15                choose();
16            }
17            //变动函数
18            function choose(){
19                for(var i = 0 ; i &lt; checks.length ; i++ ){
20                    checks[i].checked = str;
21                }
22            }
</code></pre><h2 id="3、对应控制"><a href="#3、对应控制" class="headerlink" title="3、对应控制"></a>3、对应控制</h2><p>用一个元素去控制另外一个元素的变动。需要找到之间的关系。一般找数组下标。</p>
<pre><code>1    //获取所有元素
2            var ps1 = document.getElementById(&quot;box1&quot;).getElementsByTagName(&quot;p&quot;);
3            var ps2 = document.getElementById(&quot;box2&quot;).getElementsByTagName(&quot;p&quot;);
4    
5            //批量给PS1里的元素加事件
6            for(var i = 0 ; i &lt; ps1.length ; i++){
7                //自定义属性存储下标
8                ps1[i].index = i;
9                ps1[i].onclick = function(){
10                    ps2[this.index].style.background = &quot;yellowgreen&quot;;
11                }
12            }
</code></pre><p>4、排他控制<br>保留自己，排除别人。</p>
<p>排他控制方法：在点击事件函数内部多做一步工作，先将所有元素回归默认样式，给对应的元素再添加单独样式。</p>
<pre><code>1    //获取所有元素
2            var ps1 = document.getElementById(&quot;box1&quot;).getElementsByTagName(&quot;p&quot;);
3            var ps2 = document.getElementById(&quot;box2&quot;).getElementsByTagName(&quot;p&quot;);
4    
5            //批量给PS1里的元素加事件
6            for(var i = 0 ; i &lt; ps1.length ; i++){
7                //自定义属性存储下标
8                ps1[i].index = i;
9                ps1[i].onclick = function(){
10                    //先将所有元素回归默认样式，给对应的元素再添加单独样式
11                    //排他操作
12                    for(var j = 0 ; j &lt; ps1.length ; j++){
13                        ps1[j].style.background = &quot;skyblue&quot;;
14                        ps2[j].style.background = &quot;skyblue&quot;;
15                    }
16                    
17                    //给这个元素和对应的p加特殊样式
18                    ps1[this.index].style.background = &quot;yellowgreen&quot;;
19                    ps2[this.index].style.background = &quot;pink&quot;;
20                }
21            }
</code></pre>]]></content>
      
        <categories>
            
            <category> getElementsByTagName </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DOM操作方法]]></title>
      <url>http://yoursite.com/2016/10/31/title14/</url>
      <content type="html"><![CDATA[<h2 id="1、DOM体验"><a href="#1、DOM体验" class="headerlink" title="1、DOM体验"></a>1、DOM体验</h2><p>DOM（Document Object Model，文档对象模型）描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。这使得JavaScript操作HTML，不是在操作字符串，而是在操作节点，极大地降低了编程难度。编写例子整体感知一下这个事儿。</p>
<pre><code>1    //获得元素
2            var oDiv = document.getElementById(&quot;box&quot;);
3            var oKaola = document.getElementById(&quot;kaola&quot;);
4            //添加点击事件，盒子变色，图片变图
5            oDiv.onclick = function(){
6                oDiv.style.backgroundColor = &quot;yellowgreen&quot;;
7                oKaola.src = &quot;images/kaola2.jpeg&quot;;
8            }
</code></pre><p>DOM规范在1998年10月制定，称为“DOM1级规范”。随着ECMAScript的升级，DOM也发展出了2级规范、3级规范。另外，早于1998年的DOM也有事实上的标准，我们称为0级规范。</p>
<p>DOM对很多东西做了抽象，提供了丰富的API：取得元素、css样式、事件、运动、元素尺寸位置、节点操作。每个知识体系都非常庞大，千丝万缕。我们今天的课程，把一些线头都掐出来，日后的课程深入研究每个线头。</p>
<h2 id="2、获取元素"><a href="#2、获取元素" class="headerlink" title="2、获取元素"></a>2、获取元素</h2><p>JavaScript通过document对象表示文档，它表示整个页面。它有很多属性和方法，包含了绝大多数多页面的特征和操作。学习DOM，说白了就是学习document对象。例如document.title属性，就是页面的标题。</p>
<pre><code>1    document.title = &quot;获取元素&quot;;
2    alert(document.title);
</code></pre><p>DOM操作，往往都是从取得某个（些）HTML元素开始，然后对这个（些）元素进行一些操作。所以得到元素是非常重要的。得到元素的操作可以使用document对象的两个方法来完成：</p>
<pre><code>document.getElementById()
document.getElementsByTagName()
</code></pre><p>getElementById：get得到  element 元素 by 通过  id id属性值。通过id名字获得某一个元素。</p>
<blockquote>
<p>驼峰命名法：一个标识符由多个英文单词组成，首个单词正常小写，从第二个开始每个单词首字符要大写，其他的小写。</p>
</blockquote>
<p>JS的书写位置：如果要想获得某一个元素，那么获得之前，元素必须是加载过的。js的书写顺序，需要写在标签后面。</p>
<pre><code>1    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;   //标签写在获取元素的前面
2        &lt;script&gt;
3            // document.title = &quot;获取元素&quot;;
4            // alert(document.title);
5    
6            //获取div元素
7            var box = document.getElementById(&quot;box&quot;);
8            box.onclick = function(){
9                box.style.border = &quot;10px solid #0f0&quot;;
10            }
11        &lt;/script&gt;
</code></pre><p>获取元素语法：直接将获得的这个元素的id属性值写在参数里。名字必须加引号。跟css区别，不需要加#。</p>
<p>错误写法：</p>
<pre><code>1    var box = document.getElementById(&quot;#box&quot;);
</code></pre><p>正确写法：</p>
<pre><code>1    var box = document.getElementById(&quot;box&quot;);
</code></pre><p>获得的元素的数据类型。通过检测，得到一个对象类型。</p>
<pre><code>1    console.log(typeof box);
</code></pre><p>也就是说，我们通过id获得元素本身又是一个对象类型的数据，内部还包含了一些属性和方法。可以对这些元素打点继续调用属性和方法。</p>
<p>注意：id名不能重复。</p>
<pre><code>1    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
2    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
3    //id名字不能重复，如果有重复的，只得到第一个
4            var oBox = document.getElementById(&quot;box&quot;);
5            oBox.style.backgroundColor = &quot;#0f0&quot;;
</code></pre><p>id大小写要严格区分，但是在IE6、7中，大小写是不区分的。</p>
<p>IE7及较低版本还有一个怪癖，表单元素name特性也会被当做id。为了避免这个问题，所以页面上的name最好也不要和任何id相同。</p>
<h2 id="3、操作html"><a href="#3、操作html" class="headerlink" title="3、操作html"></a>3、操作html</h2><p>获取一个html标签之后，得到一个对象类型变量。</p>
<p>可以控制html的属性：得到属性、更改属性。</p>
<p>有两种选择：getAttribute()和setAttribute()方法，或者使用点语法。</p>
<blockquote>
<p>点语法：</p>
</blockquote>
<p>获得元素属性：直接在元素对象后点语法调用，输出属性值。</p>
<pre><code>1    //获得img标签的src属性
2            console.log(oImg.src);
3            console.log(oImg.id);
4            console.log(oImg.alt);
</code></pre><p>更改html标签属性：可以通过点语法调用相关属性后，通过等号给这个属性赋值，更改属性值的方法。</p>
<pre><code>1    //通过点语法得到相关属性，等号赋新值
2    oImg.src = &quot;images/kaola2.jpeg&quot;;
3    //不要去更改id属性，id是只读。
</code></pre><blockquote>
<p>第二种方法：</p>
</blockquote>
<p>得到属性值getAttribute()，需要得到什么属性，直接将名字写在小括号内。</p>
<pre><code>1    console.log(oImg.getAttribute(&quot;src&quot;));   //得到的就是属性值的字符串
2    console.log(oImg.getAttribute(&quot;alt&quot;));   //得到的就是属性值的字符串
</code></pre><p>设置属性值setAttribute()，设置属性的新的属性值，直接写在小括号内，用引号包裹。</p>
<pre><code>1    oImg.setAttribute(&quot;src&quot;,&quot;images/kaola.jpg&quot;);
</code></pre><p>第一个参数：设置属性名，第二个参数：新的属性值，中间用逗号隔开。</p>
<p>区别：</p>
<blockquote>
<p>①html标签可以使用自定义属性，自定义属性调用和更改都不能使用点语法实现。getAttribute（）可以获得自定义属性，setAttribute（）可以更改自定义属性。</p>
</blockquote>
<pre><code>1    //自定义属性
2    oImg.setAttribute(&quot;kaola&quot;,&quot;yuanxing&quot;);
3            console.log(oImg.kaola);
4            console.log(oImg.getAttribute(&quot;kaola&quot;));
</code></pre><blockquote>
<p>②点语法调用html属性时，有一些属性名需要进行更改，这些属性名可能是其他的关键字，规避这些名字。getAttribute方法不用规避，直接写原属性名。</p>
<p>class        改为className</p>
<p>for        改为htmlFor</p>
<p>rowspan        改为rowSpan</p>
<p>colspan        改为colSpan</p>
</blockquote>
<pre><code>1    //更改一些属性名的写法，只限于点语法
2            console.log(oImg.class);
3            console.log(oImg.className);
</code></pre><p>getAttribute方法不需要改变写法，如果改了反而错。</p>
<pre><code>1    console.log(oImg.getAttribute(&quot;className&quot;));
2    console.log(oImg.getAttribute(&quot;class&quot;));
</code></pre><blockquote>
<p>③如果调用style属性得到的还是一个css对象，可以继续打点调用css的样式，遇到复合属性的单一写法，点语法需要些驼峰命名，另外一种方法不需要。</p>
</blockquote>
<p>text-  font-  line-   background-   border-  margin-  padding- </p>
<pre><code>1    //console.log(oImg.style.border-color);
2    console.log(oImg.style.borderColor);
</code></pre><p>getAttribute方法直接写css内的命名就行。</p>
<blockquote>
<p>④点语法得到的style属性是一个对象，可以继续打点调用内部的属性。getAttribute方法得到style属性，是一个字符串，不能再继续打点调用。</p>
</blockquote>
<pre><code>1    //console.log(oImg.style.border-color);
2            console.log(typeof oImg.style);
3            console.log(typeof oImg.getAttribute(&quot;style&quot;));
</code></pre><p>点语法才能继续打点调用css样式属性。</p>
<p>总结：除了自定义属性用getAttribute和setAttribute之外，其他情况都用点语法。</p>
<h2 id="4、操作css"><a href="#4、操作css" class="headerlink" title="4、操作css"></a>4、操作css</h2><p>通过对一个元素对象打点调用style属性，得到的是css样式的一个对象。可以通过得到css样式的对象，进行css属性的读取和更改。</p>
<p>通过点语法读取和更改的css样式都是行内样式。</p>
<pre><code>1    &lt;img src=&quot;images/kaola.jpg&quot; alt=&quot;这是一只考拉&quot; style=&quot;border:2px solid #f00;&quot; class=&quot;tupian&quot; id=&quot;image&quot; kaola=&quot;bianxing&quot; /&gt;
2    //点语法得到样式都是行内样式，更改的也是行内样式
3            console.log(oImg.style.width);
4            console.log(oImg.style.border);
</code></pre><p>通过点语法改的css样式属性都是在行内式进行更改的。</p>
<pre><code>1    //更改样式
2            oImg.style.height = &quot;400px&quot;;
</code></pre><p>语法注意：点语法直接调用。如果给属性赋新值，通过等号赋值，右侧的值必须写在一对儿引号里，css里面怎么写属性值，引号里直接就这么些。</p>
<pre><code>1    oImg.style.height = &quot;400px&quot;;
2    oImg.style.borderColor = &quot;#00f&quot;;
</code></pre><p>innerHTML表示标签内的文本。</p>
<p>input标签有自己的获得方法，点语法直接调用value属性。</p>
<pre><code>1    console.log(oBox.innerHTML);
2    console.log(oTxt.value);
</code></pre><h2 id="5、事件"><a href="#5、事件" class="headerlink" title="5、事件"></a>5、事件</h2><blockquote>
<p>DOM0级事件：</p>
<p>onclick        单击事件</p>
<p>ondblclick      双击事件</p>
<p>onmouseover   鼠标移上事件</p>
<p>onmouseout    鼠标移出事件</p>
<p>onmousedown  鼠标按下事件</p>
<p>onmouseup    鼠标弹起事件</p>
<p>onfocus       获得焦点事件</p>
<p>onblur        失去焦点事件</p>
<p>onload         加载事件</p>
</blockquote>
<p>事件监听：给一个元素去添加事件，如果触发事件就会执行相应的功能。JS在加载的时候，先去整个页面去查看，看谁绑定了事件，引擎就会给这个元素进行监控（监听），监控我们的元素有没有被触发这个事件的动作，如果触发动作，在瞬间执行相应的功能。</p>
<p>语法：给哪个元素绑定事件，就给这个元素对象打点添加对应的事件，用等号给这个事件添加事件函数。</p>
<pre><code>2    box.onmouseover = function(){
3    事件触发之后要做的事。
4    };
</code></pre><p>如果事件被触发，立即执行后面的事件函数，不需要加()调用函数。</p>
<pre><code>6    //获取元素
7            var oImg = document.getElementById(&quot;image&quot;);
8            // 绑定鼠标移上的效果，变图片
9            oImg.onmouseover = function(){
10                oImg.src = &quot;images/kaola2.jpeg&quot;;
11            };
</code></pre><p>调用函数方法：用小括号调用，触发事件执行事件函数。</p>
<p>onclick：单击事件,鼠标单击事件元素触发事件。</p>
<pre><code>5    //鼠标单击事件
6            oImg.onclick = function(){
7                oImg.style.width = &quot;300px&quot;;
8            };

4    //鼠标双击事件
5            oImg.ondblclick = function(){
6                oImg.style.width = &quot;300px&quot;;
7            };

3    //绑定鼠标移上的效果，变图片
4            oImg.onmouseover = function(){
5                oImg.src = &quot;images/kaola2.jpeg&quot;;
6            };
7            //鼠标移出效果，一般与鼠标移上成对出现
8            oImg.onmouseout = function(){
9                oImg.src = &quot;images/kaola.jpg&quot;;
10            };

2    //获取元素
3            var oBox = document.getElementById(&quot;box&quot;);
4            //添加鼠标移上和移出事件
5            oBox.onmouseover = function(){
6                oBox.style.backgroundImage = &quot;url(images/jd2.png)&quot;;
7            };
8            oBox.onmouseout = function(){
9                oBox.style.backgroundImage = &quot;url(images/jd1.png)&quot;;
10            };


5    //添加鼠标按下和弹起事件
6            oBtn.onmousedown = function(){
7                oBtn.style.backgroundColor = &quot;pink&quot;;
8            };
9            oBtn.onmouseup = function(){
10                oBtn.style.backgroundColor = &quot;skyblue&quot;;
11            };
点击： 
松开： 

4    //获得焦点事件，输入框清空
5            oTxt.onfocus = function(){
6                oTxt.value = &quot;&quot;;
7            };
8            oTxt.onblur = function(){
9                oImg.src = &quot;images/kaola2.jpeg&quot;;
10            };
</code></pre><p>onload事件：表示元素加载完之后执行某一个事件函数。</p>
<pre><code>3    //onload加载，图片加载完之后，弹出一句话，加载完了
4            oImg.onload = function(){
5                alert(&quot;加载完毕&quot;);
6            };
</code></pre><p>页面整体加载事件：</p>
<p>window.onload:表示页面的所有html标签、css样式都加载完。JS就可以随意书写加载位置。</p>
<pre><code>3    // 只有页面全部加载完了才会触发window.onload
4            window.onload = function(){
5                //获取元素
6                var oImg = document.getElementById(&quot;image&quot;);
7                var oTxt = document.getElementById(&quot;txt&quot;);
8                //绑定鼠标移上的效果，变图片
9                oImg.onmouseover = function(){
10                    oImg.src = &quot;images/kaola2.jpeg&quot;;
11                };
12                //鼠标移出效果，一般与鼠标移上成对出现
13                oImg.onmouseout = function(){
14                    oImg.src = &quot;images/kaola.jpg&quot;;
15                };
16    }；
</code></pre><p>window浏览器对象，alert就是window对象里面的一个方法。window可以省略。</p>
<pre><code>window.alert(&quot;yes&quot;);
</code></pre>]]></content>
      
        <categories>
            
            <category> Dom </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Dom </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[arguments对象]]></title>
      <url>http://yoursite.com/2016/10/29/title13/</url>
      <content type="html"><![CDATA[<h2 id="1、arguments对象"><a href="#1、arguments对象" class="headerlink" title="1、arguments对象"></a>1、arguments对象</h2><p>在其他语言里，一个函数定义两次，每次有不同的形式参数，代表的就是两个不同的函数，叫做函数的重载（overloaded）。</p>
<pre><code>1    function fun(a,b){
2                console.log(1);
3            }
4            function fun(a,b,c){
5                console.log(2);
6            }
</code></pre><p>以上在其他语言里，作为两个不同的函数执行，如果实际参数有2个，调用第一个函数，如果实际参数有三个，调用第二个函数。</p>
<p>JS语言没有函数重载的现象。一个标识符不能给两个函数，如果给了两个函数，第二个会覆盖前面的。不论参数是多少个，都会去执行最后一个函数内部的代码。</p>
<pre><code>1    function fun(a,b){
2                console.log(1);
3            }
4            function fun(a,b,c){
5                console.log(2);
6            }
7            fun(1,2,3,4);
</code></pre><p>JS的函数内部默认都有一个叫做arguments的类数组对象。在调用函数过程中，会传递参数，所有的实际参数不管有没有对应的形参都会存到arguments对面。</p>
<p>arguments对象内部存的是所有的实参，将实参以数组单独数据的形式存起来。</p>
<pre><code>1    function fun(a,b){
2        console.log(arguments);
3    }
4    fun(1,2,3,4,45,6,7);

1    function fun(a,b){
2                // console.log(arguments);
3                arguments[5] = 10;
4                arguments.length = 10;
5                console.log(arguments.length);
6                var sum = 0;
7                for(var i = 0 ; i &lt; arguments.length ; i++){
8                    sum += arguments[i];
9                }
10                console.log(sum);
11            }
12            fun(1,2,3,4,45,6,7);
</code></pre><p>arguments并不能完全使用数组的所有方法。</p>
<pre><code>1    var arr = arguments.slice(3,5);
2    console.log(arr);
</code></pre><p>arguments常用于封装函数时，模拟函数重载现象。</p>
<p>一个函数有三个形式参数，用户传一个参数，直接给参数乘以2，传2个参数，求两个参数的和，如果穿3个参数，先比较前两个数的大小，大的数与第三个数求和。</p>
<pre><code>1    function sum(a,b,c){
2                //根据实际参数个数不同，走不同的分支
3                switch(arguments.length){
4                    case 1:
5                        return a * 2;
6                        break;
7                    case 2:
8                        return a + b;
9                        break;
10                    case 3:
11                        return (a &gt; b ? a : b) + c;
12                        break;
13                    default:
14                        throw new Error(&quot;参数个数必须是1到3个，请重新输入&quot;);
15                }
16            }
17            console.log(sum(1));
18            console.log(sum(1,2));
19            console.log(sum(1,2,3));
20            console.log(sum(1,2,3,4));
</code></pre><h2 id="2、IIFE"><a href="#2、IIFE" class="headerlink" title="2、IIFE"></a>2、IIFE</h2><p>IIFE：immediately-invoked function expression。即时调用函数表达式。指的就是函数在声明、定义的同时，直接调用。</p>
<p>（）调用函数的操作符。不能直接用在关键字定义的函数后面。</p>
<pre><code>1    function fun(){
2        console.log(1);
3    }();
</code></pre><p>可以用函数表达式直接调用。函数表达式中，将函数矮化成了表达式，表达式是可以参数数学运算。</p>
<pre><code>1    var fun = function(){
2        console.log(2);
3    }();
</code></pre><p>可以通过将函数矮化成表达式的形式，直接进行调用。<br>常用的其他方法：如果函数前面加一个数学运算符，就可以矮化成表达式。</p>
<pre><code>1    
2            +function fun(){
3                console.log(1);
4            }();
5            -function fun(){
6                console.log(1);
7            }();
8            !function fun(){
9                console.log(1);
10            }();
11            (function fun(){ //()是我们最常用
12                console.log(1);
13            })();
</code></pre><p>IIFE的函数不能再外面使用函数名调用，认为函数是未定义。</p>
<pre><code>1    (function fun(){
2        console.log(1);
3    })();
4    fun();
</code></pre><p>IIFE将fun函数的作用域给关住，在外面调用找不到这个函数定义。<br>最常见的IIFE的写法：内部的函数是一个匿名函数。</p>
<pre><code>1    (function(){
2        console.log(1);
3    })();
</code></pre><p>IIFE可以自身传递参数。</p>
<pre><code>1    
2            (function(a){
3                a++;
4                console.log(a);
5            })(5);
6            (function(a){
7                a++;
8                console.log(a);
9            })(5);
10            (function(a){
11                a++;
12                console.log(a);
13            })(8);
</code></pre><p>在查找变量时，在IIFE内部查找，不会去全局。</p>
<pre><code>1    var a = 5;
2            (function(a){
3                a++;
4                console.log(a);
5            })();
</code></pre><p>作用：用来解决一些闭包的问题。</p>
<h2 id="3、通过数组观察闭包"><a href="#3、通过数组观察闭包" class="headerlink" title="3、通过数组观察闭包"></a>3、通过数组观察闭包</h2><p>数组内部每一项都是一个函数。可以自动的通过遍历给数组添加项。</p>
<pre><code>1    //在数组内添加十个函数
2            var arr = [];
3            for(var i = 0 ; i &lt; 10 ; i++){
4                //闭包：记住自己的定义域环境、内部语句。
5                arr[i] = function(){
6                    console.log(i);
7                };
8            }
9            console.log(arr[8]);
10            arr[0]();
11            arr[1]();
12            arr[2]();
13            arr[3]();
14            arr[4]();
15            arr[5]();
</code></pre><p>每个函数都记住了自己的定义域环境和内部语句，环境记住了一个i变量，最终执行时，i变量的值已经变成了10.</p>
<p>利用IIFE解决问题。</p>
<pre><code>1    //在数组内添加十个函数
2            var arr = [];
3            for(var i = 0 ; i &lt; 10 ; i++){
4                //闭包：记住自己的定义域环境、内部语句。
5                //IIFE可以关注函数的作用域
6                (function(a){
7                    //内部记住a的值是固定的了，就是这次循环传进来的i
8                    arr[a] = function(){
9                        console.log(a);
10                    }
11                })(i);
12            }
13            console.log(arr[8]);
14            arr[0]();
15            arr[1]();
16            arr[2]();
17            arr[3]();
18            arr[4]();
19            arr[5]();
</code></pre><p>IIFE可以解决数组中闭包出现的问题。</p>
]]></content>
      
        <categories>
            
            <category> arguments </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IIFE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[正则的术语和操作符]]></title>
      <url>http://yoursite.com/2016/10/26/title12/</url>
      <content type="html"><![CDATA[<p>由一些普通字符和一些特殊字符（又叫元字符–metacharacters）组成。普通字符包括大小写的字母和数字，而元字符则具有特殊的含义。</p>
<p>特殊字符：</p>
<p>（） [ ] { } \ ^ $ | ? * + .</p>
<p>就想匹配特殊字符，将特殊字符进行转义。用到转义符号\。</p>
<p>(    [    .</p>
<h2 id="1、精确匹配"><a href="#1、精确匹配" class="headerlink" title="1、精确匹配"></a>1、精确匹配</h2><p>精确匹配指的是我们要去匹配某一个固定值或者常量，匹配abc，正则表达式里必须用精确的术语进行匹配。</p>
<p>正则表达式：/abc/,表示我们要匹配的是三个字符，分别是a，b，c，必须是顺序在一起，顺序不能颠倒。</p>
<h2 id="2、预定义特殊字符："><a href="#2、预定义特殊字符：" class="headerlink" title="2、预定义特殊字符："></a>2、预定义特殊字符：</h2><pre><code>\t    /\t/    制表符      eg: console.log(/\t/.test(&apos;    &apos;)) 
\n    /\n    回车符        eg: console.log(/\n/.test(`aaa
    bbb`));
\f    /\f/    换页符        
\b    /\b/    空格
</code></pre><h2 id="3、字符集"><a href="#3、字符集" class="headerlink" title="3、字符集"></a>3、字符集</h2><p>用正则表达式中的一类字符去配字符串中的一个字符。字符集用[]包括。</p>
<p>比如[abc]，表示可以匹配a，也可以匹配b，也可以匹配c，只要存在其中任意一个都是对的。</p>
<p>简单类:正则的多个字符对应一个字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符。将所有可能性都列在[]内，不要任何其他字符，直接连写</p>
<p>范围类:有时匹配的东西过多，而且类型又相同，全部输入太麻烦，我们可以在中间加了个横线。<br>[a-z]、[0-9]、[A-Z]</p>
<p>组合类:允许用中括号匹配不同类型的单个字符<br>[0-9a-b]<br>只要数字和小写字母：[0-9a-z]</p>
<p>负向类:[]前面加个元字符(^)进行取反，表示匹配不能为括号里面的字符。<br>[^a]</p>
<h2 id="4、修饰符"><a href="#4、修饰符" class="headerlink" title="4、修饰符"></a>4、修饰符</h2><p>g 修饰符用于执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</p>
<p>match、replace这两种方法可以使用。</p>
<p>i 修饰符用于执行对大小写不敏感的匹配。</p>
<p>注意：修饰符书写位置，都是在//写完之后，紧跟在后面。修饰符可以同时使用，连写就可以。</p>
<h2 id="5、边界"><a href="#5、边界" class="headerlink" title="5、边界"></a>5、边界</h2><p>^    开头    注意不能紧跟于左中括号的后面</p>
<p>界定的是我们的字符串必须以什么为开头。^后面的正则术语匹配的字符串就必须是开头。</p>
<p>$    结尾</p>
<p>界定的是必须以$前面的字符为结尾，$写在正则的最后。</p>
<p>^和$可以同时使用，必须以他们中间的内容当做开头和结尾，字符串只能有中间的内容。</p>
<p>\b    单词边界，用于查找位于单词的开头或结尾的匹配。</p>
<p>对我们字符匹配是前后字符的界定。\b写在前面，表示后面的那个字符匹配时必须是一个单词的开始，\b写在后面，表示前面的那个字符匹配时必须是一个单词的结尾。</p>
<p>借用：\w,表示单词字符，包括数字、大小写字母、下划线。</p>
<p>\B    非单词边界，用于查找不处在单词的开头或结尾的匹配。</p>
<p>\B写在前面，表示后面的那个字符匹配时必须不是一个单词的开始，\B写在后面，表示前面的那个字符匹配时必须不是一个单词的结尾。</p>
<p>对比记忆：单词边界\b必须包括单词边界。非单词边界\B不能有单词边界。</p>
<h2 id="6、预定义类"><a href="#6、预定义类" class="headerlink" title="6、预定义类"></a>6、预定义类</h2><p>预定义类其实都是对一些字符集的简写。</p>
<pre><code>.    [^\n\r]            除了换行和回车之外的任意字符


\d    [0-9]            数字字符
digital


\D    [^0-9]            非数字字符 只要不是数字都可以


\s    [ \t\n\x0B\f\r]        空白字符  空格、缩进、换行、换页
space


\S    [^ \t\n\x0B\f\r]        非空白字符  


\w    [a-zA-Z_0-9]        单词字符(所有的字母/数字/下划线)
word


\W    [^a-zA-Z_0-9]        非单词字符
</code></pre><h2 id="7、量词"><a href="#7、量词" class="headerlink" title="7、量词"></a>7、量词</h2><p>规定数量：作用范围是量词的前面的一个字符。</p>
<p>{n}        硬性量词        对应零次或者n次，n人为自定义的，可以是任意正数和0</p>
<p>{n,m}    软性量词        至少出现n次但不超过m次(中间不能有空格)</p>
<p>{n,}        软性量词        至少出现n次(+的升级版)</p>
<p>?        软性量词        出现零次或一次  等价于{0,1}</p>
<ul>
<li>软性量词        出现零次或多次(任意次)   等价于{0,}</li>
</ul>
<ul>
<li>软性量词        出现一次或多次（至少一次）   等价于{1,}</li>
</ul>
<p>量词除了修饰前面的单个字符，还经常搭配预定义类使用。</p>
<h2 id="8、或操作符"><a href="#8、或操作符" class="headerlink" title="8、或操作符"></a>8、或操作符</h2><p>可以使用竖线（|）字符表示或者的关系。</p>
<p>会匹配|前面或者后面。</p>
<p>a|bcd : 表示匹配的字符串，要么包括一个单独的a，要么包括一个整体的bcd。</p>
<p>可以利用小括号分组，将|操作符包裹起来，跟后面就没关系了。</p>
<p>(a|b)cd : 表示从a、b选一个，后面是cd。</p>
<p>验证一个月的31天：</p>
<pre><code>1    ^((0?[1-9])|((1|2)[0-9])|30|31)$
</code></pre><h2 id="9、分组的反向引用"><a href="#9、分组的反向引用" class="headerlink" title="9、分组的反向引用"></a>9、分组的反向引用</h2><p>反向引用标识是对正则表达式中的匹配组捕获的子字符串进行编号，通过“\编号(在表达式中)”，“$编号（在表达式外）”进行引用。从1开始计数。</p>
<p>在正则表达式里反向引用。</p>
<pre><code>1    &apos;123*456&apos;.replace(/(\d{3})\*(\d{3})/, &apos;$2*$1&apos;)

除了直接反向引用 之外，还可以对引用的字符做一些复杂操作。

1    &apos;123*456&apos;.replace(/(\d{3})\*(\d{3})/, function (match, $1, $2) {
2        return $2 + &apos;*&apos; + $1
3    })4    
</code></pre><p>10、中文匹配<br>固定用法：[\u4e00-\u9fa5]</p>
<pre><code>1    var str = prompt(&quot;请输入用户名，必须是4-6位的汉字&quot;);
2            var reg = /^[\u4e00-\u9fa5]{4,6}$/;
3            if(reg.test(str)){
4                alert(&quot;right&quot;);
5            }else{
6                alert(&quot;wrong&quot;);
7            }
</code></pre>]]></content>
      
        <categories>
            
            <category> 正则 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> regular </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[字符串属性和方法]]></title>
      <url>http://yoursite.com/2016/10/23/title11/</url>
      <content type="html"><![CDATA[<h2 id="1、length属性"><a href="#1、length属性" class="headerlink" title="1、length属性"></a>1、length属性</h2><p>length 属性可返回字符串中的字符数目。</p>
<pre><code>49    //数组可以存一组数据        
50            var str = &quot;今天要多讲一会儿了hahaha，你能怎 样？&quot;;
51            console.log(str.length);
</code></pre><h2 id="2、方法"><a href="#2、方法" class="headerlink" title="2、方法"></a>2、方法</h2><p>charAt() 方法可返回指定位置的字符。</p>
<p>index:字符索引值，从0开始。</p>
<pre><code>36    语法：str.charAt(index);

52    var str = &quot;今天要多讲一会儿了hahaha，你能怎 样？&quot;;
53    console.log(str.charAt(3));
</code></pre><p>concat() 方法用于连接两个或多个字符串。原字符串不会被改变。</p>
<pre><code>37    //concat() 方法用于连接两个或多个字符串。
38            var str2 = str.concat(&quot;不怎么样啊&quot;);
39            console.log(str);
40            console.log(str2);
</code></pre><p>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。得到的结果是字符串的索引值。</p>
<blockquote>
<p>注意：区分字母大小写。如果找不到对应的字符，返回-1.</p>
</blockquote>
<pre><code>54    //indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。
55    console.log(str.indexOf(&quot;多讲&quot;));
</code></pre><p>lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</p>
<blockquote>
<p>注意：输出的还是索引值，它是从后面找第一次出现的位置。</p>
</blockquote>
<pre><code>41    console.log(str.indexOf(&quot;a&quot;));
42    console.log(str.lastIndexOf(&quot;a&quot;));
</code></pre><p>slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。<br>生成新的字符串，对原字符串没影响。</p>
<pre><code>56    //slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。
57            var str2 = str.slice(4,8);
58            console.log(str);
59            console.log(str2);
</code></pre><p>split() 方法用于把一个字符串分割成字符串数组。参数：分隔符。</p>
<pre><code>43    var str2 = &quot;lsdfowekfsdfowekdowfefsfwepp&quot;;
44    var arr = str2.split(&quot;f&quot;);
45    console.log(str2);
46    console.log(arr);
</code></pre><blockquote>
<p>toLowerCase() 方法用于把字符串转换为小写。</p>
<p>toUpperCase() 方法用于把字符串转换为大写。</p>
</blockquote>
<pre><code>60    var str4 = str3.toUpperCase();
61    var str5 = str4.toLowerCase();
62    console.log(str3);
63    console.log(str4);
64    console.log(str5);
</code></pre><p>substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。</p>
<p>start：开始的索引值。可以为正、可以为负。</p>
<p>length：截取的字符串数量。可以写可以不写，不写截取到字符串结尾。</p>
<pre><code>47    var str4 = str3.substr(5,6);
48            console.log(str3);
49            console.log(str4);
</code></pre><p>substring() 方法用于提取字符串中介于两个指定下标之间的字符。</p>
<p>substring() 方法返回的子串包括 start 处的字符，但不包括 end 处的字符。与slice一样。</p>
<p>不一样：substring参数不能为负。两个参数位置可以互换，第一个参数字符位置可以在第二个参数位置之后。</p>
<p>如果 start 比 end 大，那么该方法在提取子串之前会先交换这两个参数。end参数可以不写。</p>
<pre><code>29    //substring() 方法用于提取字符串中介于两个指定下标之间的字符。
30            var str4 = str3.substring(4,9);
31            var str5 = str3.substring(9,4);
32            console.log(str3);
33            console.log(str4);
34            console.log(str5);
</code></pre><p><img src="http://wx3.sinaimg.cn/orj360/a579329cly1fcto0ble9oj20me07omx7.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> 字符串 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> string </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数组基本知识]]></title>
      <url>http://yoursite.com/2016/10/22/title10/</url>
      <content type="html"><![CDATA[<h2 id="1、数组的概述"><a href="#1、数组的概述" class="headerlink" title="1、数组的概述"></a>1、数组的概述</h2><p>数组：是一组有序的数据集合。存放的不是一个单独的数据，而是一组数据。</p>
<p>创建一个数组，最简单的方法是使用数组字面量。</p>
<p>数组字面量：[],中括号表示内部存放的是一个数组。</p>
<p>[]里面可以放多个数据，每个数据之间用逗号隔开，最后一个数据后面不用加逗号。</p>
<pre><code>1    //数组可以存一组数据        
2    var arr = [1,2,3,4,5];
</code></pre><p>一个数组内可以存不同数据类型的数据。实际工作还是存同一种的情况居多。</p>
<pre><code>1    //数组内并不只存储一种类型的数据，能存各种数据类型，甚至存数组
2    var arr2 = [1,&quot;haha&quot;,undefined,true,null,function fun(){console.log(a)},[3,4,5]];
</code></pre><p>索引值：index，数组有一个自己的属性，可以通过下标获得某一项具体的数据。索引值从0开始。</p>
<pre><code>1    方法：arr[0];
</code></pre><p>通过数组的下标获得数组每一项的数据。</p>
<pre><code>1    var arr = [1,2,3,4,5];
2    console.log(arr[0]);
3    console.log(arr[1]);
4    console.log(arr[2]);
5    console.log(arr[3]);
</code></pre><p>通过给数组的下标去赋值，可以更改数组内的对应的数据。</p>
<pre><code>1    arr[1] = &quot;haha&quot;;
2    console.log(arr[0]);
3    console.log(arr[1]);
</code></pre><p>如果调用时索引值超过最大的项数，得到的值是undefined，表示这一项还没定义具体的值。</p>
<pre><code>1    console.log(arr[9]);
</code></pre><p>length：长度，数组内部存了多少个数据，length就输出几。</p>
<p>调用length的方法：数组名字.length。</p>
<pre><code>1    console.log(arr2.length);
</code></pre><p>数组的length可以推算我们数组的最大索引值，length-1就是最大的index。</p>
<pre><code>1    console.log(arr2[arr2.length - 1]);
</code></pre><p>数组长度是一个固定值，但是我们可以通过arr.length强制给数组改长度。如果长度大于原来的长度，强制将数组拉长了，多出来的数组项相当于未定义值。</p>
<pre><code>1    arr2.length = 12;
2    console.log(arr2.length);
</code></pre><p>如果自定义的长度小于原来的数组长度，相当于删除了后面的项。</p>
<pre><code>1    arr2.length = 4;
2    console.log(arr2);
3    arr2.length = 7;
4    console.log(arr2);
5    console.log(arr2[arr2.length - 1]);


1    arr[9] = 10;
2    console.log(arr.length);
</code></pre><p>数组是引用类型，它是一个对象。</p>
<pre><code>1    console.log(typeof arr);

1    //数组赋值给变量时，变量存的是数组的地址        
2            var arr = [1,2,3,4,5];
3            var arr2 = arr;
4            arr2.length = 10;
5            console.log(arr.length);
</code></pre><h2 id="2、数组的遍历"><a href="#2、数组的遍历" class="headerlink" title="2、数组的遍历"></a>2、数组的遍历</h2><p>需要将数组里面的每一项拿出来做某一个操作，可以利用循环通过数组下标将所有项都取出来，对每一项进行操作，这个过程就是数组遍历的过程。</p>
<pre><code>1    //数组可以存一组数据        
2            var arr = [1,2,3,4,5];
3            for(var i = 0 ; i &lt;= arr.length - 1 ; i++){
4                console.log(arr[i]);
5            }
</code></pre><p>请输出数组中每一项的阶乘的和。</p>
<pre><code>1    //数组可以存一组数据        
2            var arr = [1,2,3,4,5,6,7];
3            //累加器
4            var sum = 0;
5            for(var i = 0 ; i &lt; arr.length ; i++){
6                sum += jiecheng(arr[i]);
7            }
8            console.log(sum);
9            //阶乘函数
10            function jiecheng(a){            
11                if(a == 0){
12                    return 1;
13                }else{
14                    //累乘器
15                    var mul = 1;
16                    for(var i = 1 ; i &lt;= a ; i++){
17                        mul *= i;
18                    }
19                    return mul;
20                }            
21            }
</code></pre><h2 id="3、数组的方法"><a href="#3、数组的方法" class="headerlink" title="3、数组的方法"></a>3、数组的方法</h2><p>3.1、首尾操作</p>
<blockquote>
<p>push() 在数组末尾添加一个或多个元素，并返回数组操作后的长度。</p>
<p>pop() 从数组移出最后一个元素，并返回该元素。</p>
<p>shift() 从数组移出第一个元素，并返回该元素。</p>
<p>unshift() 在数组开头添加一个或多个元素，并返回数组的新长度。</p>
</blockquote>
<p>push：推。在数组最后一项后面推入一个新数据。返回值是新的长度。</p>
<pre><code>1    var arr = [1,2,3,4,5];
2    //console.log(arr.push(8));
3    console.log(arr.push(&quot;8&quot;,10,true,[2,3]));
4    console.log(arr);

1    //pop() 从数组移出最后一个元素，并返回该元素。
2            console.log(arr.pop());
3            console.log(arr);


5    //unshift() 在数组开头添加一个或多个元素，并返回数组的新长度。
6            console.log(arr.unshift(&quot;haha&quot;));
7            console.log(arr);

4    //shift() 从数组移出第一个元素，并返回该元素。
5    console.log(arr.shift());
6    console.log(arr);
</code></pre><p>综合案例：</p>
<pre><code>8    //将第一项删除，添加到最后一项
9            arr.push(arr.shift());
10            console.log(arr);
11            arr.push(arr.shift());
12            console.log(arr);
13            arr.push(arr.shift());
14            console.log(arr);
15            arr.push(arr.shift());
16            console.log(arr);
17            arr.push(arr.shift());
18            console.log(arr);
19            //最后一项给第一项
20            arr.unshift(arr.pop());
21            console.log(arr);
</code></pre><p>3.2、合并和拆分</p>
<blockquote>
<p>concat() 连接两个数组并返回一个新的数组。</p>
</blockquote>
<p>concat：合并的意思。将两个数组或者多个连接成一个新的数组，对原数组或数据没有任何影响。</p>
<pre><code>7    //数组可以存一组数据        
8            var arr = [1,2,3,4,5];
9            var arr2 = [6,7,8,9];
10            //合并
11            var arr3 = arr.concat(arr2);
12            console.log(arr);
13            console.log(arr2);
14            console.log(arr3);
</code></pre><blockquote>
<p>拆分：slice() 从数组提取一个片段，并作为一个新数组返回。</p>
</blockquote>
<pre><code>15    语法：array.slice(start,end);
</code></pre><p>截取到的新数组：原数组的第start项开始到end结束（不包含end位置）的这一段数据。start、end表示的index索引值。</p>
<p>参数为正数：从start开始到end结束，不包含end。</p>
<pre><code>23    var arr = [1,2,3,4,5,6,7,8,9,10,11,12];
24            //拆分
25            var arr2 = arr.slice(3,8);
26            console.log(arr);
27            console.log(arr2);
</code></pre><p>不写end：表示从start开始截取到最后一个数据。</p>
<pre><code>16    var arr3 = arr.slice(3);
</code></pre><p>参数为负数：从最后一个数据往前数多少个，从开始位置截取到最后位置不包含结束位置。</p>
<pre><code>28    var arr4 = arr.slice(-6,-3);
</code></pre><p>参数为负，不写end：表示从start截取到最后。</p>
<p>3.3、删除、插入、替换</p>
<p>splice() 方法用于插入、删除或替换数组的元素。</p>
<p>三个功能是根据参数不同而产生。</p>
<pre><code>arrayObject.splice(index,howmany,element1,.....,elementX)
</code></pre><p>前两个参数必须写。后面的参数可以选择。</p>
<p>删除：只写前两个参数。index表示删除的开始位置，howmany表示从这个位置开始删除多少个元素。</p>
<pre><code>18    //数组可以存一组数据        
19            var arr = [1,2,3,4,5,6,7,8,9,10,11,12];
20            //删除.表示从起始位置下标为3开始删除5个
21            arr.splice(3,5);
22            console.log(arr);
</code></pre><p>插入：写三个参数，要求第二个参数必须为0.插入位置是在index元素的前面。</p>
<pre><code>30    //插入数据，写三个参数，第二个参数为0
31            arr.splice(3,0,&quot;haha&quot;);
32            console.log(arr);
</code></pre><p>替换：写三个或以上的参数，将一部分数据删除，用另外的数据替代。</p>
<pre><code>23    // 替换数据
24            arr.splice(3,5,&quot;haha&quot;,true,[2,3]);
25            console.log(arr);
</code></pre><p>3.4、倒序和排序</p>
<p>倒序：reverse() 颠倒数组元素的顺序：第一个变成最后一个，最后一个变成第一个。</p>
<pre><code>33    //数组可以存一组数据        
34            var arr = [1,2,3,4,5,6,7,8,9,10,11,12];        
35            //倒序
36            arr.reverse();
37            console.log(arr);
</code></pre><p>排序：sort();可以穿参数，也可以不传。</p>
<p>如果没有指明比较函数（没有传参数），那么元素会被转换为字符串并按照字符编码顺序顺序排序。例如 “Cherry” 会被排列到 “banana” 之前。当对数字进行排序的时候， 9 会出现在 80 之后，因为他们会先被转换为字符串，而 “80” 比 “9” 要靠前。</p>
<pre><code>26    //排序、默认情况，比较字符编码顺序
27            arr.sort();
28            console.log(arr);
</code></pre><p>sort函数有一个参数，叫做比较函数，规定了我们排序的依据。</p>
<p>如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。记 a 和 b 是两个将要被比较的元素：</p>
<blockquote>
<p>如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；</p>
<p>如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。</p>
<p>如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。</p>
</blockquote>
<pre><code>38    //升序排列，能控制的是条件
39            arr.sort(function(a,b){
40                if(a &gt; b){
41                    return -1;
42                }else if(a &lt; b){
43                    return 1;
44                }else{
45                    return 0;
46                }
47            });
48            console.log(arr);
</code></pre><p>3.5、转字符串</p>
<p>join() 将数组的所有元素连接成一个字符串。</p>
<p>join加入的意思，在数组数据之间加入一个连字符，整体连城一个字符串。</p>
<p>连字符：join方法的参数。不传参数，默认逗号是连字符。</p>
<p>数组转成字符串，用新变量接收。</p>
<pre><code>29    //数组可以存一组数据        
30            var arr = [1,52,23,4,75,36,7,88,90,10,11,12];        
31            var str = arr.join();
32            var str2 = arr.join(&quot;(ㄒoㄒ)&quot;);
33            console.log(arr);
34            console.log(str);
35            console.log(str2);
</code></pre>]]></content>
      
        <categories>
            
            <category> arr </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[函数的使用]]></title>
      <url>http://yoursite.com/2016/10/17/title8/</url>
      <content type="html"><![CDATA[<p><img src="http://wx2.sinaimg.cn/mw690/a579329cly1fctlptz0r2j20dc07i0tm.jpg" alt=""><br>函数就是功能。函数可以封装一段代码，整体会具备一个功能，可以人为的定义自己的功能。函数执行时候，所有的这一段封装的代码都会立即执行，实现这个功能。</p>
<pre><code>1    //定义函数
2            function fun(){
3                console.log(1);
4                console.log(2);
5                console.log(3);
6                console.log(4);
7                console.log(5);
8            }
9            //使用函数
10            fun();
11            fun();
</code></pre><blockquote>
<p>函数的特点①：函数能够封装一些重复性的代码，使用时直接调用，简化代码。</p>
</blockquote>
<h2 id="1、函数的声明和调用"><a href="#1、函数的声明和调用" class="headerlink" title="1、函数的声明和调用"></a>1、函数的声明和调用</h2><p>1.1 函数的声明</p>
<p>函数必须先定义才能使用。</p>
<p>函数定义：也叫作函数声明。关键字：function。本身就是功能意思。<br>定义语法：function关键字后面必须跟一个空格，后面是我们自定义的函数名字，紧跟着是一个小括号（参数），后面紧跟着是一个大括号，里面放的就是我们封装的结构体。函数后面不用加分号。</p>
<pre><code>1    function 函数名(参数){
2        封装的结构体；
3    }
</code></pre><p>函数名是一种标识符，必须遵循标识符命名规范：</p>
<blockquote>
<p>首字符必须是字母、下划线、美元符号。</p>
<p>其他字符可以是字母、下划线、美元符号、数字。</p>
<p>区分大小写，且不能是关键字和保留字。</p>
</blockquote>
<pre><code>1    function fun(){
2     alert(&quot;hello world&quot;);
3    }
</code></pre><p>意义：只是定义了一下函数执行时要做的工作，并不会去自动执行这些代码。函数只有调用的时候，才会执行内部的结构体。</p>
<p>1.2函数的调用</p>
<p>函数调用方法：函数名（）；直接在函数名后面加小括号。</p>
<pre><code>1    //函数声明
2            function fun(){
3                alert(&quot;hello world&quot;);
4            }
5            //函数的调用
6            fun();
</code></pre><p>函数内部的结构体执行的位置，与定义的位置无关，与函数调用的位置有关。</p>
<pre><code>1    //定义函数
2            function fun(){
3                console.log(1);
4                console.log(2);
5                console.log(3);
6            }
7            console.log(10);
8            console.log(20);
9            console.log(30);
10            fun();
</code></pre><p>函数一次声明，可以多次调用。<br>函数每次调用时，内部的结构体都会全部一起执行。</p>
<pre><code>1    fun();
2    fun();
</code></pre><h2 id="2、函数的参数"><a href="#2、函数的参数" class="headerlink" title="2、函数的参数"></a>2、函数的参数</h2><p>函数使用的目的，方便我们重复使用某一个功能，有时候需要功能发生一些变化，函数留了一个接口给我们，让我们的程序可以根据输入值的不同发生相应变化。</p>
<p>参数就是函数预留的接口：通过参数的变化，让函数执行结果发生改变。参数书写位置：函数名后面的小括号里。</p>
<pre><code>1    function 函数名(参数){
2        封装的结构体；
3    }
</code></pre><p>参数：就是一些变量。可以有一个变量或者多个变量。</p>
<pre><code>1    //定义函数
2            function fun(a){
3                console.log(a);
4            }
5            //调用时
6            fun(1);
</code></pre><p>函数的参数：定义时，小括号内的参数叫做形式参数（形参），调用时小括号内的参数叫做实际参数（实参），真正调用时参与到结构体里面的数据是实际参数的数据。</p>
<p>整个函数调用的过程，就是实际参数传递给形式参数（过程叫做传参），执行语句的过程。</p>
<p>函数的执行结果跟传递的参数息息相关。</p>
<p>参数本身是变量：变量的数据类型是动态变化，跟我们变量的赋值的数据类型有关。根据传参的不同，我们的函数会出现不同的结果。</p>
<p>案例：定义一个求和的函数。</p>
<pre><code>1    //定义求和函数
2            function sum(a,b){
3                console.log(a + b);
4            }
5            //调用
6            sum(2,3);
7            sum(2,&quot;3&quot;);
</code></pre><p>arguments：实际参数组成的一个类数组对象。函数的形参和实参的个数可以不同。<br>函数的形式参数可以少于实际参数，匹配对应形参的个数，多余的实参，不参与程序的执行。</p>
<pre><code>1    //定义求和函数
2            function sum(a,b){
3                console.log(a + b);
4            }
5            //调用
6            sum(1,2,3,4);
</code></pre><p>函数的形式参数多于实际参数，对应的实参先匹配传递，多出来的形式参数相当于只定义没有赋值，有一个默认的undefined值，会参与程序执行。</p>
<pre><code>1    //定义求和函数
2            function sum(a,b){
3                console.log(a + b);
4            }
5            //调用
6            sum(3);
</code></pre><p>函数参数提供了一个便利：</p>
<blockquote>
<p>其实根本不需要去看函数内部的结构体怎么定义的，只需要知道执行函数传递几个参数，能实现什么功能就行了。后期，只需要对相应的函数传参，执行实现某种功能即可。</p>
<p>定义函数后：给一个说明，告诉用户输入几个参数，参数的数据类型要求是什么，执行之后会有什么后果。也叫API使用说明。</p>
<p>函数的特点</p>
<p>②：函数很便利，只需要知道怎么使用某一个函数，不需要了解内部的构造。可以使用自己的函数，也可以使用别人的定义的函数，只需要知道怎么用，不需要知道为什么。简化我们自己的编程。</p>
</blockquote>
<h2 id="3、函数的返回值"><a href="#3、函数的返回值" class="headerlink" title="3、函数的返回值"></a>3、函数的返回值</h2><p>函数可以通过参数接收数据，也可以通过一个return返回一个值。</p>
<p>return：返回的意思。将函数执行结果返回一个固定的值。</p>
<pre><code>1    //定义函数
2            function sum(a,b){
3                return a + b;
4            }
5            //函数返回的是一个计算后的值，需要一个输出语句看值是多少
6            console.log(sum(2,3));
</code></pre><p>如果函数有return返回值，就相当于将函数矮化成了一个表达式，表达式都会计算出一个结果参与到程序里。</p>
<p>可以将有return的函数执行后赋值给一个变量。</p>
<p>函数的参数也是变量，函数执行时，传递实参可以是另外一个有return函数的执行结果。</p>
<pre><code>2    console.log(sum(4,sum(2,3)));
</code></pre><blockquote>
<p>函数的特点③：</p>
<p>函数可以有返回值，可以将他的返回值当做另一个函数的参数，参与编程。模块化编程。</p>
<p>return的另外一个功能：函数内部如果遇到return，不会往下继续执行，跳出函数。</p>
</blockquote>
<pre><code>2    function fun(){
3                console.log(1);
4                console.log(2);
5                console.log(3);
6                return;
7                console.log(4);
8                console.log(5);
9                console.log(6);
10            }
11            fun();
</code></pre><h2 id="4、模块化编程"><a href="#4、模块化编程" class="headerlink" title="4、模块化编程"></a>4、模块化编程</h2><p>逆向思维：输出0~10000之间的完美数  → 什么是完美数 → 一个数的约数和</p>
<p>写的过程：约数和函数 → 判断完美数函数 → 输出所有完美数</p>
<pre><code>13    // 逆向思维：输出0~10000之间的完美数  → 什么是完美数 → 一个数的约数和
14            // 写的过程：约数和函数 → 判断完美数函数 → 输出所有完美数
15    
16            //封装一个约数和函数，传入一个数，返回它的约数和
17            function sum(a){
18                var sum = 0;
19                for(var i = 1 ; i &lt; a ; i++){
20                    if(a % i == 0){
21                        sum += i;
22                    }
23                }
24                return sum;
25            }
26            //console.log(sum(10));
27            //可以封装判断完美数函数，传入一个数，返回它是否是完美数
28            function isWanmei(a){
29                if(a == sum(a)){
30                    return true;
31                }else{
32                    return false;
33                }
34            }
35            //console.log(isWanmei(16));
36            //输出0-10000之间的所有完美数
37            for(var i = 1 ; i &lt;= 10000; i++){
38                if(isWanmei(i)){
39                    console.log(i);
40                }
41            }
</code></pre><h2 id="gt-5、函数递归"><a href="#gt-5、函数递归" class="headerlink" title="&gt; 5、函数递归"></a>&gt; 5、函数递归</h2><p>递归：函数内部通过函数名调用这个函数本身。</p>
<pre><code>19    //定义函数，内部调用了这个函数
20            function sum(a,b){
21                b = sum(a,b);
22                return a + b;
23            }
24            console.log(sum(1,2));
</code></pre><p>递归如果写的不够严谨，容易出错。使用时一定要考虑好。</p>
<p>斐波那契数列：</p>
<pre><code>1、1、2、3、5、8、13、21、34、55、89、144、233……用求和函数内部，参数就是自己的上一次函数执行。
2    //定义函数，从第三项开始，等于前两项的和
3            //输出第几项斐波那契数列的值
4            function fib(a){
5                if(a == 1 || a == 2){
6                    return 1;
7                }else{
8                    return fib(a-1) + fib(a-2);
9                }
10            }
11            console.log(fib(1));
12            console.log(fib(2));
13            console.log(fib(3));
14            console.log(fib(4));
15            console.log(fib(5));
16            console.log(fib(6));
17            console.log(fib(7));
18            console.log(fib(8));
</code></pre><h2 id="6、函数表达式"><a href="#6、函数表达式" class="headerlink" title="6、函数表达式"></a>6、函数表达式</h2><p>通过将一个匿名函数（或者有函数名的函数）矮化成一个表达式，赋值给一个变量的形式定义函数。</p>
<p>调用方法：使用变量名加小括号调用。不能用函数自身的名字调用，会报错。能够在函数内部用自己函数名字。</p>
<p>匿名函数：函数没有名字。也叫拉姆达函数。</p>
<pre><code>9    //定义：将一个函数赋值给变量
10            //这种定义方式最后要加分号，相当于一个普通的语句给变量赋值。
11            var fun = function(){
12                console.log(1);
13            };
14            // 调用使用变量加小括号
15            //因为变量内部的值是一个函数，数据类型是函数的类型，函数能加小括号执行。
16            fun();


9    var fun = function fun1(){
10                console.log(1);
11            };
12            //函数赋值给一个变量，函数名在外面就相当于未定义
13            fun();
14            fun1();
</code></pre><p>但是，函数名在函数内部是可以使用的。</p>
<pre><code>8    var fun = function fun1(a){
9                if(a == 1 || a == 2){
10                    return 1;
11                }else{
12                    return fun1(a - 1) + fun1(a - 2);
13                }
14            };
15            //函数赋值给一个变量，函数名在外面就相当于未定义
16            console.log(fun(3));
17            console.log(fun1(3));
</code></pre><h2 id="7、函数的数据类型"><a href="#7、函数的数据类型" class="headerlink" title="7、函数的数据类型"></a>7、函数的数据类型</h2><p>函数数据类型：function。函数类型</p>
<pre><code>10    // //定义：将一个函数赋值给变量
11            var fun = function fun1(a){
12                if(a == 1 || a == 2){
13                    return 1;
14                }else{
15                    return fun1(a - 1) + fun1(a - 2);
16                }
17            };
18            function fun2(){
19                console.log(1);
20            }
21            console.log(typeof fun);
22            console.log(typeof fun2);
</code></pre><blockquote>
<p>function数据类型是一种复杂数据类型，也叫作引用类型。</p>
<p>简单数据类型：number、string、undefined、boolean、null。</p>
<p>变量内部数据类型是动态数据类型，存储数据是什么类型就是什么。</p>
<p>变量内部存的数据如果是简单数据类型的，存的就是一个实际的确切的能自身更改的值。</p>
<p>变量内部存的数据如果是引用类型，存的不是一个确切的object，而是这个对象的地址、指针。</p>
</blockquote>
<p>如果存的是简单数据类型，将一个变量赋值给另一个变量的时候，相当于将变量内部的值复制了一份给新变量，而其中一个变量发生变化，对另一个不会产生任何影响。</p>
<pre><code>7        var a = 1;
8        var b = a;
9        b = 2;
10        console.log(a);
11        console.log(b);
</code></pre><p>如果变量存的是引用类型，赋值给别的变量时，是将对象的地址复制一份给b，a和b指向的是一个对象原型，通过a或者b对对象做出变化，另外一个也会相应发生变化。</p>
<pre><code>17    //复杂的数据类型，存储地址
18            var a = function(){            
19                console.log(1);
20            };
21            var b = a;
22            b.haha = 2;
23            console.log(a.haha);
24            console.log(b.haha);
</code></pre>]]></content>
      
        <categories>
            
            <category> 函数 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS循环语句]]></title>
      <url>http://yoursite.com/2016/10/13/title7/</url>
      <content type="html"><![CDATA[<h1 id="1、循环语句"><a href="#1、循环语句" class="headerlink" title="1、循环语句"></a>1、循环语句</h1><p>循环语句是一系列反复执行直到符合特定条件的命令。</p>
<p>循环语句实际是对某一段代码进行循环执行，在规定的一个判断条件表达式为假的时候，跳出循环，停止重复执行。</p>
<p>JavaScript 支持 for, do while, while这些循环语句。另外，你可以在循环语句中使用break和continue 语句 。</p>
<h2 id="1、for循环语句"><a href="#1、for循环语句" class="headerlink" title="1、for循环语句"></a>1、for循环语句</h2><p>for循环语句是一种前测试循环语句。在执行下一次需要重复的代码之前，我需要先测试一下条件表达式到底是真还是假。如果是真，可以执行，如果是假，就不在循环，跳出for循环。<br>for循环内部的循环语句执行时有先决条件。</p>
<pre><code>1    //体验一下考拉体重飙升的过程
2            for(var i = 7 ; i &lt;= 178 ; i+=3){
3                console.log(&quot;考拉今天&quot; + i + &quot;斤了&quot;);
4            }
</code></pre><p>for循环的语法：</p>
<pre><code>1    for(){}
</code></pre><p>其他人总结的规律：<br>    1    for(定义循环变量；变量的最大值；步长){<br>    2      循环体；<br>    3    }<br>以上总结有局限性，for循环并不是只有这一种书写情况。</p>
<p>运行原理：</p>
<blockquote>
<p>遇到for循环，先执行①位置的语句，然后执行语句②条件表达式，如果②的值为true，继续执行语句③；如果②的结果为false，直接跳出for循环，执行语句⑤。如果能执行到语句③，执行完之后，去执行语句④，然后再执行语句②，如果②的值为true，继续执行语句③；如果②的结果为false，直接跳出for循环，执行语句⑤。<br>重复这个过程……直到条件②语句为假false，彻底跳出for循环，去执行语句⑤。</p>
</blockquote>
<p>注意：（）里面有三个语句，用两个分号分割开，最后一个语句后面不要加分号。</p>
<pre><code>1    for(var i = 3 ; i &lt;= 35 ; i += 6;){
2                console.log(i);
3            }

1    //第二个
2            for(var i = 5 ; i &lt; 25 ; i += 5){
3                console.log(i);
4            }

1    //第三个
2            for(var i = 30; i &gt;= 10 ; i -= 7){
3                console.log(i);
4            }


1    //第四个
2            for(var i = 3 ; i &lt;= 35 ; i *= 2){
3                console.log(i);
4            }
</code></pre><p>for循环内部定义的这个i变量，是一个全局变量，定义在全局，可以在全局任意地方使用。可以将i变量的声明和赋初值，写在for循环外面，第一个语句的位置可以空着。</p>
<pre><code>1    //第五种
2            var i = 3;
3            for(; i &lt;= 10 ; i += 3){ 虽然第一个语句可以不写，但是分号不能省略
4                console.log(i);
5            }
</code></pre><p>如果不写第一个分号，会报错，认为你没写第三个语句</p>
<pre><code>1    //第六个
2            var i = 3;
3            for(console.log(i++); i &lt;= 10 ; i += 3){
4                console.log(i);
5            }
</code></pre><p>如果限制条件没有了，不写，认为可以一直进入到语句③，循环会无限进行下去，叫做死循环。程序一定要合理，不要书写死循环。</p>
<pre><code>1    //第七个
2            var i = 3;
3            for(console.log(i++); ; i += 3){
4                console.log(i);
5            }
6    var i = 3;
7            for(console.log(i++); i &gt; 1 ; i += 3){
8                console.log(i);
9            }10    

1    //第八个
2            for(var i = 4 ; i &lt;= 12 ;){
3                i += 3;
4                console.log(i);
5            }

1    //第九个
2            for(var i = 4 ; i &lt;= 3 ;){
3                i += 3;
4                console.log(i);
5            }
</code></pre><p>for循环内部可以嵌套if语句，输出并不是无条件输出，只有满足某一个条件才会执行输出代码。</p>
<pre><code>1    //第十个，嵌套if语句
2            for(var i = 3 ; i &lt;= 20 ; i += 5){
3                if(i % 2 == 0){
4                    console.log(i);
5                }
6            }
</code></pre><p>for循环还可以嵌套for循环，注意我们定义的循环变量一定不能重复。循环变量常用名字i,j,k.</p>
<pre><code>1    //第十一个
2            for(var i = 1 ; i &lt;= 5 ; i++){
3                for(var j = 1; j &lt;= 4 ; j++){
4                    console.log(i,j);
5                }
6            }
</code></pre><h2 id="2、穷举思想"><a href="#2、穷举思想" class="headerlink" title="2、穷举思想"></a>2、穷举思想</h2><p>一般我们希望得到一组有特殊意义的数据，电脑并不会直接帮我们输出，而是需要我们编写一段代码，规定一个合理范围，从范围内找到这些数据。电脑需要一一去验证某一个数据是否符合条件，如果符合就输出。</p>
<p>程序必须将范围内每一个数据都检测一遍，通过判断条件确定是否符合要求。这些都需要我们来编写。<br>用到我们的循环将所有可能情况循环一遍，挑出有用的，用if语句。</p>
<p>穷举思想：将可能性全部列举完，穷就是穷尽、完全的意思。</p>
<p>外层：for循环，列举。</p>
<p>内层：if语句，判断。</p>
<h2 id="3、do-while循环"><a href="#3、do-while循环" class="headerlink" title="3、do while循环"></a>3、do while循环</h2><p>do while循环是一种后测试循环语句，重复执行某一段代码，直到入口条件测试为假时，跳出循环。</p>
<pre><code>1    语法：
2    do{
3        statement
4    }while(expression);5    6    
</code></pre><blockquote>
<p>do：做某事</p>
<p>while：当……时候</p>
</blockquote>
<p>特点：在第一次测试条件之前，结构体会提前执行一次。<br>通常会定义一些变量，让循环有一些不同。需要将这样的变量定义在循环外面，如果定义在内部，会每次重置，有可能死循环。</p>
<pre><code>1    //循环变量定义在循环外面
2            var i = 1;
3            do{
4                console.log(i);
5                i++;
6            }while(i &lt;= 10);
</code></pre><p>结构体总是会至少输出一次，条件是后测试的，哪怕条件为假，我也会执行一次结构体。</p>
<pre><code>1    //循环变量定义在循环外面
2            var i = 1;
3            do{
4                console.log(i);
5                i++;
6            }while(i &gt;= 10);
</code></pre><p>for循环其实可以模拟do while的结构体先执行一次的情况，但是不够优化，尽量少用。</p>
<pre><code>1    //for循环模拟do while
2            var i = 1;
3            for(console.log(i); i &gt;= 9 ; ){
4                console.log(++i);
5            }

1    //如果变量写在内部，每次循环都会重置，有可能是死循环
2            do{
3                var i = 1;   //全局变量不要定义在内部，会被重置，死循环
4                console.log(i);
5                i++;
6            }while(i &lt;= 10);
7            
</code></pre><p>变量自加的语句，写在输出语句前面和后面，得到的结果是不一样的。</p>
<h2 id="4、while循环"><a href="#4、while循环" class="headerlink" title="4、while循环"></a>4、while循环</h2><p>while语句反复执行直到一个特定的条件计算为假。</p>
<p>while语句是一个前测试循环语句，在循环体中的代码执行之前，就要测试出口条件。</p>
<p>语法：</p>
<pre><code>1    while(expression){
2    statement;}
注意：如果有循环变量，需要定义在循环外边。
1    //循环变量写在外面
2            var i = 1;
3            while(i &lt; 10){
4                console.log(i);
5                i += 3;
6            }
</code></pre><p>可以用for循环模拟，都是前测试循环语句。</p>
<pre><code>1    //while语句能做的，for循环都能做
2            for(var i = 1 ; i &lt; 10 ; i += 3){
3                console.log(i);
4            }
</code></pre><p>变量自加的过程写的位置不同，结果不同。</p>
<pre><code>1    var i = 1;
2            while(i &lt; 10){
3                i += 3;
4                console.log(i);
5            }
</code></pre><p>总结：for循环是最重要，用的最多的循环语句。如果必须先执行一次结构体，再判断，最好用do while循环。while能做的for都能做。随意挑选。</p>
<h2 id="5、break"><a href="#5、break" class="headerlink" title="5、break"></a>5、break</h2><p>break会终止我们的循环。</p>
<pre><code>1    //碰到5的倍数，就停止循环
2            for(var i = 1 ; i &lt; 40 ; i++){
3                console.log(i);
4                if(i % 5 == 0){
5                    break;
6                }
7            }
</code></pre><p>break如果没有特殊指向，只能终止自己在的内层循环，不能终止外层的其他循环。</p>
<pre><code>1    for(var i = 1 ; i &lt;= 4 ; i++){
2                for(var j = 1 ; j &lt;= 4 ; j++){
3                    console.log(i,j);
4                    if(j == 2){
5                        break;
6                    }
7                }
8            }
</code></pre><p>break控制外层循环：给外层循环加一个标签，标签可以代表外层循环，在break后面加这个标签，就会终止标签对应的这一层循环。</p>
<pre><code>1    waiceng : for(var i = 1 ; i &lt;= 4 ; i++){
2                for(var j = 1 ; j &lt;= 4 ; j++){
3                    console.log(i,j);
4                    if(j == 2){
5                        break waiceng;
6                    }
7                }
8            }
</code></pre><p>所有循环语句：如果能够执行break语句，都会跳出循环。</p>
<h2 id="6、continue"><a href="#6、continue" class="headerlink" title="6、continue"></a>6、continue</h2><p>作用：终止当前这一次的循环，直接进入下一次循环。<br>案例：从1到10，去找偶数，判断如果不是2，不输出直接进入下一个循环。</p>
<pre><code>1    for(var i = 1 ; i &lt;= 10 ; i++){
2                //如果你不能被3整除，直接跳过看下一个可能性
3                if(i % 3 != 0){
4                    continue;
5                }
6                console.log(i);
7            }
</code></pre><p>continue语句与break一样，也只能作用于当前的循环，不能控制外层循环。</p>
<pre><code>1    for(var i = 1 ; i &lt; 4; i++){
2                for(var j = 1 ; j &lt; 4 ; j++){
3                    if(j == 2){
4                        //这不是我要的，继续下一次循环
5                        continue;
6                    }
7                    console.log(i,j);
8                }
9            }
</code></pre><p>控制外层循环：给外层循环加一个标签，将标签名写在continue后面，就可以控制了。</p>
<pre><code>1    waiceng:for(var i = 1 ; i &lt; 4; i++){
2                for(var j = 1 ; j &lt; 4 ; j++){
3                    if(j == 2){
4                        //这不是我要的，继续下一次循环
5                        continue waiceng;
6                    }
7                    console.log(i,j);
8                }
9            }
</code></pre><p>break和continue：能够优化我们的代码。<br>判断一个数是不是质数，通过break简化。</p>
<pre><code>1    var sum = 0;
2        for(var i = 2 ; i &lt;= Math.sqrt(n) ; i++){
3            if(n % i == 0){
4                //说明i是n的一个约数，n肯定不是质数
5                sum++;        
6                // alert(n + &quot;不是质数&quot;);
7                break;
8            }                
9        }
10        if(sum == 0){
11            alert(n+&quot;是质数&quot;);
12        }else{
13            alert(n + &quot;不是质数&quot;);14        }
</code></pre><p>简化：输出1~10000之间的质数</p>
<pre><code>1    //输出2~10000之间的质数
2            //列出所有的情况，只要发现这个数不是质数的可能性，直接跳到下一次循环
3            waiceng:for(var i = 2 ; i &lt;= 10000 ; i++){
4                //判断除了1和本身之外只要有质数，打断，跳入下一次循环
5                for(var j = 2 ; j &lt;= Math.sqrt(i) ; j++ ){
6                    if(i % j == 0){
7                        continue waiceng;
8                    }
9                }
10                //能够进行到这一步，说明前面的continue没发生作用，j一直都不是i的约数
11                // 确定i就是一个质数
12                console.log(i);
13            }
</code></pre>]]></content>
      
        <categories>
            
            <category> 循环语句 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> for </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[if语句]]></title>
      <url>http://yoursite.com/2016/10/10/title5/</url>
      <content type="html"><![CDATA[<h2 id="1、if语句"><a href="#1、if语句" class="headerlink" title="1、if语句"></a>1、if语句</h2><p>if是如果的意思。else，否则。</p>
<pre><code>1    语法：
2    if(condition){
3            statement1   //结构体，多行代码，写在一对大括号内部
4        }else{
5            statement2
6     }
</code></pre><p>结构体要执行就都执行，要不执行，就都不执行。</p>
<p>condition：条件表达式，强制给我们转成布尔值。</p>
<p>含义：如果条件condition为真，执行第一个结构体。如果为假，执行第二个结构体。</p>
<pre><code>1    if(条件){
2    条件为真，执行的结构体；
3    }else{
4    条件为假，执行的结构体；
    }
</code></pre><p>if语句可以没有else，条件成立执行结构体，不成立直接退出程序</p>
<pre><code>1    if(a &lt; 60){
2        alert(&quot;抱歉没及格，努力吧&quot;);3    }
</code></pre><p>如果执行的结构体只有单行语句，可以省略大括号</p>
<pre><code>1    if(a &gt;= 60)
2        alert(&quot;恭喜，及格了&quot;);
3    else
4    alert(&quot;很遗憾，没及格，继续努力&quot;);
</code></pre><p>也能写在if语句的同一行，仅限单行结构体。</p>
<pre><code>1    if(a &gt;= 60) alert(&quot;恭喜，及格了&quot;);
2    else alert(&quot;很遗憾，没及格，继续努力&quot;);
</code></pre><p>这两种写法不会报错，但是为了避免出一些不必要的问题，尽量写大括号。<br>大括号后面不需要写分号，不会出错。</p>
<p>if语句殊途同归，不管执行哪个程序，退出后都继续执行后面的语句</p>
<pre><code>1    if(a &gt;= 60){
2                alert(&quot;恭喜，及格了&quot;);
3            }else{
4                alert(&quot;很遗憾，没及格，继续努力&quot;);
5            }
6            alert(&quot;好好准备下一次考试&quot;);
</code></pre><h2 id="2、多条件分支语句"><a href="#2、多条件分支语句" class="headerlink" title="2、多条件分支语句"></a>2、多条件分支语句</h2><p>条件并不是只有一个，每一个条件对应一个结构体。</p>
<p>if……else if …… else if…… else if…… else …… 如果……否则如果……否则如果……否则……</p>
<pre><code>1    if(条件1){
2        满足条件1执行的结构体
3    }else if(条件2){
4        条件1不满足，满足条件2时执行的结构体
5    }else if(条件3){
6        条件1/2都不满足，满足条件3时执行的结构体
7    }else if(条件4){
8        条件1/2/3都不满足，满足条件4时执行的结构体
9    }else{
10        以上条件都不满足，执行的结构体11    }
</code></pre><p>跳楼现象：程序会选择一个分支执行（跳楼），如果执行了这个分支，表示前面分支的条件都没有满足。</p>
<p>案例：详细划分成绩评价，优秀，良好，及格，不及格。</p>
<pre><code>1    if(a &gt;= 90){
2        alert(&quot;优秀&quot;);
3    }else if(a &gt;= 70){  //如果走到这一步，隐含了a&lt;90
4        alert(&quot;良好&quot;);        //执行完之后，直接跳楼，不会执行后面的条件分之
5    }else if(a &gt;= 60){
6        alert(&quot;及格&quot;);  //如果走到这一步，隐含了a&lt;70
7    }else{
8        alert(&quot;不及格&quot;);9    }
</code></pre><blockquote>
<p>大坑</p>
</blockquote>
<pre><code>1    var b = 1;
2            if(b &lt;= 3){  //只会选择这个条件内部的结构体，执行后直接跳楼
3                b += 4;
4            }else if(b == 5){
5                b += 3
6            }else if(b == 8 ){
7                b += 4
8            }else{
9                b += 10;
10            }
11            console.log(b);
</code></pre><h2 id="3、if语句嵌套"><a href="#3、if语句嵌套" class="headerlink" title="3、if语句嵌套"></a>3、if语句嵌套</h2><p>制作一个结构的时候，有两个限制条件，可以使用if语句的嵌套。</p>
<p>if语句可以嵌套if语句使用，最终执行符合条件成立的结构体</p>
<pre><code>1    if(sex == &quot;男&quot; &amp;&amp; age &gt;= 22){
2                alert(&quot;可以领证了&quot;);
3            }else if(sex == &quot;女&quot; &amp;&amp; age &gt;= 20){
4                alert(&quot;可以领证了&quot;);
5            }else{
6                alert(&quot;你还小，等等吧&quot;);
7            }
</code></pre><p> 以上程序也可以达到效果：结构划分不清晰，条件比较复杂。</p>
<pre><code>1    //if语句嵌套方法，每一层if语句只判断一个条件，内部再去进行另一个条件的判断。
2            //第一层，只判断性别
3            if(sex == &quot;男&quot;){
4                //第二次，判断年龄
5                if(age &gt;= 22){
6                    alert(&quot;可以领证了&quot;);
7                }else{
8                    alert(&quot;你还小，等等吧&quot;);
9                }
10            }else{
11                //第二次，判断年龄
12                if(age &gt;= 20){
13                    alert(&quot;可以领证了&quot;);
14                }else{
15                    alert(&quot;你还小，等等吧&quot;);
16                }
17            }
</code></pre>]]></content>
      
        <categories>
            
            <category> 条件分支语句 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> if </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS条件分支语句]]></title>
      <url>http://yoursite.com/2016/10/10/title6/</url>
      <content type="html"><![CDATA[<h2 id="1、三元运算符"><a href="#1、三元运算符" class="headerlink" title="1、三元运算符"></a>1、三元运算符</h2><p>他是唯一一个需要三个元素参与的运算。<br>也叫作三元表达式。</p>
<blockquote>
<p>符号：? :</p>
<pre><code>1    语法：boolean_expression ? true_value : false_value;
</code></pre></blockquote>
<p>表示：前面的布尔表达式的值只有true和false两种，如果为true，运算结果就是冒号前面的true_value，如果是false，运算结果就是冒号后面的false_value。</p>
<p>表达式：在js里面如果出现表达式，在参与代码运行时，会先计算出结果。</p>
<pre><code>1    var a = 23;
2            console.log(true ? 1 : 0);
3            console.log(false ? 1 : 0);
4            console.log(7 &gt; 8 ? 1 : 0);
5            console.log(a &gt; 0 ? 1 : 0);
6            console.log(&quot;nihao&quot; ? 1 : 0);
7            console.log(&quot;&quot; ? 1 : 0);
</code></pre><p>三元运算符的结果都可以用if语句模仿。</p>
<pre><code>1    //用if语句模拟三元运算符
2        var a = 23;
3        if(a &gt; 0){
4            console.log(1);
5        }else{
6            console.log(0);
7        }
</code></pre><p>简单的二选一得到值的程序里，三元运算符比if语句要更加简单。而且，三元运算符会直接计算出一个值，可以赋值给变量。</p>
<pre><code>1    var a = 7 &gt; 8 ? 1 : 0;
2    console.log(a);
</code></pre><p>遇到给变量通过条件二选一赋值的时候，三元表达式更加好用。</p>
<pre><code>1    var beishu;
2            if(year == 0){
3                //发月薪的1倍月薪年终奖，如果月薪大于8000，那么就是发1.2倍
4                beishu = salary &gt; 8000 ? 1.2 : 1;
5            }else if(year == 1){
6                beishu = salary &gt; 10000 ? 1.7 : 1.5;
7            }else{
8                beishu = salary &gt; 12000 ? 3.2 : 3;
9            }
10            bonus = salary * beishu;
11            alert(&quot;您的年终奖是&quot; + bonus + &quot;元&quot;);
</code></pre><p>拓展：逻辑运算符也有选择的功能。</p>
<pre><code>1    var year = parseFloat(prompt(&quot;请输入你的工作年限，不满1年输入0&quot;)) || 0;
</code></pre><h2 id="2、switch语句"><a href="#2、switch语句" class="headerlink" title="2、switch语句"></a>2、switch语句</h2><p>开关语句允许一个程序求一个表达式的值，并且尝试去匹配表达式的值到一个case标签。如果匹配成功，这个程序执行相关的语句。</p>
<blockquote>
<p>比较if语句和switch语句：</p>
</blockquote>
<p>if语句：</p>
<pre><code>1    if(xingzuo == &quot;白羊座&quot;){
2                alert(&quot;会有旧朋友约见面，还有一两场的应酬，相对是比较有口福的一天，但是要注意别饮食过量，引起肠胃不适，另外还需要花费一笔钱。爱情不太稳定，会有点的小状况，部...&quot;);
3            }else if(xingzuo == &quot;金牛座&quot;){
4                alert(&quot;今天运势佳，生活无忧无虑，爱情欢乐浪漫，时刻能感受到激情的乐趣，单身者寻寻觅觅，真爱可能就在身边。另一半会是你工作上的好帮手，能为你解决许多问题。&quot;);
5            }else if(xingzuo == &quot;双子座&quot;){
6                alert(&quot;今日头脑清醒，思路也变得清晰许多，时间比较宽裕，可以多看看书，多补充一些额外的专业知识，对以后的发展会有帮助。对投资理财有点兴趣，领悟能力不错&quot;);
7            }else{
8                alert(&quot;不好意思，查不到了&quot;);
9            }
</code></pre><p>switch语句：</p>
<pre><code>1    switch(xingzuo){
2                case &quot;白羊座&quot;:
3                    alert(&quot;会有旧朋友约见面，还有一两场的应酬，相对是比较有口福的一天，但是要注意别饮食过量，引起肠胃不适，另外还需要花费一笔钱。爱情不太稳定，会有点的小状况，部...&quot;);
4                    break;
5                case &quot;金牛座&quot;:
6                    alert(&quot;今天运势佳，生活无忧无虑，爱情欢乐浪漫，时刻能感受到激情的乐趣，单身者寻寻觅觅，真爱可能就在身边。另一半会是你工作上的好帮手，能为你解决许多问题。&quot;);
7                    break;
8                case &quot;双子座&quot;:
9                    alert(&quot;今日头脑清醒，思路也变得清晰许多，时间比较宽裕，可以多看看书，多补充一些额外的专业知识，对以后的发展会有帮助。对投资理财有点兴趣，领悟能力不错&quot;);
10                    break;
11                default:
12                    alert(&quot;不好意思，查不到了&quot;);
13                    break;
14            }
</code></pre><p>语法：</p>
<pre><code>1    switch(expression){
2        case label1: //如果表达式的值等于label1，执行下面的statement1.
3            statement1;
4            break;   //遇到break，直接跳出switch语句。
5        case label2: //如果表达式的值等于label2，执行下面的statement2.
6            statement2;
7            break;   //遇到break，直接跳出switch语句。
8        case label3: //如果表达式的值等于label3，执行下面的statement3.
9            statement3;
10            break;   //遇到break，直接跳出switch语句。
11        ……
12        default://前面的情况都不匹配，执行default后面的结构体
13            statement_n;
14            break;15    }
</code></pre><p>default：相当于if语句里面的else。可以省略。如果写了，前面不符合就走default，如果不写，前面情况都不符合，直接跳出switch。后面的break可以不写。</p>
<p>break：打断程序，强制跳出当前的switch语句。如果不写break，程序会继续往下进行，直到碰到一个break或者程序执行完，才能跳出。</p>
<pre><code>1    switch(a){
2                case 3:
3                    alert(&quot;three&quot;);
4                case 4:
5                    alert(&quot;four&quot;);
6                case 5:
7                    alert(&quot;five&quot;);
8                case 6:
9                    alert(&quot;six&quot;);
10                case 7:
11                    alert(&quot;seven&quot;);
12                case 8:
13                    alert(&quot;eight&quot;);
14                case 9:
15                    alert(&quot;nine&quot;);
16                default:
17                    alert(&quot;sorry, I don&apos;t know&quot;);
18            }
</code></pre><p>虽然不写不能跳出程序，我们可以利用这个特点做一些特殊的小程序。</p>
<pre><code>1    var a = parseInt(prompt(&quot;请输入一个个位数，会输出它是奇数还是偶数&quot;));
2            switch(a){
3                case 1:
4                case 3:
5                case 5:
6                case 7:
7                case 9:
8                    alert(&quot;奇数&quot;);
9                    break;            
10                default:
11                    alert(&quot;偶数&quot;);
12            }
</code></pre><p>以下写法是错误：</p>
<p>1    case 1 || 3 || 5 || 7 || 9: //程序遇到表达式会先计算出结果。<br>2        alert(“奇数”);<br>3        break;    </p>
<p>switch语句能做的，if语句都能做。但是对于给某一个值进行匹配的情况，switch语句更优化。</p>
<p>总结：</p>
<blockquote>
<p>if语句最常用，可以做所有的条件分支语句。<br>三元运算符，多用于给某一个变量赋值时二选一的情况。<br>switch语句，多用于给某一个变量去匹配固定值的情况。<br>以下也可以判断成绩好坏，但是不如if语句清晰。</p>
</blockquote>
<pre><code>1    var a = 67;
2            switch(true){
3                case a &gt;= 90:
4                    alert(&quot;best&quot;);
5                    break;
6                case a &gt;= 70:
7                    alert(&quot;better&quot;);
8                    break;
9                case a &gt;= 60:
10                    alert(&quot;good&quot;);
11                    break;
12                default:
13                    alert(&quot;bad&quot;);
14            }
</code></pre>]]></content>
      
        <categories>
            
            <category> 条件分支语句 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> switch </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[运算符介绍]]></title>
      <url>http://yoursite.com/2016/09/30/title4/</url>
      <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><blockquote>
<p>运算符（Operators，也翻译为操作符），是发起运算的最简单形式。<br>数学运算符(Arithmetic operators)<br>比较运算符(Comparison operators)<br>逻辑运算符(Logical operators)<br>赋值运算符(Assignment operators)<br>按位运算符(Bitwise operators)<br>条件 (三元) 运算符(Conditional operator)</p>
</blockquote>
<h2 id="2、数学运算符"><a href="#2、数学运算符" class="headerlink" title="2、数学运算符"></a>2、数学运算符</h2><p>数学运算符： + - * / % ()</p>
<p>运算顺序：先算乘除取余，再算加减，有小括号先算小括号。js里数学运算没有[]、{}，全部用（）代替。</p>
<p>正规：数字与数字之间进行数学运算。非正规：数字与其他类型数据进行运算，其他类型数据之间进行数学运算。</p>
<p>①如果是数字与纯数字字符串字符串之间进行运算。</p>
<p>除了＋号之外，其他的运算符，会自动将字符串转成数字。这个过程是私下进行，叫做隐式转换。不需要使用parseInt等方法。</p>
<pre><code>1    // 数字与纯数字字符串,纯数字字符串之间
2            console.log(12 + &quot;2&quot;);  //&quot;122&quot;
3            //在纯数字字符串参与运算之前，被隐式转换成数字类型
4            console.log(12 - &quot;2&quot;);  //&quot;122&quot;
5            console.log(12 * &quot;2&quot;);  //&quot;122&quot;
6            console.log(12 / &quot;2&quot;);  //&quot;122&quot;
7            console.log(12 % &quot;2&quot;);  //&quot;122&quot;
8            console.log(&quot;12&quot; % &quot;2&quot;);  //&quot;122&quot;
</code></pre><p>②其他类型的数据参与数学运算。</p>
<p>其他类型的数据也会发生饮食转换。]</p>
<blockquote>
<p>转换为0：空字符串、null、false<br>转成1：true<br>转NaN：undefined、非空非纯数字字符串。<br>    1    console.log(23 + true);<br>    2            console.log(23 - true);<br>    3            console.log(23 * true);<br>    4            console.log(23 / true);<br>    5            console.log(23 % true);<br>    6            console.log(23 + false);<br>    7            console.log(23 + null);<br>    8            console.log(23 - “”);<br>    9            console.log(23 - undefined);<br>    10            console.log(23 - “hello”);<br>    11            console.log(23 - “12hello”);</p>
<p>1    “”→0    null→0   false→0    true→1   “12helle”→NaN    undefined→NaN</p>
</blockquote>
<p>③特殊数字参与运算。</p>
<p>特殊值NaN参与的运算都会返回NaN。<br>    1    //所有NaN参与的运算都返回NaN<br>    2            console.log(12 + NaN);<br>    3            console.log(12 - NaN);<br>    4            console.log(12 * NaN);<br>    5            console.log(12 / NaN);<br>    6            console.log(12 % NaN);</p>
<p>Infinity参与的运算，要单独看。</p>
<pre><code>1    //Infinity参与运算
2            console.log(23 + Infinity);
3            console.log(23 - Infinity);
4            console.log(23 * Infinity);
5            console.log(23 / Infinity);
6            console.log(23 % Infinity);
7            console.log(Infinity % Infinity);
8            console.log(Infinity + Infinity);
9            console.log(Infinity - Infinity);
10            console.log(Infinity * Infinity);
11            console.log(Infinity / Infinity);
</code></pre><p>特殊值的数学运算，防止被大公司面试阴，要过一下脑子。不过数学运算的特殊值，真心没有任何实战价值，建议没必要刻意记忆，留着脑容量记更有用的。《高3》P47~P50</p>
<p>总结一下：纯数字字符串、字符串在参与数学运算时，除了加号之外，其他的运算都会隐式转换。<br>其他数据类型参与任何数学运算都会被隐式转换。</p>
<h2 id="3、比较运算符"><a href="#3、比较运算符" class="headerlink" title="3、比较运算符"></a>3、比较运算符</h2><p>种类：</p>
<blockquote>
<p>   大于<br>&lt;    小于<br>=    大于等于<br>&lt;=    小于等于<br>==    相等<br>!=    不等<br>===    全等<br>!==    不全等</p>
</blockquote>
<p>比较运算符输出结果，都是布尔值，要么是true，要么是false。</p>
<pre><code>1    //数字与数字比较
2            console.log(7 &gt; 8);
3            console.log(7 &lt; 8);
4            console.log(7 &gt;= 8);
5            console.log(7 &lt;= 8);
6            console.log(7 == 8);
7            console.log(7 != 8);
8            console.log(7 === 8);
9            console.log(7 !== 8);
10            console.log(8 === 8);
11            console.log(8 !== 8);
</code></pre><p>非常规：数字与其他类型数据进行比较，或者其他数据类型之间进行比较。</p>
<p>①如果数字进行其他比较，其他类型的数据会隐式转换为数字，然后再比较。</p>
<blockquote>
<p>纯数字字符串转为对应的数字，空字符串、null、false转0，true转成1.<br>    1    console.log(1 == “1”);<br>    2    console.log(1 == true);<br>    3    console.log(0 == false);<br>    4    console.log(0 == null);<br>    5    console.log(0 &gt;= null);<br>    6    console.log(0 &lt;= null);<br>    7    console.log(0 == “”);</p>
</blockquote>
<p>相等于和全等于的区别：相等只判断值相等就够了，全等于还要判断数据类型。</p>
<pre><code>1    //判断全等,除了判断值得大小，还要判断数据类型。
2            console.log(1 === &quot;1&quot;);
3            console.log(1 === true);
4    
5            //不等于、不全等于，先看等于和全等于，取反
6            console.log(1 !== &quot;1&quot;);
</code></pre><p>②字符串与字符串进行比较。</p>
<p>不会隐式转换为数字，比较的是Unicode字符编码顺序。顺序在前面的小于顺序在后面。</p>
<p>字符编码顺序：数字0~9、大写字母A~Z、小写字母a~z。</p>
<blockquote>
<p>比较方法：比较的不是字符串的长度，根据字符编码顺序，一个字符一个字符比较，直到比较出大小。</p>
</blockquote>
<pre><code>1    //字符串与字符串进行比较
2            console.log(&quot;12&quot; &lt; &quot;2&quot;);
3            console.log(&quot;22&quot; &lt; &quot;2&quot;);
4            console.log(&quot;abc&quot; &lt; &quot;banana&quot;);
5            console.log(&quot;ball&quot; &lt; &quot;banana&quot;);
6            console.log(&quot;ball&quot; &lt; &quot;23&quot;);
7            console.log(&quot;ball&quot; &lt; &quot;ABC&quot;);
</code></pre><p>③NaN参与的比较</p>
<p>除了不等于和不全等于，NaN参与的比较运算返回的都是false。</p>
<p>④Infinity自身的比较</p>
<p>特殊情况：</p>
<blockquote>
<p>比较：3&gt;2&gt;1;</p>
<p>原因：代码从前往后执行，先计算3&gt;2,得到的是true，再比较时true&gt;1,返回false。<br>控制台快捷键：<br>清空控制台：ctrl+L<br>执行代码：enter<br>换行：shift+enter<br>重新输入上一次代码：Ctrl+↑。</p>
</blockquote>
<h2 id="4、逻辑运算符"><a href="#4、逻辑运算符" class="headerlink" title="4、逻辑运算符"></a>4、逻辑运算符</h2><p>逻辑运算符常用于布尔类型值之间; 当操作数都是布尔值时，返回值也是布尔值。</p>
<blockquote>
<p>&amp;&amp;    逻辑与运算符       且   交集<br>||    逻辑或运算符       并集<br>!    逻辑非运算符    </p>
<p>①逻辑与运算</p>
</blockquote>
<p>真值表</p>
<blockquote>
<p>a &amp;&amp; b<br>a    b    输出<br>真    真    真<br>真    假    假<br>假    真    假<br>假    假    假</p>
</blockquote>
<p>规律：都真才真，有假就假。</p>
<pre><code>1    //逻辑与运算
2            console.log(true &amp;&amp; true);
3            console.log(true &amp;&amp; false);
4            console.log(false &amp;&amp; true);
5            console.log(false &amp;&amp; false);
</code></pre><p>②逻辑或运算</p>
<pre><code>真值表
a || b
a    b    输出
真    真    真
真    假    真
假    真    真
假    假    假
</code></pre><p>规律：有真就真，都假为假。</p>
<pre><code>1    //逻辑或运算
2            console.log(true || true);
3            console.log(true || false);
4            console.log(false || true);
5            console.log(false || false);
</code></pre><p>③逻辑非运算</p>
<p>规律：非真即假，非假即真。</p>
<pre><code>1    // 逻辑非运算
2            console.log(!true);
3            console.log(!false);
4            console.log(!!!!!!!!!!!!false);
</code></pre><blockquote>
<p>正常：用于布尔值之间的逻辑运算。</p>
<p>非正常：其他类型的数据参与逻辑运算。将其他的数据隐式转换成布尔类型的值，计算完之后，输出对应位置的数据。不一定是输出布尔值。</p>
<p>隐式转换成true：非0数字、非空字符串。<br>隐式转换为false：0、NaN、空字符串、undefined、null</p>
</blockquote>
<pre><code>1    //非布尔类型的数据
2            console.log(35 &amp;&amp; null);
3            console.log(35 || null);
4            console.log(35 &amp;&amp; &quot;nihao&quot;);
5            console.log(35 || &quot;nihao&quot;);
</code></pre><p>当它们用于非布尔值的时候，返回值就可能是非布尔值。其实这种运算非常简单，就两句话：</p>
<blockquote>
<p>(逻辑与 &amp;&amp; ) 如果a能被转换为false，那么返回a；否则，返回b。<br>(逻辑或 || ) 如果a能被转换为true，那么返回a；否则，返回b。</p>
</blockquote>
<p>要能深层次的理解上面的话，达到不用刻意背，自行能推倒出来的“最高境界”。<br>花式写法：短路语法。</p>
<h2 id="5、短路语法"><a href="#5、短路语法" class="headerlink" title="5、短路语法"></a>5、短路语法</h2><p>将逻辑运算，模拟电路里面的短路。</p>
<p>①逻辑与<br>比喻成串联电路。</p>
<p>电流通过a到b；<br>如果a为真，电流可以流通到b，不论b为真还是假，直接抛出b。<br>如果a为假，电流通不过，停留在a，就直接抛出a。</p>
<pre><code>1    // //逻辑与运算
2            console.log(23 &amp;&amp; &quot;haha&quot;);
3            console.log(23 &amp;&amp; null);
4            console.log(undefined &amp;&amp; Infinity);
5            console.log(NaN &amp;&amp; null);
</code></pre><p>②逻辑或<br>比喻成并联电路。</p>
<p>电流优先通过a。<br>如果a为真，电流可以直接通过a，不需要到b，直接抛出a。<br>如果a为假，电流不能通过a，换到b流过，不管b为真还是假，都抛出b。</p>
<pre><code>1    //逻辑或运算
2            console.log(23 || &quot;haha&quot;);
3            console.log(23 || null);
4            console.log(undefined || Infinity);
5            console.log(NaN || null);
</code></pre><p>逻辑运算有顺序：非、与、或。</p>
<pre><code>案例：NaN &amp;&amp; null || 23 &amp;&amp; !true || !false
原式= NaN &amp;&amp; null || 23 &amp;&amp; !true || !false
= NaN &amp;&amp; null || 23 &amp;&amp; false || true
= NaN || false || true
= false || true
= true
</code></pre><h2 id="6、赋值运算符"><a href="#6、赋值运算符" class="headerlink" title="6、赋值运算符"></a>6、赋值运算符</h2><p>做了两步工作：先运算，后赋值。必须有变量参与运算。</p>
<blockquote>
<p>=        等于</p>
<p>+=        加等于 将后面的值加到原来的变量值上，得到的值赋值给变量</p>
<p>-=        减等于</p>
<p>*=    </p>
<p>/=</p>
<p>%=</p>
<p>++        递加  在原来的基础上加1，再赋值</p>
<p>–        递减     在原来基础上减一，在赋值</p>
</blockquote>
<pre><code>1    //带等号的赋值运算符
2            var a = 1;
3    
4            //加等于
5            a += 2;// a = a + 2;
6            console.log(a);  //3
7    
8            //减等于
9            a -= 5;   // a = a - 5;
10            console.log(a);   //-2
11    
12            //乘等于
13            a *= -5;   // a = a * -5;
14            console.log(a);  //10
15    
16            //除等于
17            a /= 2;   // a = a / 2;
18            console.log(a);  //5
19    
20            //取余等于
21            a %= 6;   // a = a % 6;
22            console.log(a);   //5
</code></pre><p>递加：<br>符号++，与前面的变量之间不能有空格。而且++符号可以写在变量的前面，也可以写在后面。着这两种情况使用时有一些区别。</p>
<blockquote>
<p>++a:如果在一个算式里，第一次使用的值，是加完后的值，第二次使用也是加完后的新值。<br>a++：如果在一个算是里，参与运算时，第一次使用时原来的就值，第二次使用的时候就是新值。</p>
</blockquote>
<pre><code>1    var a = 2;
2            console.log(a++);
3            console.log(a);
4            a = 2;
5            console.log(++a);
6            console.log(a);
</code></pre><p>特殊运算：</p>
<pre><code>1    var a = 10,
2                b = 20,
3                c = 30;
4            var sum = ++a + b++ + a++ + ++c;
5            console.log(sum); //73
6            console.log(a);  //12
7            console.log(b);  //21
8            console.log(c);  //31
</code></pre><h2 id="7、综合运算顺序"><a href="#7、综合运算顺序" class="headerlink" title="7、综合运算顺序"></a>7、综合运算顺序</h2><p>贴身的 → 数学的 → 比较 → 逻辑的 → 赋值的。</p>
<pre><code>1    综合案例：
2        var a = 4;
3        a *= 1 * (2 + 3) &amp;&amp; ++a || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || !9;4    
原式 = a *= 1 * (2 + 3) &amp;&amp; ++a || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || !9;
 = a *= 1 * (2 + 3) &amp;&amp; 5 || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || false;
 = a *= 5 &amp;&amp; 5 || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || false;
 = a *= 5 &amp;&amp; 5 || false &amp;&amp; true || false
 = a *= 5 || false || false
 = a *= 5
a = 20
</code></pre>]]></content>
      
        <categories>
            
            <category> js </category>
            
        </categories>
        
        
        <tags>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IE6兼容及hack使用]]></title>
      <url>http://yoursite.com/2016/09/28/title3/</url>
      <content type="html"><![CDATA[<p><img src="http://wx1.sinaimg.cn/mw690/a579329cly1fctlpuja4vj20dc07i3ze.jpg" alt=""></p>
<h2 id="一、HACK"><a href="#一、HACK" class="headerlink" title="一、HACK"></a>一、HACK</h2><p>我们真正的网页是由一份html和css来完成，在不同用户电脑上可能不一样的渲染效果。<br>但是我们需要所有浏览器渲染效果都是一致的，由于存在兼容问题，对于一些特殊的html和css，要根据浏览器的不同，写不同的代码，显示效果是一样的，这个技术就叫做HACK（Hacker黑客）。</p>
<p>hack：针对不同的浏览器写不同的html和css，达到显示一致的效果。<br>分类：html hack，css hack。</p>
<p>1、html的hack<br>根据不同的浏览器写不同的html代码。需要用到一个辅助的代码，叫做hack符号。IE浏览器存在很多兼容问题，IE给我们留了一个接口，规定的IE版本的浏览器认识里面是html结构，其他的浏览器认为里面的是注释。</p>
<pre><code>&lt;!--[if lte IE 9]&gt;
   这是一段文字
&lt;![endif]--&gt;
</code></pre><p>这段代码里面的文字，只能在IE9及以下的版本浏览器内看得到。其他的不显示，认为是注释。</p>
<blockquote>
<p>if：如果 lte：小于等于 IE 浏览器 9版本。</p>
<p>lte：less than or equal ，小于等于</p>
<p>lt：less than ，小于</p>
<p>gt：greater than ，大于</p>
<p>gte： greater than or equal ，大于等于</p>
</blockquote>
<p>如果低于IE8就显示，其他的认为是注释。</p>
<pre><code>&lt;!--[if lt IE 8]&gt;
       &lt;h1&gt;这是一个标题&lt;/h1&gt;
    &lt;![endif]--&gt;
</code></pre><p>如果高于IE8就显示，其他的认为是注释。</p>
<pre><code>&lt;!--[if gt IE 8]&gt;
    &lt;h2&gt;大于IE8能看见&lt;/h2&gt;
&lt;![endif]--&gt;
</code></pre><p>如果只有IE8认识，其他都是注释。</p>
<pre><code>&lt;!--[if IE 8]&gt;
    &lt;p&gt;只有IE8认识&lt;/p&gt;
&lt;![endif]--&gt;
</code></pre><p>作为浏览器版本提醒：<br>      <!--[if lte IE 8]>
           <h2>你的浏览器版本过低，请更新。</h2>
      <![endif]--><br>      <div class="box"></div></p>
<p>有一些代码在IE中加载，其他浏览器不加载。<br>      <!--[if IE 6]>
          <script src="js/ie6.js"></script>
      <![endif]--></p>
<p>位置不能乱写：不能卸载css样式里面</p>
<pre><code>&lt;style&gt;
       .box{
           width: 100px;
           height: 100px;
           border-radius: 50%;
           background: skyblue;
       }
       &lt;!--[if IE 6]&gt;
       &lt;script src=&quot;js/ie6.js&quot;&gt;&lt;/script&gt;
      &lt;![endif]--&gt;
   &lt;/style&gt;
</code></pre><h2 id="2、css的hack"><a href="#2、css的hack" class="headerlink" title="2、css的hack"></a>2、css的hack</h2><p>针对不同的浏览器写不同的css样式。</p>
<p>css hack：值的hack、选择器的hack</p>
<ul>
<li>2.1 值的hack</li>
<li><p>对某一个特定的属性值写hack。<br>/IE6/<br>hack符：_下划线、-横线。</p>
<pre><code>.box{
           width: 100px;
           height: 100px;
           background: skyblue;
           _background: gold;//表示只有IE6认识
}
</code></pre><p>其他浏览器会认为是未知的属性名：unknown property name。</p>
</li>
</ul>
<blockquote>
<p>/IE6、7/</p>
<p>hack符：~ ! @ # $ % ^ &amp; * ( ) + ` [ ] | &lt; &gt; ? / .任意一个符号都可以，表示只有ie6/7认识，其他的都是不认识。</p>
</blockquote>
<pre><code>!background: green;
|background: green;
+background: green;
[background: green;
</code></pre><blockquote>
<p>/<em>IE8</em>/<br>hack符：在属性值的后面加\0/。</p>
</blockquote>
<pre><code>.selector { color: blue\0/; }
</code></pre><p>只有IE8里加载这个属性。</p>
<pre><code>background: red\0/;
</code></pre><blockquote>
<p>/<em>IE8/9</em>/<br>hack符：在属性值后面加\0.</p>
</blockquote>
<pre><code>/*IE6/7/8/9/10*/
hack符：在属性值后面加\9


background: red\9;
</code></pre><p>实际工作：记住IE6的下划线。IE6/7记住一个！。</p>
<ul>
<li>2.2 选择器hack</li>
<li><p>针对不同的浏览器，加载不同选择器内的所有样式。</p>
<p>  /<em> IE 6 and below </em>/<br>      html .selector {}<br>只有IE6及以下的浏览器认识这个选择器。高级浏览器认为html就是整个结构的根元素，不包含在*通配符选择器内，所以不认识这个选择器。而IE6及以下是认识。</p>
<pre><code>.box{
           width: 100px;
           height: 100px;
           background: skyblue;
       }
       * html .box{
           width: 200px;
           height: 200px;
           background: pink;
      }
</code></pre><p>等价于：内部的属性值都加hack符。</p>
<pre><code>_width: 200px;
_height: 200px;
_background: pink;
</code></pre></li>
</ul>
<p>/<em> IE 7 and below </em>/</p>
<p>.selector, {}<br>IE7及以下才认识的选择器写法。</p>
<pre><code>.box,{
           width: 200px;
           height: 200px;
           background: green;
      }
</code></pre><p>等价于：</p>
<pre><code>.box{
           !width: 200px;
           !height: 200px;
           !background: green;
       }
</code></pre><p>/<em> Everything but IE 6 </em>/</p>
<p>html &gt; body .selector {}表示出了IE6其他的浏览器都认识。<br>IE6不支持&gt;表示的子级选择器。</p>
<pre><code>html&gt;body .box{
           width: 200px;
           height: 200px;
           background: purple;
      }
</code></pre><p>/<em> Everything but IE 6/7 </em>/</p>
<p>html &gt; /**/ body .selector {}</p>
<p>head ~ /<em> </em>/ body .selector {}</p>
<p>除了IE6/7，其他的都认识。<br>实际：选择器的hack不常用，不会把所有的属性都重写，单一的属性单独设置，直接用值hack。</p>
<h2 id="二、IE6兼容问题"><a href="#二、IE6兼容问题" class="headerlink" title="二、IE6兼容问题"></a>二、IE6兼容问题</h2><ul>
<li>1、盒模型</li>
<li>1.1 DTD</li>
</ul>
<p>如果页面没有写文档DTD，页面盒子在加载时其他高级浏览器正常加载，IE6加载模式是一种怪异模式。</p>
<p>正常：宽高确定后，添加内边距、border盒子整体外扩。</p>
<p>怪异：宽高确定后，添加内边距、border盒子会往内自减，实际书写内容区域变小。</p>
<p>解决方法：写DTD。</p>
<p>1.2盒子高度不能低于字号</p>
<p>IE6有默认字号是18px。其他浏览器都能够设置盒子高度低于默认字号的盒子。IE6不能让盒子高度低于18px。</p>
<p>解决方法：给你要设置高度的盒子单独设置一个字号属性，属性值小于你要设置的盒子高度。</p>
<pre><code>_font-size: 0;只有IE6加载这个属性。
</code></pre><p>1.3 图片边框问题</p>
<p>图片外如果包裹了一个a标签，在IE6里会比正常情况给图片多加了一个蓝色的边框。</p>
<p>解决方法：给img都清除边框。</p>
<pre><code>img{
  border: none;
}
</code></pre><ul>
<li>2、浮动</li>
<li>2.1 一个浮动一个不浮动</li>
</ul>
<p>高级浏览器：不浮动的元素会钻到浮动元素下面。</p>
<p>IE6：排在浮动元素后面。不会出现压盖效果。</p>
<p>解决方法：不要用浮动制作压盖，同级元素一个浮动另外一个也要浮动。</p>
<p>2.2 3像素bug</p>
<p>如果元素一个浮动，一个不浮动，IE6里会并排排列，同时两个元素之间多了3像素间距。</p>
<p>解决方法：</p>
<blockquote>
<p>①同级元素一个浮动另外一个也要浮动。<br>②给浮动的元素添加一个margin-right值为-3px的属性。</p>
</blockquote>
<pre><code>.box1{
           width: 100px;
           height: 100px;
           background: #f40;
           float: left;
           margin-right: -3px;
       }
</code></pre><p>2.3 双倍margin问题</p>
<p>如果浮动的方向和margin边距的方向相同，那么首个浮动的元素距离父盒子的边距是margin值的两倍。</p>
<p>解决方法：</p>
<blockquote>
<p>①浮动的方向与margin的方向相反，父盒子和第一个元素的间距用父盒子的padding挤出来。不要用儿子踹父亲。<br>      ul{<br>                 list-style: none;<br>                 width: 780px;<br>                 padding-right: 20px;<br>                 height: 40px;<br>                 border: 1px solid #000;<br>                 margin: 100px auto;<br>             }<br>             ul li{<br>                float: right;<br>                width: 100px;<br>                height: 40px;<br>                background: #f40;<br>                margin-left: 20px;<br>            }</p>
</blockquote>
<p>②非要用margin去撑开。单独给IE6的第一个盒子设置一个margin值减半。</p>
<pre><code>  ul li.half_margin{
      _margin-right: 10px;
}
</code></pre><p>2.4 overflow:hidden失效</p>
<p>加了overflow属性之后，盒子可以清除内部的浮动，自适应高度。IE6以前不能使用它来清浮动的效果。布局：layout。</p>
<p>IE有两个加载机制：有布局、没有布局。</p>
<p>有布局：hasLayout，盒子在布局时，根据内部元素的内容来进行布局。</p>
<p>没有布局：盒子在布局时，盒模型数据是来源于父元素。<br>我们需要想办法触发有布局机制。有很多属性都能触发。有一个属性始终能够触发zoom放大属性。<br>属性值：数字，1表示按1倍放大，2表示按2倍放大……</p>
<pre><code>.box{
           width: 700px;
           border: 10px solid #999;
           margin-bottom: 20px;
           overflow: hidden;
          _zoom: 1;
      }
</code></pre><h2 id="三、图片和透明"><a href="#三、图片和透明" class="headerlink" title="三、图片和透明"></a>三、图片和透明</h2><ul>
<li>1、图片</li>
<li></li>
</ul>
<p>网页使用的三种图片：JPG、png、GIF。<br>分辨率：72像素/英寸</p>
<p>1.1 JPG图片</p>
<p>是我们最常用的一种图片格式。</p>
<blockquote>
<p>特点：色彩丰富。可以压缩，品质可以调整。</p>
<p>缺点：不能保存图层，不能做动图，不能保存背景透明、图片半透明的效果。</p>
<p>用途：有实际意义的结构，用作插入图，背景不是透明的背景图，图片大小比较小。</p>
</blockquote>
<p>1.2 png图片</p>
<blockquote>
<p>特点：不可压缩，可以保存图层，可以保存透明和半透明。</p>
<p>缺点：文件太大。</p>
</blockquote>
<p>大小并不是一定png就比JPG大。色彩很丰富，图层保存比较多的时候，肯定是png文件大。如果保存的图片背景透明，文件色彩、形状都比较简单，png图片导出成没有图层的时候，文件反而比JPG要小。<br>png图片保留一份带图层，往网上上传是需要将png图片导出一份图层合并之后。</p>
<blockquote>
<p>用途：背景透明和半透明的图片，精灵图，图片比较小色彩不是很复杂。</p>
</blockquote>
<p>1.3 GIF图片</p>
<p>GIF图片无所压缩不压缩的问题。色彩比较单一，色值有256种、128种、216种、64种……2种。</p>
<blockquote>
<p>特点：文件小，可以存动图，能够保存透明，不能保存半透明。</p>
<p>动图：通过添加时间轴帧动画，每一帧都有一张图片，连续按照一定的时间间隔播放，有一个动图的效果。<br>背景透明：同一个图片，png比GIF文件要大。</p>
<p>用途：动图，完全透明的背景图片（解决pngIE6背景透明的兼容问题）。</p>
</blockquote>
<ul>
<li>2、盒子透明</li>
<li><p>需要用一个属性完成，透明度属性opacity，属性值是0到1之间的小数。</p>
<p>  opacity: 0.5;<br>透明效果：盒子本身半透明，内部的元素也跟着透明。</p>
</li>
</ul>
<p>IE8及以下的浏览器不支持opacity属性。虽然不支持，IE有自己的设置盒子透明的属性，滤镜属性filter。<a href="http://justcoding.iteye.com/blog/940184/比较强大。内部有多重滤镜属性，其中包括alpha通道透明。" target="_blank" rel="external">http://justcoding.iteye.com/blog/940184/比较强大。内部有多重滤镜属性，其中包括alpha通道透明。</a></p>
<p>透明度的数值注意：0~100之间的整数。</p>
<pre><code>filter: alpha(opacity=50);
</code></pre><p>解决内容同时透明的问题：只让盒子透明，内容不透明。将文字单独拿出来放在别的盒子里，用定位定到半透明幕布上面。</p>
<ul>
<li>3、图片透明</li>
<li>除了IE6，其他浏览器都能够正常的加载背景透明或半透明效果的PNG图片。ie6不支持。</li>
</ul>
<p>解决IE6的png图片兼容问题：</p>
<blockquote>
<p>方法一：如果只有透明，没有半透明，可以用GIF图片格式代替，GIF在IE6里没有兼容问题。</p>
<p>方法二：给我们页面添加一段只有IE6认识的js代码，解决png背景透明问题。</p>
<pre><code> &lt;!--[if IE 6]&gt;
       &lt;script type=&quot;text/javascript&quot; src=&quot;js/png.js&quot;&gt;&lt;/script&gt;
       &lt;script type=&quot;text/javascript&quot;&gt;
           DD_belatedPNG.fix(&quot;选择器&quot;);//多个选择器，用逗号隔开
       &lt;/script&gt;
&lt;![endif]--&gt;
</code></pre></blockquote>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS中定位的使用]]></title>
      <url>http://yoursite.com/2016/09/23/title2/</url>
      <content type="html"><![CDATA[<h2 id="1、相对定位"><a href="#1、相对定位" class="headerlink" title="1、相对定位"></a>1、相对定位</h2><p>定位：元素位置相对于某一个参考物进行的位置的偏移。</p>
<p>相对定位：元素相对于自身进行的位置偏移。position：定位属性。属性值：relative。相对的。</p>
<p>偏移的数据量。有其他属性来控制，方向属性，left、right、top、bottom。</p>
<pre><code>position: relative;
left: 100px;  
top: 110px;
</code></pre><p>便宜方向判断：如果属性值为正，偏移方向与属性方向相反。</p>
<pre><code>left: 100px;          向右100
top: 110px;           向下110
right: 20px;          向左20
bottom: 20px;         向上20
</code></pre><p>等价于：属性值为负值，便宜方向与属性方向相同。</p>
<pre><code>right: -100px;       向右100
bottom: -110px;      向下110
</code></pre><p>综合：水平方向和垂直方向可以任选一个属性，进行搭配。</p>
<pre><code>.box{        
      left: 100px;      //以元素自身左上角顶点为参考点，向右向下移动
      top: 110px;
}

left: 100px;
bottom: 110px;    //以元素自身的左下顶点为参考点，向右上移动。

right: 50px;
bottom: 110px;   //以元素自身的右下顶点为参考点，向左上移动。

right: 50px;
top: 110px;          //以元素自身的右上顶点为参考点，向左下移动。
</code></pre><p>特点：显示的位置是偏移后的位置，原位置还保留，没有被其他元素给占有，形影分离。<br>相对定位不会让元素脱离标准流，标准流的位置还是他自己的。用途不是很多，也有自己的特殊用途。</p>
<blockquote>
<p>①结构比较稳固，经常拿来做绝对定位的参考元素，子绝父相。<br>②微调。</p>
</blockquote>
<pre><code>  div span{
      font-size: 12px;
      position: relative;
      bottom: 6px;
}
</code></pre><h2 id="2、绝对定位"><a href="#2、绝对定位" class="headerlink" title="2、绝对定位"></a>2、绝对定位</h2><p>绝对定位的定位参考元素不固定的，但是不是本身。属性值：absolute。绝对的。<br>也有四个方向的偏移量：left、right、top、bottom。</p>
<pre><code>position: absolute;
top: 100px;
left: 150px;
</code></pre><p>特点：与相对定位比较，元素绝对定位之后，脱离标准流，标准流的位置让给了后面的元素。<br>绝对定位的元素根据选取偏移方向不同，参考点也不同。</p>
<p>①参考元素为body时的定位参考点</p>
<blockquote>
<p>有top参与的绝对定位，定位的参考点是页面（body）的左上角和右上角</p>
<pre><code>position: absolute;
top: 200px;
right: 300px;
</code></pre><p>有bottom参与的绝对定位：参考点是页面（body）首屏的左下角和右下角。</p>
<pre><code>position: absolute;
bottom: 200px;
left: 300px;
</code></pre></blockquote>
<p>②祖先元素作为参考元素</p>
<p>如果祖先元素中有定位的元素，元素绝对定位的参考元素就是距离它最近的有定位的祖先元素。</p>
<pre><code>&lt;div class=&quot;box1&quot;&gt;                        //有相对定位
       &lt;div class=&quot;box2&quot;&gt;                //有相对定位
            &lt;div class=&quot;box3&quot;&gt;//没有定位
                &lt;p&gt;&lt;/p&gt;                  //绝对定位，参考元素是box2
            &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;


   &lt;div class=&quot;box1&quot;&gt;                        //有相对定位
          &lt;div class=&quot;box2&quot;&gt;                //有绝对定位
            &lt;div class=&quot;box3&quot;&gt;//没有定位
               &lt;p&gt;&lt;/p&gt;                  //绝对定位，参考元素是box2
            &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
</code></pre><p>绝对定位元素的参考盒子，可以是相对定位，也可以是绝对定位，还可以是固定定位。</p>
<pre><code>子绝父相：子元素是绝对定位，参考的祖先元素是相对定位。
子绝父绝：子元素是绝对定位，参考的祖先元素是绝对地位。
子绝父固：子元素是绝对定位，参考的祖先元素是固定地位。
</code></pre><p>只要祖先元素中有任何一种定位，距离该子元素最近，它就是定位参考元素。<br>子绝父相方法最常用：相对定位的元素不脱离标准流，结构稳定，对于当参考物来说比较方便。</p>
<p>③祖先元素参考时的参考点</p>
<p>会忽视我们祖先元素的padding区域，以border内部的四个顶点作为相应方向的参考。相应方向：与使用的定位偏移方向是一致。</p>
<pre><code>position: absolute;
bottom: 50px;
left: 50px;
</code></pre><p>④制作压盖效果</p>
<p>用绝对定位制作压盖效果。</p>
<pre><code>.box{
          position: relative;
          width: 400px;
           height: 400px;
           border: 1px solid #000;
           padding: 20px;
           margin: 100px auto;
       }
       .demo1{
          width: 400px;
          height: 400px;
          background: skyblue;
      }
      .demo2{
         width: 100px;
           height: 30px;
           background: gold;
           position: absolute;
           left: 160px;
           bottom: 40px;
       }
</code></pre><p>⑤绝对定位元素的居中</p>
<p>不能使用标准流的方法，只能先左边线居中，自身拽回宽度一半。</p>
<pre><code>.demo2{
           width: 100px;
           height: 30px;
           background: gold;
           position: absolute;
           left: 50%;                     移动父亲宽度的50%
           bottom: 40px;
           margin-left: -50px;将元素本身拽回自身宽度的一般
       }
</code></pre><p>补充：鼠标显示小手状态cursor: pointer;</p>
<h2 id="3、固定定位"><a href="#3、固定定位" class="headerlink" title="3、固定定位"></a>3、固定定位</h2><p>固定定位，参考我们的浏览器窗口进行定位。属性值：fixed。始终保持针对浏览器窗口某一个顶点位置相对不变。也有四个方向的偏移量的值：left、right、top、bottom。</p>
<pre><code>position: fixed;
bottom: 80px;
right: 80px;
</code></pre><h2 id="4、压盖顺序z-index"><a href="#4、压盖顺序z-index" class="headerlink" title="4、压盖顺序z-index"></a>4、压盖顺序z-index</h2><p>默认压盖顺序：</p>
<blockquote>
<p>①有定位的元素压盖没有定位的元素。<br>②有定位的元素，不区分定位类型，只要html结构写在后面的压盖写在前面。</p>
</blockquote>
<p>自定义压盖顺序</p>
<p>属性：z-index，压盖顺序。属性值：数字，没有任何单位，数值越大，压盖数值小的。</p>
<blockquote>
<p>①只能给定位的元素加，其他的标准流的或者浮动元素都没有z-index属性。默认的定位元素的z-index值是1.</p>
<pre><code>position: relative;
left: 0;
bottom: 300px;
z-index: 2;
</code></pre><p>②属性值越大的会压盖属性值越小的。</p>
<p>③如果属性值相同，看html结构书写顺序，后面的压盖前面的。</p>
<p>④父子盒模型里，如果父子都有定位，都有自定义的z-index值，两对父子对比时，不管子元素的属性值多大，只要父亲z-index值小，都只能被压盖。子级再大，如果父级数值小，都不管用。</p>
</blockquote>
<pre><code>&lt;div class=&quot;box1&quot;                 //父亲一z-index是5
   &lt;div class=&quot;small&quot;&gt;1&lt;/div&gt;//30
&lt;/div&gt;
 &lt;div class=&quot;box2&quot;&gt;//父亲二z-index是4
    &lt;div class=&quot;big&quot;&gt;2&lt;/div&gt;//100
&lt;/div&gt;
</code></pre>]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS-background背景]]></title>
      <url>http://yoursite.com/2016/09/19/title1/</url>
      <content type="html"><![CDATA[<h2 id="1、background-color背景色"><a href="#1、background-color背景色" class="headerlink" title="1、background-color背景色"></a>1、background-color背景色</h2><p>渲染位置：border及以内。<br>属性值：十六进制、rgb、rgba、颜色名。</p>
<pre><code>background-color: blue;
</code></pre><h2 id="2、background-image背景图"><a href="#2、background-image背景图" class="headerlink" title="2、background-image背景图"></a>2、background-image背景图</h2><p>实际渲染位置：跟背景色一样，能看到的其实就是border以内。<br>属性值：url(图片路径)。</p>
<pre><code>background-image: url(images/hai.jpg);
</code></pre><p>添加的背景图片会铺满整个盒子的背景区域。</p>
<p>url：uniform resource locator。统一资源定位符。实际就是背景图片的来源。<br>url内部的值：图片的路径，可以是相对路径，也可以是绝对路径。</p>
<p>背景图和背景色的压盖顺序：image压盖color。</p>
<h2 id="3、background-repeat背景重复"><a href="#3、background-repeat背景重复" class="headerlink" title="3、background-repeat背景重复"></a>3、background-repeat背景重复</h2><p>设置背景图片以什么方式进行重复。<br>属性值：<br>repeat 默认值，整个背景区域重复<br>no-repeat 不重复<br>repeat-x 水平方向重复<br>repeat-y 垂直方向重复</p>
<pre><code>background-repeat: repeat;
background-repeat: no-repeat;
background-repeat: repeat-x;
background-repeat: repeat-y;`
</code></pre><p>body背景加载效果：</p>
<p>repeat-x的一个妙用：制作一个渐变背景的导航栏。<br>给盒子添加一个背景图：水平方向1像素宽，垂直方向就是正常高度，让背景图，水平重复铺开。</p>
<pre><code>background-image: url(images/nav_bg.png);
background-repeat: repeat-x;
background-position背景图位置
</code></pre><p>作用：规定我们插入的背景图的在盒子里的位置。<br>属性值：像素表示法、单词表示法、百分比表示法。</p>
<p>①像素表示法<br>属性值有两个，都用像素表示：</p>
<pre><code>background-position: 150px 100px;
</code></pre><p>第一个属性值：背景图片左上角距离盒子背景区域左上角（border以内）的水平偏移量。</p>
<p>第二个属性值：背景图片左上角距离盒子背景区域左上角（border以内）的垂直偏移量。</p>
<p>位置的属性值分正负。正方向：向右向下移动；负方向：向左向上移动。指的是图片针对（0,0）点移动的方向。</p>
<p>css精灵图技术：很多元素都有背景图，需要有实际存在图片，就需要发送多个http请求下载图片。将很多小的背景图合成在一张图片上，谁用背景图加载的都是一张图片。<br>用法：给一个合适盒子大小，通过背景图定位找到图片的位置。</p>
<p>②单词表示法</p>
<p>图片位置水平和垂直方向用代表方向的单词来表示</p>
<p>水平方向，第一个属性值：left ，center，right。背景在盒子内部居左、居中、居右。</p>
<p>垂直方向，第二个属性值：top，center，bottom。背景图在盒子内部居上、居中、居下。</p>
<pre><code>background-position: center center;
</code></pre><p>body大背景效果：水平居中、垂直居上。</p>
<pre><code>background-position: center top;
</code></pre><p>制作通栏ｂａｎｎｅｒ。</p>
<p>③百分比表示法</p>
<p>关注：百分比参考依据。</p>
<pre><code>background-position: 100% 50%;
background-attachment背景附着
</code></pre><p>指的是背景是否随着页面滚动而滚动。</p>
<p>属性值：<br>scroll 滚动，背景图会随着页面滚动走。</p>
<p>fixed 固定，背景图不会随着页面滚动而滚走。<br>    background-attachment: fixed;</p>
<h2 id="background复合属性"><a href="#background复合属性" class="headerlink" title="background复合属性"></a>background复合属性</h2><pre><code>background: #f00 fixed url(images/bg4.jpg) no-repeat center top;
</code></pre><p>五个属性之间位置可以更换，position的两个属性值位置不能电脑。</p>
<p>#二、背景实际应用#</p>
<h2 id="1、padding挤出背景图效果"><a href="#1、padding挤出背景图效果" class="headerlink" title="1、padding挤出背景图效果"></a>1、padding挤出背景图效果</h2><p>方法：给盒子用padding-left留出一个空白区域，添加一个合适的背景图，不重复。</p>
<pre><code>padding-top: 96px;
background: url(images/in_12.png) no-repeat center top;
</code></pre><h2 id="2、文字换图片"><a href="#2、文字换图片" class="headerlink" title="2、文字换图片"></a>2、文字换图片</h2><p>提高搜索引擎优化：搜索时都是搜索文字。</p>
<p>h1标签内部放的是logo的图片。用一个技巧，logo图不用插入图，换成背景图，内部放置的是简单的关键字。</p>
<pre><code>h1 a{
    display: block;
    height: 96px;
    background: url(images/in_15.png); 添加背景图，用户看到
    text-indent: -9999px; 隐藏文字
    overflow: hidden;
}
</code></pre>]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css中浮动的影响]]></title>
      <url>http://yoursite.com/2016/09/11/title/</url>
      <content type="html"><![CDATA[<h2 id="1、浮动存在的问题"><a href="#1、浮动存在的问题" class="headerlink" title="1、浮动存在的问题"></a>1、浮动存在的问题</h2><p>浮动的元素不能撑高父级。元素脱离标准流之后， 不能再撑高它的父级盒子<br>浮动会影响后面的浮动的元素。如果后面的浮动方向相同， 会去贴上一个浮动最后一个元素的边。</p>
<h2 id="2、清楚浮动影响的方法"><a href="#2、清楚浮动影响的方法" class="headerlink" title="2、清楚浮动影响的方法"></a>2、清楚浮动影响的方法</h2><ul>
<li>给父盒子加高度<br>给父级元素增加高度， 它内部的浮动元素， 被限制了范围， 不会再影响后面的元素浮动。</li>
</ul>
<blockquote>
<p>效果： 解决父级高度的问题， 解决浮动影响后面的浮动的问题。<br>      问题： 高度还是不能够自适应。</p>
</blockquote>
<ul>
<li>清除浮动属性 clear</li>
</ul>
<p>元素都可以设置一个叫做 clear 的属性， 清除浮动的作用。</p>
<blockquote>
<p>属性值： left、 right、 both。<br>作用： clear 整体表示清除自身受到的其他元素带来的浮动的影响。<br>left： 清除受到的左浮动影响。<br>right： 清除受到的右浮动影响。<br>both： 清除受到的左右两个方向的浮动影响。</p>
</blockquote>
<pre><code>box1{

clear: both;}
`
</code></pre><blockquote>
<p>  解决： 浮动的互相影响。`</p>
<p>问题： 父盒子还是不能被子盒子撑高。 margin 如果小于中间浮动的子元素的高度， 显示效果失效。<br>隔墙法<br>外墙法：<br>在右浮动元素的父盒子之间隔一堵墙。 添加两个类， 一个是用来清除浮动， 一个用来模拟外边距。</p>
</blockquote>
<pre><code>cl{
     clear: both; 清除浮动

  }

  .h20{

      height: 20px; 模拟间距

  }
</code></pre><p>解决： 浮动互相影响。<br>问题： 高度自适应， MARGIN 失效。</p>
<a id="more"></a>
<ul>
<li>内墙法：<br>将清除浮动的墙放在有浮动元素的父盒子内部的最后。 只要有浮动， 就在盒子内部加一堵墙。</li>
</ul>
<blockquote>
<p>解决： 浮动互相影响， 高度自适应， margin 失效。</p>
<p>缺点： ①html 结构布局， 很多需要进行浮动， 每个浮动的盒子内都需要隔一堵墙。 页面结构复杂会出现很多<br>冗余的没有意义的标签。</p>
<p>②一个盒子内的标签要浮动就都浮动， 浮动后面的墙是一个标准流里的元素<br>overflow： hidden<br>盒子内部的元素可以设置溢出模式， 隐藏， 自动显示。<br>overflow： 溢出。</p>
</blockquote>
<p>属性值： hidden 溢出隐藏， auto 溢出滚动（ 多出的内容出现滚动条）<br>`</p>
<pre><code>{
      `overflow： hidden;
      overflow： auto;`
}
</code></pre><p>overflow 的其他小功能： 能够清除盒子内部元素的浮动影响 </p>
<p>解决： 浮动互相影响， 高度自适应， margin 失效。</p>
<p>优势： 能够解决所有的问题， 不会增加无用的标签。</p>
<h2 id="3、overflow：-hidden；-的加载机制："><a href="#3、overflow：-hidden；-的加载机制：" class="headerlink" title="3、overflow： hidden； 的加载机制："></a>3、overflow： hidden； 的加载机制：</h2><p><strong>高度自适应： </strong></p>
<p>如果元素有溢出隐藏的属性， 网页加载时， 会强制的去元素内部搜索， 识别所有内部元素的高度， 会用最高的元素高度配给我们父盒子的自适应高度。</p>
<p><strong>浮动影响：</strong></p>
<p> 加载时， 如果有溢出隐藏， 强制检索， 看盒子内部是否有浮动的元素， 如果有， 会被整体管理起来， 在自身的高度内， 不会影响其他的浮动元素。<br>实际工作中： 就用 overflow 来清浮动</p>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
