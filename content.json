{"meta":{"title":"Layne'blog","subtitle":"Web world is wonderful!","description":"Diligence makes an ordinary man realize an extraordinary ideal!","author":"郭石磊","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-02-23T07:24:15.250Z","updated":"2017-02-23T06:52:23.497Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"腾讯公益404页面"},{"title":"404 Not Found：该页无法显示","date":"2017-02-23T12:32:32.181Z","updated":"2017-02-23T12:32:32.181Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":"title: 404 Not Found：该页无法显示toc: falsecomments: false permalink: /404 .article-header { padding: 0; padding-top: 26px; border-left: none; text-align: center; } .article-header:hover { border-left: none; } .article-title { font-size: 2.1em; } strong a { color: #747474; } .article-meta { display: none; } .share { display: none; } .ds-meta { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } #container .article-info-post.article-info { display: none; } #container .article .article-title { padding: 0; }"},{"title":"About","date":"2017-02-17T06:05:28.000Z","updated":"2017-02-25T04:34:10.117Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"[Name]CN：郭石磊（Guo Shilei）| EN: Layne [Contact]电话：18500351690 微博: honey笔杆子 微信: xlszgsl Q Q：294268937 知乎: Layne GitHub: guoshilei Email: 294268937@qq.com 教育背景2010-2014 北京化工大学 本科 视觉传达专业 [Motto]勤奋会使一个平凡的人实现不平凡的理想！ 工作经验 2013/11—2014/7 北京盛林兰广告公司 平面设计 客户之间的沟通和公司内部市场部之间的协调和沟通 宣传册、书籍封面、banner设计 负责北京塞纳印象客户项目 2014/8–2015/9 北京亚控科技发展有限公司 前端开发 根据公司项目需求和UI设计师的设计图，运用div+css、html将设计图快速生成页面，并进行交互 解决浏览器兼容等问题 协助美工美化图片 2015/10–2017/1 北京亿莎商业管理有限公司 web前端开发 根据UI设计图及需求说明书进行网页开发，与开发人员确认后台接口及数据格式，配合后台开发人员进行测试，实现商品详情功能模块，完成用户中心，个人订单，相关维护工作。 专业技能1、熟悉W3C标准与ES规范，对J面向对象有一定理解。 2、HTML，CSS，JavaScript基础扎实，掌握JS面向对象开发原理和闭包原理。 3、熟练掌握常用主流Web前端框架，如Bootstrap，jQuery，AngularJS等。 4、熟悉CSS3和HTML5的新特性，并且能够实现CSS3动画（2D、过渡等）。 5、能熟练高效手工编写HTML及CSS、JS代码，熟悉DIV+CSS布局。 6、对前端模块化开发有一定了解。 自我评价为人诚恳,积极进取,适应力强、勤奋好学、脚踏实地，有较强的团队精神,工作积极进取,态度认真，做事情始终坚持有始有终，从不半途而废；有问题不逃避,愿意虚心向他人学习；会用100%的热情和精力投入到工作中。 [Introduce] 为了成为前端世界的武林盟主，还需要不断不断不断学习~ 乐于结交各路武林高手，喜欢折腾，喜欢尝试新鲜事物~ 喜欢研究前端一些技术~~ 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"categories","date":"2017-02-17T06:04:31.000Z","updated":"2017-02-17T06:04:57.530Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-14T14:57:02.702Z","updated":"2017-02-14T14:57:02.682Z","comments":true,"path":"photos/ins.css","permalink":"http://yoursite.com/photos/ins.css","excerpt":"","text":"Skip to content This repository Search Pull requests Issues Gist @guoshilei Sign out Watch 1 Star 36 Fork 95 litten/BlogBackup Code Issues 3 Pull requests 0 Projects 0 Wiki Pulse Graphs Branch: master Find file Copy pathBlogBackup/source/photos/ins.css 3e5f94a on 5 Dec 2016 @litten litten update 1 contributor RawBlameHistory 145 lines (144 sloc) 2.79 KB #post-instagram{ padding: 30px; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ position: relative; min-height: 500px; } .instagram img { width: 100%; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; outline: 1px solid #ddd; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } } Contact GitHub API Training Shop Blog About © 2017 GitHub, Inc. Terms Privacy Security Status Help"},{"title":"","date":"2017-02-14T14:57:54.768Z","updated":"2017-02-14T14:57:54.764Z","comments":true,"path":"photos/ins.js","permalink":"http://yoursite.com/photos/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = 'http://litten.me/ins-min/' + data.link[i] + '.min.jpg'; var src = 'http://litten.me/ins/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += '.jpg'; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './ins.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"},{"title":"tags","date":"2017-02-17T06:02:35.000Z","updated":"2017-02-17T06:04:00.859Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-14T14:58:53.749Z","updated":"2017-02-14T14:58:53.736Z","comments":true,"path":"photos/ins.json","permalink":"http://yoursite.com/photos/ins.json","excerpt":"","text":"{\"list\":[{\"date\":\"2016-12\",\"arr\":{\"year\":2016,\"month\":12,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"BOAF_bbA9H0\",\"BN9ZdHuAqL1\",\"BN30BiDAVGo\",\"BN2CjzagYQK\",\"BNyLQGUgdma\",\"BNwOJYlgAOL\",\"BNtsL5QgEts\",\"BNn5V7oA_nc\"],\"text\":[\"末班车\",\"树影，好似一只黄鹂和蜣螂\",\"街拍 | 晴天\",\"“望”\",\"午睡\",\"“黄昏之时”\",\"枯萎的植物，最后的光\",\"街拍 | 也许是深圳最后的夏日\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2016-11\",\"arr\":{\"year\":2016,\"month\":11,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"BNUaqEagioX\",\"BNTHIbUgigX\",\"BNRr9zBg0fu\",\"BNQHWSwA1Gy\",\"BNPbdVIg6gT\",\"BNOpXsKgU53\",\"BNBrozHAAV7\",\"BM8hsf-grvj\",\"BM8WO8xglvC\",\"BMy1VT3grFk\",\"BMrSxSNgpIN\",\"BMedxcZA0_g\",\"BMQLQvogqn7\"],\"text\":[\"“我是谁我爱谁我要谁我去哪”\",\"天都峰顶转一圈，站的地方巴掌大其实很慌…\",\"下了一夜雨，晚上没睡好，脑子里老想着天都峰关闭的事情。但风云变幻就在一瞬间，冥冥中必有回响，突如其来的晴天太过惊喜。峰顶走起\",\"上年没见着的雾凇突然出现，愿望兑现的感觉\",\"“不看岳”\",\"黄山行\",\"宿舍楼\",\"华科的秋天好像一条安静河流，慢慢扩散，了无声息，异常缓慢，又很具体。反正，时间还有很多，请随意\",\"又回我科，我科这个季节怎么拍都好看\",\"今夜月亮\",\"想过去改变，想过要离开，想过拍拍裤管就去远方。然后又想是不是先做出点事情，后来又突然有了点责任，再后来发现自己可以影响一些人… 它没有扼杀选择，反而让更多条路铺在我面前。所以，生日快乐，18岁。\",\"街拍 | 面对面\",\"一叶知秋\"],\"type\":[\"image\",\"video\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2016-10\",\"arr\":{\"year\":2016,\"month\":10,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"BL_WXdxAM1Y\",\"BL6dTmIgecl\",\"BLv6COag1M6\",\"BLlf8WWgHcJ\",\"BLfzJ7gjj-8\",\"BLbaFJDAJ1i\",\"BLVHTFJgfg-\",\"BLTvxMWgKUn\",\"BLTd_nVAFQi\",\"BLP2UMKAGcn\",\"BLJIJCegCT3\",\"BLDZyq2g7Zr\",\"BLDSZ6pAsAZ\"],\"text\":[\"这年头不做作的民谣已经很少了……\",\"很久没去看那群留守的孩子了。他们还是很容易对每个人卸下心防，情绪会很强烈，所以开心时笑得特别大声，这让我想到悲伤会不会也成正比。不敢想。这世上，不一定所有问题都要去思考去直面，因为时间能帮你们解决很多问题。起码，在一起玩的时间。\",\"深圳雨，台风。小时候问大人，为什么我的风筝飞不起来？他们说要等大风。所以我期待着台风天。等了半年，台风来了，我却只能呆在窗户里往外看，也开始理解这场空欢喜。后来发现台风不单是种天气，还可以是一件事或一个人\",\"鸽子再也看不到无名山的高，你也不再是安和桥下清澈的水\",\"降低了预期，觉得滕王阁还不错。路遇一位玩摄影的大爷，教了许多东西，也听他说了许多往事。其实人得不得意都要尽欢，白不白头都要有那么一点青云之志\",\"东四变成了超市\\n东三变成了清真\\n神剪阁还在\\n绝望坡的小吃多到绝望\\n球场都翻修了\\n计科有钱了(辅导员说的)\\nofo小黄车已占领校园\\n学弟学妹主要玩lol和王者荣耀\\n光谷门对面依旧有鸡蛋灌饼和麻辣烫\\n韵苑食堂还是不怎么好吃\\n沁苑的猫又生了许多娃…\\n\\n来去匆匆，一些照片在：http://120.24.181.238/gallery/\",\"要是一个地方能称作图书馆，不单单是因为图书，还因为它收藏了太多的心事。\\n一语一念，虽不可借阅，愿永不过期。\",\"《深夜食堂》\",\"《返校日》\",\"旧时作\",\"和奶奶在一起。把轮椅推到广场下面玩，突然问我：你们厂生产什么？我：很难说，网络你知道吗… 奶奶：哦，卖绳子的啊\",\"19年前的我，就已经学会了爱恨分明……\",\"回老家，今天正好是“圩日”。村民一家老小，从竹林深处的罗江村出发，走过这条小桥，赶往市集。买到中意的衣服，或者零食，这就是完美的一天\"],\"type\":[\"video\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2016-09\",\"arr\":{\"year\":2016,\"month\":9,\"src\":[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"],\"link\":[\"BK-l0eHgWep\",\"BK3W05HgBqP\",\"BK0nQcSARek\",\"BKx6pvkg5HE\",\"BKfNILQgNAO\",\"BKdn7vEAJJW\",\"BKcdEbPAWzk\",\"BKcCulagAx1\",\"BKazUfGAFlb\",\"BKayutggosw\",\"BKTJUOdgkLm\",\"BKIiijpAvmT\"],\"text\":[\"街拍 | 回望\",\"街拍 | 深拷贝…\",\"街拍 | 拷贝\",\"街拍 | 擦肩而过\",\"苗族妹子上来敬酒。以为只是普通米酒，一饮而尽，后来才跟我说有70度。那还怎样办？不走了。\",\"满城星星点点的灯火，当作你心心念念的生日蜡烛吧。生日快乐，永远单纯。\",\"以大为美的苗族银饰，近看却有许多复杂的细节\",\"迷了路找不见甲秀楼位置。干脆坐下来吃一碗哨脆面，听到对面歌舞升平，寻路过去果然找到了。道理就是，有地标的地方就有广场，有广场的地方就有广场舞。感谢大妈，感谢广场舞。\",\"眼中仿佛藏了一个宇宙\",\"曾经想仗剑走天涯\",\"…\",\"hello，好久不见\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2015-12\",\"arr\":{\"year\":2015,\"month\":12,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/12317949_812027942276002_800384968_n.jpg\"],\"link\":[\"-wSMLcI7sl\"],\"text\":[\"秦教练教学得很好，三小时已可征服中级场。滑雪真是项迷人的活动，还没回去就约好了下次再来\"],\"type\":[\"video\"]}},{\"date\":\"2015-11\",\"arr\":{\"year\":2015,\"month\":11,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/s640x640/sh0.08/e35/12269862_894338194013437_1805169379_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpf1/t51.2885-15/s640x640/sh0.08/e35/12276891_172191463131445_911534090_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/s640x640/sh0.08/e35/12237527_913338585386151_2037194016_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11934646_1088170014540783_209449183_n.jpg\"],\"link\":[\"-tqoLXo7v-\",\"-qKfKxo7nw\",\"-nE5BQo7uP\",\"9qjBpWI7lk\"],\"text\":[\"雪上鸦飞\",\"行走于结了冰的松花江上，遇到一群放生的人。佛经飘扬，鱼虾入河，河面转瞬又恢复了平静。而后在饭店，服务员说我们的鱼，就来自这松花江里。\\n\\n佛的安排奇妙又令人啼笑，鱼让俩群不同的人都收获了快乐？那么我想，鱼就是佛\",\"月上枝头\",\"在天黑后的日光岩顶呆了很久，一个人看一座岛，孤单也自由。后来遇到一位姑娘，我们一同下山。带着她逛遍整条龙头路找吃的，但她什么也不愿吃，问她，她说，想吃酸辣土豆丝。\\n\\n只有笑着承认，真是意料之外的答案。我出来玩，就是为了吃平时吃不到的东西，她则是觉得家乡的菜最熟悉，在哪都是愿意吃的。\\n\\n好吧，陪你吃。因为，离开武汉这么久，我也挺想念这道菜。\"],\"type\":[\"image\",\"image\",\"image\",\"video\"]}},{\"date\":\"2015-10\",\"arr\":{\"year\":2015,\"month\":10,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/s640x640/sh0.08/e35/12145229_1722399741326075_2063247708_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/s640x640/sh0.08/e35/12080493_892409564169375_1626542651_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/s640x640/sh0.08/e35/11849199_203248513340142_1615092499_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/e15/12132912_162625974083441_1400003063_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/s640x640/sh0.08/e35/12135478_1700175696879683_933151519_n.jpg\"],\"link\":[\"9VYE8YI7sk\",\"9BkX3xo7od\",\"8-Ba4MI7lt\",\"88Neujo7r2\",\"8uKqhDo7vp\"],\"text\":[\"在路上\",\"11点的时候，不想睡，借一只手电，一人夜游古村。这事情很刺激，转角遇到的神像，榕树的垂枝，摇曳的灯笼，自己投射到土楼的巨大影子，莫名的恐惧自心底升起。然而后来又不怕了，却总是想起以前去的思溪源村…with my friends\",\"古城的砖瓦年代久了，就很容易长出猫来\",\"以前吉他老师说，对于一首天空之城，听过与弹过是完全不一样的。弹过后才知道，从开始的吉他2品就一直在递增，仿佛自身也在飞翔，云层渐开，空城显现，情绪是那么容易被调动。然而我的水平只够感动自己，要抓紧时间努力学习了。不说了，玩游戏去了\",\"海上日出\"],\"type\":[\"image\",\"image\",\"image\",\"video\",\"image\"]}},{\"date\":\"2015-9\",\"arr\":{\"year\":2015,\"month\":9,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/s640x640/sh0.08/e35/11875445_885316994870904_706284789_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/s640x640/sh0.08/e35/11352715_138879086461968_2066668148_n.jpg\"],\"link\":[\"8NKC9RI7oZ\",\"8DOh_to7p0\"],\"text\":[\"沙滩总有数不完的沙子，数不完的故事。在这突然想起那本还没看完的《岛上书店》，是时候继续做些什么了\",\"陌上花开\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2015-6\",\"arr\":{\"year\":2015,\"month\":6,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/11429225_720390118073037_768409912_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11420780_1012574008772885_1569805305_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/11252784_879698105429690_2109453469_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11267410_925161560884785_371811288_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/11375982_491190547696110_2013240096_n.jpg\"],\"link\":[\"4T1Lfgo7gX\",\"3-mmN3o7mn\",\"3uts9do7jI\",\"3iK7kwI7j1\",\"3glBKbI7jm\"],\"text\":[\"大雨之后\",\"一脸无辜的王尼玛大哥，从肚腩来看，果然是正品？\",\"感觉迷上风筝了。有次做梦，想到一根根拉伸向上的线，像是在钓空中的鱼。而一个技术娴熟的“渔夫”，收杆时是这么干净利落。\",\"起飞\",\"小萝莉不愿回家，跟奶奶说：“再让我玩会，明天要学钢琴，后天要学跳舞，就来不了这儿玩了。”\"],\"type\":[\"image\",\"image\",\"video\",\"video\",\"image\"]}},{\"date\":\"2015-5\",\"arr\":{\"year\":2015,\"month\":5,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/11252751_1444216632541093_1558227860_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11226595_701075516681953_1354085958_n.jpg\"],\"link\":[\"24-dd6o7uB\",\"2uQeuaI7nv\"],\"text\":[\"风雨欲来\",\"野生海带\"],\"type\":[\"image\",\"video\"]}},{\"date\":\"2015-4\",\"arr\":{\"year\":2015,\"month\":4,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11142212_609961145801361_1913577076_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11049421_1375007652828983_401355534_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/11137852_1649834698581861_1050691792_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11055751_1573536912901494_1683773508_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/11055897_1407191599597961_1763496348_n.jpg\"],\"link\":[\"1IUZByo7vP\",\"1ISKRxo7r8\",\"1GPBzpo7qW\",\"1FtGO3I7kN\",\"1C03iPI7hZ\"],\"text\":[\"要回去啦，再见北流河\",\"灵芝get√\",\"这里的清明是个很重要的节日，子孙们都会回来，跋山涉水，竹排渡江，荒山寻路，凭集体的记忆寻找列祖列宗的宝地，寄哀思，也求福德。一路上可以听他们唠叨旧事，也有超级靠谱的风水科普\",\"为了部落\",\"在清明的山路遇到了天然松香\"],\"type\":[\"video\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2015-3\",\"arr\":{\"year\":2015,\"month\":3,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/11123665_1542600796003839_1576473443_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11008101_1593505510894691_369067449_n.jpg\"],\"link\":[\"04_8fwo7gL\",\"zzfe7Oo7uc\"],\"text\":[\"如果你飞得像月亮这么高，就不会搁浅在树上\",\"喜欢这个季节的天空，你找个草坪一躺，飞机，风筝，鸟儿就都在上边，天气好时还能看到白天的月亮\"],\"type\":[\"image\",\"image\"]}},{\"date\":\"2015-2\",\"arr\":{\"year\":2015,\"month\":2,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10958252_1405701033068537_2023890854_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/10832246_413065338853260_183697882_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10268927_436139166536328_1377561628_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11008343_410508022446936_713236389_n.jpg\"],\"link\":[\"zcWez6I7uo\",\"zRPazvI7ol\",\"zPN2LtI7sT\",\"zKrDWlo7gZ\"],\"text\":[\"很多东西随着慢慢长大，变得不像小时候那样盼望热切，比如巧克力麦当劳薯片雪糕。只有对担子粉的爱永远不变的说…\",\"据说是一年一度考验演技的时候…\",\"锈迹斑斑的香炉\",\"回老家了，小时候跟我打过玻璃珠的小伙伴们呢？你们一个在北京，一个在安徽，一个在澳洲，一个我都不知道了…但你们看到玻璃珠的时候，要想起我来啊\"],\"type\":[\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2015-1\",\"arr\":{\"year\":2015,\"month\":1,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/10932550_620643038062978_1729442807_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/891532_1563899373855738_1180535181_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10005439_338105566394046_854247264_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/10903312_693622147425934_1766884651_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/e15/10914460_1546003772305181_1301162053_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10903277_832760670116494_255352239_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/924083_1539057536347062_2062767438_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10890944_765121966897759_2039585477_n.jpg\"],\"link\":[\"yb8uaCI7tt\",\"yKBopho7mX\",\"yAOcawI7pA\",\"x5U25kI7sN\",\"x1TTZUo7gW\",\"xeGbWuo7if\",\"xXr70fI7iD\",\"xUB4dOI7g1\"],\"text\":[\"草地上遗落的鞋子\",\"有位很久没联系的朋友寄来明信片，说：我很少看到海，正如你没见过几次雪\",\"深夜总是灵感乍现的最佳时期，只是几个设计方案都没法使自己满意。累了打开窗看到天上有个大月亮，只想用图章工具把它干掉。\",\"面朝大海冬暖花开\",\"分享日常不正常生活照一张\",\"其实我想，那些古老的渔民们，每天看着海岸线的日落日出，肯定是有人想过地球是圆的。而“想法”与“证明”之间，却跨越了一整条麦哲伦航道\",\"鱼山鱼海中，只有你，肯安静的趴在65厘米厚的亚克力板子上与我合影，大丑鱼\",\"新年单人旅行走起。其实从九洲港码头开始，珠海并没有给人很惊喜的感觉，包括盛名之下的沿海风光与渔女雕塑。倒是交通不通畅，从轮渡到公交都给我带来了许多麻烦。直到，晚上吃烤生蚝的第一口，我又觉得什么事情都是可以原谅的……\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-12\",\"arr\":{\"year\":2014,\"month\":12,\"src\":[\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10899183_999582293404177_745539859_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10894909_702627706517406_1277557620_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/10831989_483313928477468_40906631_n.jpg\"],\"link\":[\"xRWN47I7pW\",\"xO3qREI7iW\",\"wEQykeo7tU\"],\"text\":[\"2014年最后的阳光\",\"最后一节吉他课结束后，马路上那风一直吹，才感觉南方的冬天终于是来了。其实吉他在冬天会有许多神奇的事情。比如琴弦如肌肉一样因冷而紧绷，发出比以往沉闷的低语；而空旷的大教室里，如有其他同伴拨响和弦，手中本已按灭的琴弦又会因共鸣微微颤动。像有生命一样。\",\"有棵丑树，我经常去看，又胖又歪，秃得可笑。在变冷的一天，它突然就开花了。冬天的花我知道得很少，南方没有梅花，那就是异木棉了\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2014-11\",\"arr\":{\"year\":2014,\"month\":11,\"src\":[\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10784965_1518537748403855_176956695_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10735195_1505939246340704_1984926778_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10747711_429336373885590_422028037_n.jpg\"],\"link\":[\"vP2ywuo7pq\",\"vA68BLo7tN\",\"u7zEVxo7vw\"],\"text\":[\"通灵之术！\",\"现场气氛果然不一样，马上就可以看到小伞在大哥胯下疯狂输出…是时候来首选一记薇恩了\",\"有朋友跟我说，挪威的森林根本看不下去；又有朋友说，看这书一发不可收拾。差别好大呀！我倒觉得有个简单的方法：翻到开篇的这几个字，如果心中一紧，那就说明这本书适合你，否则请弃之\"],\"type\":[\"image\",\"image\",\"image\"]}},{\"date\":\"2014-10\",\"arr\":{\"year\":2014,\"month\":10,\"src\":[\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10735112_730529873702428_413107753_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10725177_573652486072155_1401604216_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfp1/t51.2885-15/e15/10724868_302191016652312_2097904817_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/10731727_461314204008708_386749273_n.jpg\"],\"link\":[\"uu70zJo7qb\",\"uQnvluo7sK\",\"uLi56Wo7oO\",\"uEv-tCo7rJ\"],\"text\":[\"天下的小饼干遇到我，貌似就只有一种下场！！\",\"一个人，一支口琴，一片海，一瓶酒\",\"《论夜归，打的，以及发票的正确用法》\",\"童年真好。我以后一定不要跟孩子说：希望你快高长大这种傻话…\"],\"type\":[\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-9\",\"arr\":{\"year\":2014,\"month\":9,\"src\":[\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10616983_1382591478697855_2107473552_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/925287_1464119273867077_427071626_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/925284_1534308033454310_855505111_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfp1/t51.2885-15/e15/10666267_1550871771803214_2074300649_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693244_734401199942901_1572709880_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693771_1517437541834868_665867908_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693822_497709657032441_1125408654_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10683941_796597910390683_12441123_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10661142_164227523747936_1526737465_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10661182_550889531706942_2043749716_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10520334_1523531751215211_1344090061_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693390_547748238660649_761529890_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10693650_837768039589771_1793184733_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/914812_1529561143923493_1662159287_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfp1/t51.2885-15/e15/10644019_368509079979549_2085033896_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xta1/t51.2885-15/e15/10684161_918887498139099_2081383304_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10683828_327931784041264_894089329_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10666028_872988212713750_1345360858_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpf1/t51.2885-15/e15/10665501_1452353738387652_2075798065_n.jpg\"],\"link\":[\"tXuIHso7qK\",\"tJjQlAo7kH\",\"tDYyUeo7oX\",\"tCBULHo7sW\",\"tB_Xmao7qG\",\"s8cKzLI7pM\",\"s6-lOFo7ip\",\"s5GifkI7q7\",\"s3uZcmo7uj\",\"s2bb5io7p-\",\"s2P72tI7o6\",\"s2FPpGI7o_\",\"s1LPQPo7v8\",\"szZP5Io7lY\",\"sr9rtNo7lM\",\"sr7gXKI7h_\",\"srG7fjo7sV\",\"spAnrio7oh\",\"sj4BGgI7t_\"],\"text\":[\"我的好朋友——超级高冷超级磨人的丝瓜\",\"沉眠的店主失眠的狗。想起大学的最后时光，宿舍24小时都有人醒着，自由的人生，自由的酒和曲终人散，大家通常没有另一半，没有钱，没有忧愁，爽成狗\",\"如果他是程序员…\\nvar date = lifetime;\\rif(rotate(mountain, water, stupa)){ /*return nextLifetime;*/ return meetyou(journey);\\r}\",\"听着山寨的民谣电子乐，看着美好的姑娘。功德无量。\",\"弥里塘太宁静。在这我一直想起每一个被深圳车水马龙声吵醒的早晨，真是光辉的岁月\",\"进藏。天空挂满着云，黑的白的都有。云朵转眼飘散，它却依然是蓝色。\",\"“音浪太强不晃会被撞到地上…”\",\"陌生的朋友，愿下次再能与你们相聚在丽江love wine & half。我无法融解你悲观现实的想法，你也无法说服我旅行并不是逃避。但这都很有意思。只是想起以前有个人叫我不能喝太多的酒，一想到这个呀我就越喝越多\",\"玉龙雪山\",\"以前想去丽江，但去过的人都灌输着你也许会失望的观念，因而甚至不敢动身。这是一种“怕”。有时候真得自己去看看才会了然。第一天在丽江，民谣吉他缓缓流过商业化的街道，原来没有惊喜，也没有失望，一切刚刚好。\",\"我注定要回到老路上\",\"彩云之南\",\"云南，向往已久的地方\",\"QQ同时在线人数破2亿纪念，作为一颗小小螺丝钉，名字正好镶到企鹅的大嘴巴上。这时觉得有一丝光荣，一种努力被实化的错觉；然后又有点不舒服，感觉此时的自己，和名字身边的人一样。可我想要的就是不一样。\",\"陪伴一定得是件漫长的事呵。和奶奶在一起的中秋节。\",\"中秋和家人一起去看孔明灯，热闹而安逸，这是小城市的美好。\",\"老家的葡萄藤，从我初中时就挂在这，再见已是十一年\",\"家里橄榄熟了，盐渍，暴晒，蘸蜜，简直人间美味!\",\"在一场太阳雨里回到家中\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"video\",\"image\",\"video\",\"image\",\"video\",\"image\",\"image\",\"image\",\"image\",\"video\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-8\",\"arr\":{\"year\":2014,\"month\":8,\"src\":[\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10654876_610857929023752_364709543_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10644013_777642448965989_544517718_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/924456_1471485796442896_1699836323_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/10607913_692632367472666_1829853902_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/10611052_1466241683635233_830264506_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10617144_829548960388746_1611410337_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/10453953_542161702576881_1621059386_n.jpg\"],\"link\":[\"sXa9g6I7jB\",\"sPt4u4I7kA\",\"sC18G0o7qb\",\"sAMmEWI7oC\",\"rzSow4o7lH\",\"ro28LPI7oc\",\"rR37wLo7iu\"],\"text\":[\"在书店的晚上终于把新专反复听完。太柔了…打一星两星的人肯定是真爱粉，这点有人敢怀疑？我不是，打四星！停不下来，直到书店响起:深圳即将入眠。但22点还是深圳的早晨呀\",\"慢三的华尔兹，大篇幅的爵士即兴。感觉生活得太浮躁。也太安逸。\",\"好久没看话剧，这部果然没让人失望。导演太会讲故事了，1024个赞\",\"纵有一万种悲伤的美丽，也比不过这段。\",\"在书城里看到的《后会无期》分镜图。电影那么美，分镜是这样，这就是现实~\",\"如果你从北京来看我，我会很感动;如果你像光，从太阳那头过来，我不以为然。因为光到地球只要8.3分钟。我们经常错用代价来衡量情感\",\"相聚总有时:)\"],\"type\":[\"image\",\"video\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-7\",\"arr\":{\"year\":2014,\"month\":7,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/925559_1482425071996009_1940959046_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10554006_501929086608023_917623457_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10576105_624878090953161_638111947_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpf1/t51.2885-15/e15/10570119_332808380211109_125412512_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/926536_828142997203682_1319760676_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/923702_252705761596555_721784545_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10549755_708603639175850_2095584541_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/928307_1442957109299429_297849354_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10488451_303926969784787_1278259348_n.jpg\"],\"link\":[\"q5e2KpI7qn\",\"qyXXpNI7q5\",\"qxfUe0I7lp\",\"qq9usdo7hr\",\"qn4WCIo7hi\",\"ql0brho7vN\",\"qkiaYDo7t9\",\"qURC9fI7r-\",\"p4A8IuI7py\"],\"text\":[\"随便走走，发现世界还是很美好的。当拥有美好事物时，经常习惯性的熟视无睹;当努力抓住你想要的东西时，它又可能瞬间破碎。但依旧需要不妥协。\",\"荔枝——我心目中的水果之王（有之一）\",\"高中时代最新款的mp4，现已成了老古董\",\"台风来临时，刚好会是暑假。但我已没有暑假。\",\"看着一场雨由远及近的淋湿院子，太漂亮\",\"归来却空空的行囊 那故乡的云 那故乡的风 啦啦啦啦啦 啦啦啦。\",\"在今年第一个狂风大作的早上，回家去\",\"98年，世界杯第一次在我脑中留下记忆，和爸，围着那台很小的tcl。今天，爸还打电话给我，让我别看太晚影响到明天工作，但我知道他自己也会去看的。是的，我们爱足球，今生今世\",\"这几天深圳的天空很美，无论晴雨\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-6\",\"arr\":{\"year\":2014,\"month\":6,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10362316_1434933843444633_1187384207_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/10471930_507725875994902_393186392_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/10454011_484872768311603_738380027_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/923661_248502122024084_2086692261_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/10424605_774238262594769_78480252_n.jpg\"],\"link\":[\"p06uEZI7tG\",\"pytFNpo7sD\",\"poMFteI7q0\",\"pMt5tgI7vj\",\"o3eroFo7gK\"],\"text\":[\"“往事依稀浑似梦，都随风雨到心头”——梅表姐\",\"navy blue\",\"今天我遇到一朵枯玫瑰。她只是枯萎，从未凋零。\",\"上届卫冕冠军被打成筛子的…是热火…\",\"我和大神的差距——web工程师的自我修养\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-5\",\"arr\":{\"year\":2014,\"month\":5,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xat1/t51.2885-15/e15/10387796_255697041300477_753213015_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10005623_779769878723970_627922376_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpf1/t51.2885-15/e15/10358172_1495900567292387_640174442_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xta1/t51.2885-15/e15/10369281_674379822637848_233362820_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/928251_430572373746575_786910314_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10358301_256481271142988_1088114034_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/10296597_1413560715589179_392570057_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/10299642_561366610636165_721929935_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/10268965_1446530205590326_114108738_n.jpg\"],\"link\":[\"op03boo7lW\",\"ops-ZUI7t-\",\"ofqhBpI7mQ\",\"odP0cno7ue\",\"oLX-4GI7ne\",\"oBl6WtI7qC\",\"nvPChzI7vU\",\"ngAyz8o7qj\",\"ndTggdI7jn\"],\"text\":[\"突然发现我还是挺喜欢大晴天的\",\"单人旅行走起！开心\",\"不久就可以吃了\",\"黄昏时分\",\"大雨倾城\",\"今天路过公园，一朵玉兰掉在身边。想起小时候陪伴我的三棵树，两棵木棉，一棵玉兰。当然玉兰这名字是后来才知道的，记忆里的那朵永远叫做香花。三年级的某天放学，这三棵树一并倒下了。\",\"雨中深大。雨季再来不再来。\",\"say hey to may\",\"故事中的小黄花\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-4\",\"arr\":{\"year\":2014,\"month\":4,\"src\":[\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10261258_711820055527911_220271949_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpt1/t51.2885-15/e15/10249356_695726313802446_881680057_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10268929_597082527053970_1060360934_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/10268941_490697914386538_1148834228_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/10254195_545488182236276_1930978882_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtp1/t51.2885-15/e15/917572_539124756205696_1549712749_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/927273_657564254280429_578859844_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10175316_650834874981595_1358429831_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/926422_245144379006241_1254093305_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xaf1/t51.2885-15/e15/891289_302574849898688_205313988_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-frc/t51.2885-15/e15/10175309_510867459023322_1700312549_n.jpg\"],\"link\":[\"nOGNjUI7op\",\"nGJfYAo7lW\",\"nATIxlI7tR\",\"mxsNwto7pQ\",\"mm7JTUI7p0\",\"mhER0lo7oe\",\"mfvVUYI7hu\",\"mdF-nNo7pE\",\"mcVLQzo7nl\",\"mb5cFho7sd\",\"maqYInI7if\"],\"text\":[\"谢谢亲们的蛋糕和礼物;谢谢我们始终用“同学”来称呼彼此。\",\"处女座老榕树\",\"放风筝的人们\",\"现在我的状态，像极了一只被推上战场僵尸\",\"这几天我耳边是都是这样的话语:1、“就是敲敲键盘，挺清闲的哈！”2、“别太挑剔，给个一两千就先做着”3、“什么？你那一碗粉要十二块钱？！”我回深圳了，几天的清静生活，谢谢乡亲们的招待。\",\"good luck\",\"瓦上花开\",\"好吧，这是一艘船\",\"石表山，思罗河，四年后的清明我又来到了这儿\",\"清明，一路向西\",\"清明一回到家，老妈就开始炫耀她试验种的豆芽。愿君多采撷，此物最好吃？\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-3\",\"arr\":{\"year\":2014,\"month\":3,\"src\":[\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/10012487_604746702952671_676907736_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/1171265_389602547845527_1588547561_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11376491_1614984048759908_413209146_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/11251074_365441270314698_1015057085_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xft1/t51.2885-15/e15/11380079_1581430378786145_504181803_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xtf1/t51.2885-15/e15/11330604_837683999618217_506172540_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/11273047_110162449318540_1639646034_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xap1/t51.2885-15/e15/11375356_908792249164254_112740693_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xfa1/t51.2885-15/e15/11357539_388432694679963_1281450994_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-xpa1/t51.2885-15/e15/11311124_1611430865770700_1482115931_n.jpg\"],\"link\":[\"mIgOdio7jT\",\"mIAS5lo7hb\",\"lrhVmio7lF\",\"lmADv6I7rU\",\"lhPFVeI7g6\",\"lcyrKSI7h_\",\"lSda6Ko7nG\",\"lSSxd8I7kB\",\"lK0xswI7s6\",\"lA4KaBI7go\"],\"text\":[\"转角遇到戏台，耳熟却不知道是哪一出了。想起爷爷以前的二胡与杨琴，自己精削细磨的琴竹，还有他组织的“菊山楼”粤剧队，真是一晃好些年。今年清明，一定回去。\",\"这本书超赞！好书好书好书\",\"四五点写程序太累，就不写了。不告诉任何人，跑到这个立交桥底，我已来过好几回。这里有一棵白色的紫荆花，满墙爬山虎，和刚放学的小朋友，出去，右拐，再右拐，转角可以遇到你，我的肉夹馍…\",\"越来越认生了，到步行街买衣服，找到比较适合的，却因为店员太过热情…跑了出来。闹市中居然藏有一古庙，还是这里自在，漫天神佛只是笑笑，不理物我，无论喜悲。对了我来这干嘛\",\"爬山的好处:强身健体，磨砺意志，开阔胸怀…坏处是:没有wifi。\",\"又见回南天\",\"老妈说，今天要我送个礼物！离家万里，只好迅速开发出这个app，摇后就会播放我唱的真的爱你。可惜她说摇后没反应，后来才知道，她拿的ipad在摇…但我是真的爱你\",\"今天下雨，的士司机都不肯理我。头上路灯光芒遥不可及，脚下路面棱角冰冷鲜明\",\"起风吧，明天。喜欢偏冷的日子，假如是春天，假如是风大，太完美了\",\"腾讯的凌晨四点半。第一次在此过夜，听着耳熟不能详的歌，看着平静不微笑的人。然后记起，家里打来被我按掉的电话，忘了回\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"]}},{\"date\":\"2014-2\",\"arr\":{\"year\":2014,\"month\":2,\"src\":[\"https://scontent.cdninstagram.com/hphotos-ash/t51.2885-15/e15/1737225_591794970889160_1849235580_n.jpg\",\"https://scontent.cdninstagram.com/hphotos-prn/t51.2885-15/e15/1741200_451260698337036_577792061_n.jpg\"],\"link\":[\"kv3jNgI7sw\",\"kr8sW8I7nR\"],\"text\":[\"“不能吃太胖喔，会被杀掉的！”\",\"今晚，已经看到两个小女生在问，这里有《九云梦》吗？\"],\"type\":[\"image\",\"image\"]}}]}"},{"title":"简介","slug":"photos","date":"2017-02-14T14:56:11.828Z","updated":"2017-02-14T14:56:11.820Z","comments":false,"path":"photos/index.html","permalink":"http://yoursite.com/photos/index.html","excerpt":"","text":"Ins 摄影 图片来自instagram，正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })() Contact GitHub API Training Shop Blog About © 2017 GitHub, Inc. Terms Privacy Security Status Help"},{"title":"个人简介","date":"2017-02-24T16:16:39.000Z","updated":"2017-02-24T16:24:49.666Z","comments":true,"path":"introduction/index.html","permalink":"http://yoursite.com/introduction/index.html","excerpt":"","text":"教育背景2010-2014 北京化工大学 本科 视觉传达专业 工作经验 2013/11—2014/7 北京盛林兰广告公司 平面设计 客户之间的沟通和公司内部市场部之间的协调和沟通 宣传册、书籍封面、banner设计 负责北京塞纳印象客户项目 2014/8–2015/9 北京亚控科技发展有限公司 前端开发 根据公司项目需求和UI设计师的设计图，运用div+css、html将设计图快速生成页面，并进行交互 解决浏览器兼容等问题 协助美工美化图片 2015/10–2017/1 北京亿莎商业管理有限公司 web前端开发 根据UI设计图及需求说明书进行网页开发，与开发人员确认后台接口及数据格式，配合后台开发人员进行测试，实现商品详情功能模块，完成用户中心，个人订单，相关维护工作。 专业技能1、熟悉W3C标准与ES规范，对J面向对象有一定理解。 2、HTML，CSS，JavaScript基础扎实，掌握JS面向对象开发原理和闭包原理。 3、熟练掌握常用主流Web前端框架，如Bootstrap，jQuery，AngularJS等。 4、熟悉CSS3和HTML5的新特性，并且能够实现CSS3动画（2D、过渡等）。 5、能熟练高效手工编写HTML及CSS、JS代码，熟悉DIV+CSS布局。 6、对前端模块化开发有一定了解。 自我评价为人诚恳,积极进取,适应力强、勤奋好学、脚踏实地，有较强的团队精神,工作积极进取,态度认真，做事情始终坚持有始有终，从不半途而废；有问题不逃避,愿意虚心向他人学习；会用100%的热情和精力投入到工作中。 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"}],"posts":[{"title":"函数声明提升","slug":"title9","date":"2017-02-17T10:15:38.691Z","updated":"2017-02-20T12:47:26.688Z","comments":true,"path":"2017/02/17/title9/","link":"","permalink":"http://yoursite.com/2017/02/17/title9/","excerpt":"","text":"1、函数声明提升变量可以先使用后定义。js的解析器在运行的时候，会将所有的全局变量提升到最开始的位置，如果使用的时候可以找到这个变量定义。变量声明提升只提升定义，不提升赋值。初始值默认是undefined。 1 var a; 2 console.log(a); 3 a = 12; 函数声明提升：函数可以先调用，后定义。解析器在程序最开始，将全局范围内定义的函数声明提升到代码最前面，声明的时候提升的就是那个变量名指针，总能够根据函数名找到这个函数的圆型。 1 //先调用 2 fun(); 3 //后定义 4 function fun(){ 5 console.log(1); 6 } 函数声明头提升是强制性的：无视if语句以及for循环。 函数的另外一种定义方式：函数表达式的定义，不会进行函数声明提升，它进行的是变量的声明提升。变量声明提升只提升定义 ，不提升函数赋值，里面存的undefined，给调用函数方法，出现引用类型错误。 1 fun1(); 2 var fun1 = function(){ 3 console.log(2); 4 } 对比：同一个变量名给函数和变量，看顺序。变量写在后面，覆盖掉前面的函数名。 1 function fun(){ 2 console.log(1); 3 } 4 var fun = function(){ 5 console.log(2); 6 } 7 fun(); 函数声明优先于变量声明：同一个标识符，给变量和函数，在定义提升的时候，会将这个标识符优先给函数使用。 1 //先调用 2 3 fun(); 4 //后定义 5 function fun(){ 6 console.log(1); 7 } 8 var fun = function(){ 9 console.log(2); 10 } 11 fun(); 特殊情况解释：函数在定义的时候，进行强制性的声明提升，定义过程已经被提升到代码最前面了，后面再遇到定义的代码，直接忽视。后面定义的变量会遮盖掉这个定义。 1 var fun = function(){ 2 console.log(2); 3 } 4 function fun(){ 5 console.log(1); 6 } 7 fun(); 注意：尽量不要用同一个标识符给变量和函数，定义函数时不要使用函数表达式的方式，用函数关键字的方式。 2、作用域2.1 概述 在函数内定义的变量不能从函数之外的任何地方取得，变量仅仅在该函数的内部有定义。因为我们的函数关住了变量的作用域（定义域）。 JS的作用域：没有块级作用域{}，唯一关住作用域的结构就是函数。在函数内部定义的变量就是函数内部的局部变量，只能在函数内部调用，在外部调用会出现错误。 1 //函数关住作用域，内部定义的是局部变量 2 function fun(){ 3 var a = 1; 4 console.log(a); 5 } 6 fun(); 7 console.log(a); 全局变量：从广义上讲，是一个最外层的局部变量，作用域是全局，所以叫做全局变量。可以在全局范围内都访问到这个变量。 1 var b = 2; 2 function fun(){ 3 var a = 1; 4 console.log(a); 5 console.log(b); 6 } 7 fun(); 原理：全局变量语句没有任何限制，只要遇到就会生成一个变量，在任何地方是能找到。局部变量是声明在函数内部的，函数定义时，内部语句并没有执行，没有定义成这个变量，在函数执行的瞬间，立即定义了一个局部变量，执行完之后，这个变量被立即销毁，从外部找不到这个变量的定义，不能调用。 2.2作用域链 函数内部在调用一个变量的时候，查找的路径问题：当遇见一个变量时，JS引擎会从其所在的作用域依次向外层查找，查找会在找到第一个匹配的标识符的时候停止。在多层嵌套的作用域中可以定义同名的标识符，发生“遮蔽效应”。 1 var a = 1; 2 function outer(){ 3 var a = 2; 4 function inner(){ 5 //var a = 3; 6 console.log(a); 7 } 8 inner(); 9 } 10 outer(); 如果函数内部定义变量时，没有写var关键字，认为我们自动在全局进行了变量的声明，我们创建的不在是局部变量，而是全局变量。会造成一个全局污染。 1 var a = 1; 2 function outer(){ 3 a = 2; 4 function inner(){ 5 //var a = 3; 6 console.log(a); 7 } 8 inner(); 9 } 10 outer(); 11 console.log(a); 在全局定义变量，忘了写var关键字，只要有赋值，变量会自动在全局进行声明。 1 b = 3; 2 console.log(b); 建议：任何时候定义变量都要写var关键字，避免全局污染。 2.3 函数的参数 函数的参数是一个局部变量。在函数内部可以正常使用。在函数外部不能访问函数参数这个变量。 1 function fun(a,b){ 2 a = 1; 3 b = 4; 4 console.log(a + b); 5 } 6 fun(); 7 console.log(a); 实际工作中如果能封装函数，用到的变量，尽量定义在函数内部，不会影响其他的函数或者全局变量。 2.4 全局变量 全局变量尽量少定义，但是它有自己独特的作用：传递、累加。 程序：有两个函数，执行函数加，给我们的一个变量加1，如果执行函数减，让我们的这个变量减1.两个函数控制同一个变量。 传递：在不同的函数之间进行通信，函数都能使用，必须使用全局变量。 1 //全局变量，可以让任何函数使用，通信 2 var a = 1; 3 function plus(){ 4 a++; 5 return a; 6 } 7 function minus(){ 8 a--; 9 return a; 10 } 11 console.log(plus()); 12 console.log(plus()); 13 console.log(plus()); 14 console.log(plus()); 15 console.log(minus()); 16 console.log(minus()); 17 console.log(minus()); 如果一个函数需要累加一个变量的值，多次执行，值依次累加的。不能使用局部变量，因为每次初始值都会被重置。 累加：全局变量会将变化的值存起来，以备下次使用。 1 //全局变量。，累加功能 2 var a = 1; 3 function sum(){ 4 a++; 5 return a; 6 } 7 console.log(sum()); 8 console.log(sum()); 9 console.log(sum()); 10 console.log(sum()); 2.5 函数的作用域 函数也有作用域，就是它定义的那个环境，如果定义在另一个函数内，它也只能在这个函数内部调用，在函数外面调用时引用错误。 1 function sum(a){ 2 return ++a; 3 } 4 //函数定义在另一个函数内部，在外面是访问不到 5 function outer(){ 6 var a = 1; 7 function inner(){ 8 console.log(sum(a)); 9 } 10 inner(); 11 } 12 outer(); 13 inner(); 3、闭包观察闭包的经典案例： 1 //函数定义在另一个函数内部，在外面是访问不到 2 function outer(){ 3 var a = 1; 4 function inner(){ //只能在定义域内使用 5 console.log(a); 6 } 7 return inner; //返回值得到一个inner函数的定义 8 } 9 // 将函数执行结果赋值给一个变量 10 var fun = outer();//其实将inner函数赋值给了fun 11 //函数如果执行，需要在定义域范围去找变量a。全局没有，正常输出了一个1 12 //执行fun函数，其实是执行指向的那个函数原型，它会在自己定义的作用域内执行 13 // inner定义时作用域内有一个a = 1，inner函数记住了这个定义域 14 // 哪怕在outer函数外面使用inner的时候，我也可以访问到a的定义 15 // console.log(typeof fun); 16 // console.log(fun); 17 fun(); 每个函数天生就是一个闭包。函数在定义时，会记住自己的作用域环境以及内部的语句，将外部环境和内部语句组成了一个密闭的环境，就是闭包。 闭包不需要特殊的结构，只是会通过特殊结构来观察函数的这一性质。案例观察： 1 function outer(x){ 2 function inner(y){ //如果执行函数outer，才会定义inner 3 console.log(x + y); 4 } 5 return inner; //一定不要加小括号，如果加了，就立即执行 6 } 7 var i = outer(3); //inner函数定义的位置，环境x = 3 8 // x = 3; 9 // i = function inner(y){ 10 // console.log(x + y); 11 // } 12 console.log(i); 13 i(5); 1 function fun1(m,n){ 2 function fun2(m){ 3 console.log(m + n); 4 } 5 return fun2; 6 } 7 var f = fun1(3,4);//fun2定义的位置 8 f(6); 函数这个闭包里的变量并不是一成不变，可以通过函数调用发生一些变化。 1 function outer(){ 2 var i = 9; 3 function inner(){ 4 return i++; 5 } 6 return inner; 7 } 8 var inn = outer(); //新建了一个函数，函数是inner，赋值给了变量inn 9 console.log(inn()); 10 console.log(inn()); 11 console.log(inn()); 函数定义一次，可以进行多次调用。我们可以认为，每次重新定义，都会产生新的闭包。新的闭包指的是，语句全新，所处环境也是全新的。 1 function outer(){ 2 var i = 9; 3 function inner(){ 4 return i++; 5 } 6 return inner; 7 } 8 var inn = outer(); //新建了一个函数，函数是inner，赋值给了变量inn 9 var inn2 = outer(); //新建了一个函数，函数是inner，赋值给了变量inn2 10 console.log(inn()); 11 console.log(inn()); 12 console.log(inn()); 13 console.log(inn2()); //新的函数，闭包是全新的","categories":[{"name":"函数","slug":"函数","permalink":"http://yoursite.com/categories/函数/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Cookie和Session","slug":"title44","date":"2016-12-13T09:27:56.000Z","updated":"2017-02-20T13:02:24.023Z","comments":true,"path":"2016/12/13/title44/","link":"","permalink":"http://yoursite.com/2016/12/13/title44/","excerpt":"","text":"1、Cookie就是一个Response头部的一个K-V对儿。 当服务器下发了一个Set-Cookie，今后每次request浏览器都会带着相同的cookie上去。 HTTP是无连接的，当你第一次访问一个服务器的时候，第二次再来到这个服务器（可能就10s之后），服务器此时的HTTP和第一次毫无关系的。对于服务器来说，HTTP是两次，两次之间没有持久保持连续。 setcookie函数就是设置cookie的，有三个参数：k、v、过期时间 &lt;?php setcookie(&quot;xingming&quot;,&quot;kaola&quot;,time()+3600); ?&gt; 第一次访问页面的时候，我们关心的是Response Headers： 里面有一个Set-Cookie，值为 xingming=kaola; expires=Fri, 27-Jan-2017 12:38:36 GMT 表示Cookie的值，和过期时间。 今后的每一次访问同一个域名下的任何网站，都可以看见Request Header中携带了相同的Cookie： 有什么用！可以方便让： ① 浏览器记录服务器曾经给我们的信息； ② 服务器记录用户提供的信息 在本地，我们可以轻松使用document.cookie来使用cookie。 此时你会得到一个String，任何的cookie会被链接成为一个String： console.log(document.cookie); 转码： var c = decodeURIComponent(document.cookie); 此时仍然是字符串 变为数组，用;来拆分： var arr = c.split(&quot;;&quot;); 遍历这个数组，继续用=来拆分为数组： var result = {}; for(var i = 0 ; i &lt; arr.length ; i++){ var t_arr = arr[i].split(&quot;=&quot;); console.log(t_arr); } 变为对象： for(var i = 0 ; i &lt; arr.length ; i++){ var t_arr = arr[i].split(&quot;=&quot;); result[trim(t_arr[0])] = t_arr[1]; } console.log(result); 他的值不是object，所以eval： var infoobj = eval(&quot;(&quot; + result[&quot;iqianduan.cn&quot;] + &quot;)&quot;); 自动填入表单 //如果xingming和nianling不是空，则默认填入文本框 if(infoobj.xingming){ document.getElementById(&quot;xingmingTxt&quot;).value = infoobj.xingming; } if(infoobj.nianling){ document.getElementById(&quot;nianlingTxt&quot;).value = infoobj.nianling; } 总结一下： **&gt; cookie的产生仰赖服务器的一次Set-Cookie。今后每一次的访问，我们的request头部都会携带cookie这个东西。 其实如果不借助服务器，我们浏览器自己能不能发送带有cookie的头部呢，能！就是xhr.setRequestHeader()，不过这个东西没有意义！** Cookie的性质 ① Cookie不安全，可以在任何时候被浏览器的network面板被查看。所以千万不要试图让服务器下发密码等机密信息。可以被自由修改！ ② Cookie是文件格式存储。 ③ 有超时的限制，可以自由设置存活时间。 2、Session有cookie，让服务器发起Set-Cookie: username=且试天下Always;login=true; 此时我们的浏览器今后访问每一个这个网站的页面都会带着cookie上去。服务器识别cookie，一看就知道你登录了！ 但是，cookie可以被自由篡改！也就是说，我想登陆谁的号，就登录了谁的号！ 有人发明了一个机制，不要通过cookie下发明文信息，发送一个随机乱码下去！服务器同时在内存中保存这个随机数字的人的各种信息。如果有人带这个随机乱码上来，一定是这个人！ 此时我们把这种特别的cookie叫做SESSION，也叫作会话。也就是说，session就是cookie！是一种特殊的cookie，是不发送明文，而是发送随机乱码的cookie。 服务器下发： &lt;?php //开始session session_start(); $_SESSION[&quot;xingming&quot;] = &quot;小丹尼&quot;; ?&gt; 今后我的每一次访问，都会带着这个码上去。这个吗对于浏览器来说，没有任何意义！但是服务器就是通过这个码来知道你是你的。","categories":[{"name":"Cookie和Session","slug":"Cookie和Session","permalink":"http://yoursite.com/categories/Cookie和Session/"}],"tags":[{"name":"Cookie\\Session","slug":"Cookie-Session","permalink":"http://yoursite.com/tags/Cookie-Session/"}]},{"title":"PHP实现分页以及Hash","slug":"title43","date":"2016-12-12T09:27:56.000Z","updated":"2017-02-20T12:52:15.632Z","comments":true,"path":"2016/12/12/title43/","link":"","permalink":"http://yoursite.com/2016/12/12/title43/","excerpt":"","text":"##1、PHP实现分页 ##SQL里面的数据非常多的时候，我们不可能一次性查询全部，这样你前台页面无法显示那么多条目。此时可以用LIMIT子句来控制条目跳过多少条，并且读取多少条。 比如： SELECT * FROM banji0910 LIMIT 25,5; 表示跳过25条读取25条。我们就是利用这个SQL语句，制作分页的。 此时PHP工程师会暴露两个参数在GET请求中，page当前页码，pagesize每页条目数： &lt;?php mysql_connect(&quot;localhost&quot;,&quot;root&quot;,123456); mysql_select_db(&quot;student&quot;); mysql_query(&quot;SET NAMES UTF8&quot;); $page = $_GET[&quot;page&quot;]; //从1开始 $pagesize = $_GET[&quot;pagesize&quot;]; $skip = $pagesize * ($page - 1); $sql = &quot;SELECT * FROM banji0910 ORDER BY id LIMIT {$skip},{$pagesize}&quot;; $result = mysql_query($sql); ?&gt; 根据这个思路，就可以制作PHP版本的页码条： 简单说一下： //得到条目总数，所以就要发出一次SQL查询 $sql2 = mysql_query(&quot;SELECT count(*) FROM banji0910&quot;); $r = mysql_fetch_array($sql2); $count = $r[0]; &lt;div class=&quot;nav&quot;&gt; &lt;ul&gt; &lt;?php //总页数 $pageAmount = ceil($count / $pagesize); for($i = 1 ; $i &lt;= $pageAmount ; $i++){ ?&gt; &lt;li&gt;&lt;a href=&quot;&lt;?php echo &quot;01_PHP_FENYE.php?page={$i}&amp;pagesize={$pagesize}&quot; ?&gt;&quot;&gt;&lt;?php echo $i;?&gt;&lt;/a&gt;&lt;/li&gt; &lt;?php } ?&gt; &lt;/ul&gt; &lt;/div&gt; PHP分页的好处是： 便于分享网址，因为URL改变了。 PHP分页的缺点是： 页面刷新了并且页面全局刷新了。当你页面其他部分有很多东西的时候，此时非常恐怖，页面的其他的部分陪葬了，重新都刷了一遍。 现在越来越流行Ajax分页，先说优点就是Ajax不会全局刷新整个页面；缺点就是不便于分享网址。 2、分页条组件的开发Ajax分页最难的东西就是分页条组件的开发： `&lt;script type=&quot;text/javascript&quot;&gt;` //分页条组件 function PageNav(params){ //自己的盒子 this.$box = $(&quot;#&quot; + params.boxid); //试着创建DOM $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;cBtn&quot;).html(&quot;上一页&quot;).appendTo(this.$box); $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;nBtn&quot;).html(1).appendTo(this.$box); $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;nBtn&quot;).html(2).appendTo(this.$box); $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;nBtn&quot;).html(3).appendTo(this.$box); $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;nBtn&quot;).html(4).appendTo(this.$box); $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;ellipsis&quot;).html(&quot;...&quot;).appendTo(this.$box); $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;nBtn&quot;).html(999).appendTo(this.$box); $(&quot;&lt;a&gt;&lt;/a&gt;&quot;).addClass(&quot;cBtn&quot;).html(&quot;下一页&quot;).appendTo(this.$box); this.$box.find(&quot;.nBtn&quot;).eq(3).addClass(&quot;cur&quot;); } var pn = new PageNav({ &quot;boxid&quot; : &quot;pn&quot; }); &lt;/script&gt; 事件委托，就是给li添加监听，不如给ul添加，用event.target来判断是谁。 函数委托的事情，就是当一个函数要运行的时候，此时不要直接些业务，把具体的业务委托给另一个函数。 在new的时候，要定义一个函数，当页码改变的时候触发： var pn = new PageNav({ &quot;boxid&quot; : &quot;pn&quot;, //函数委托 &quot;change&quot; : function(index){ alert(&quot;页码到了&quot; + index + &quot;页&quot;); } }); 我们使用翻页的条的时候，new翻页条的时候需要一个总页数。但是总页数往往是在Ajax返回的JSON中： 此时就要先发出Ajax请求，然后new出翻页条。此时为了防止每次点击翻页条都重新new，一定要判断： //请求页面 function getStudent(pageNumber){ $.get(&quot;php/student.php?page=&quot; + pageNumber + &quot;&amp;pagesize=5&quot;,function(data){ //转为对象 var dataobj = typeof data == &quot;object&quot; ? data : eval(&quot;(&quot; + data + &quot;)&quot;); //数组 var list = dataobj.result; //计算总页数 var pageAmount = Math.ceil(dataobj.count / 5); //删除之前的所有tr $(&quot;table tr:gt(0)&quot;).remove(); //遍历字典，组建DOM上树 _.each(list,function(dictionary){ var str = compiled(dictionary); $(str).appendTo(&quot;table&quot;); }); //验证导航条是否存在，如果不存在new一个 if(pageNav == null){ pageNav = new PageNav({ &quot;boxid&quot; : &quot;pn&quot;, &quot;pageAmount&quot; : pageAmount, //函数委托 &quot;change&quot; : function(index){ getStudent(index); } }) } }); } 3、HashAjax做的一切都是有一个问题，就是URL不变，这样的话，不方便分享网址。此时可以用hash来解决。 一个较完整的URL： http://www.iqianduan.cn/a/b/c.php?name=%A3%B4%C3%A3%B4%C3&amp;age=12#good Path 文件路径： http://www.iqianduan.cn/a/b/c.php Query String 查询字符串：?name=%A3%B4%C3%A3%B4%C3&amp;age=12 Hash 锚点：#good 锚点的本质是a标签，a标签可以发出超级链接，也可以定位超级链接。 &lt;a name=&quot;maomao1&gt;&lt;/a&gt; a不需要有href属性，不需要有内部文本，此时URL中 #maomao1 就能快速定位浏览器卷动，默认卷动到这里。 hash的更改不会引起页面的刷新，不会重新发送HTTP请求。 JavaScript得到hash、设置hash都是用： window.location.hash //读取 window.location.hash = &quot;maomao1&quot;; //设置 用百度招聘为例，此时要解决： 1） 用户输入一个有hash的URL的时候，能够自动加载这个页面的数据，同时分页条也要对应页面有cur； 2） 当用户点击分页条的时候，要改变页面hash","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"JSONP跨域详解","slug":"title42","date":"2016-12-12T09:27:56.000Z","updated":"2017-02-20T10:38:00.373Z","comments":true,"path":"2016/12/12/title42/","link":"","permalink":"http://yoursite.com/2016/12/12/title42/","excerpt":"","text":"1、Ajax因为安全限制不允许跨域Ajax不能跨域，指的是如果你的HTML页面在127.0.0.1上，此时将不能访问127.0.0.2上的文件。如果你的文件在www.iqianduan.cn上，也不能访问www.163.com上的文件。有些浏览器甚至不允许你访问news.58gsl.cn。这是浏览器的安全限制，不允许你随随便便的访问其他服务器上的JSON。 2、JSONP跨域JSONP就是JSON with Padding ( JSON和 赘语），指的就是把函数的执行放到外部文件，HTML用script标签引用这个js文件，实际上引用的是对一个函数的执行。此时函数定义在HTML文件里面，数据就通过实参、形参的结合就进入了HTML数据。 &lt;script type=&quot;text/javascript&quot;&gt; function fun(data){ alert(data.xingming); } &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;haha.txt&quot;&gt;&lt;/script&gt; → 这个文件执行了fun函数 haha.txt文件里面： fun({&quot;xingming&quot;:&quot;小明&quot;,&quot;nianling&quot;:12,&quot;xingbie&quot;:&quot;男&quot;}); 红色部分是执行一个函数，就是所谓的“P”。 京东数据的请求： &lt;script type=&quot;text/javascript&quot;&gt; function yuanye(data){ for(var i = 0 ; i &lt; data.comments.length ; i++){ alert(data.comments[i].content); } } &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://sclub.jd.com/comment/productPageComments.action?productId=4048938&amp;score=0&amp;sortType=3&amp;page=1&amp;pageSize=10&amp;callback=yuanye&quot;&gt;&lt;/script&gt; JSONP的缺点： 1） 太不安全，什么时候章泽天和刘强东吵架，刘强东很生气，把JSONP接口换成了 for(var i = 0 ; i &lt; 1000000 ; i++){ alert(&quot;你好&quot;); } 此时你又在用script引用它，此时你的用户也被连带遭殃了。 所以JSONP的提供者，一定要可靠！ 2） 没有明显的异步的特点。页面虽然不会假死，但是没有提供回调函数。不过也没关系，页面不假死是重点。 3） 很难控制请求的发出。比如我想点击一个按钮，然后发出请求。不过也很快被解决了，我们可以动态的创建一个script标签，设置了src，一旦上树，上行请求将发出，此时函数将执行！ &lt;script type=&quot;text/javascript&quot;&gt; var btn = document.getElementById(&quot;btn&quot;); //准备一个函数，一会儿外部文件将执行这个函数 function fun(data){ alert(data.xingming); } //事件监听 btn.onclick = function(){ var oscript = document.createElement(&quot;script&quot;); oscript.src = &quot;haha.txt&quot;; document.head.appendChild(oscript); document.head.removeChild(oscript); } &lt;/script&gt; 甚至我们可以封装一个函数，就不用显式的创建fun函数了，可以把用户传输进来的函数，当做fun函数： &lt;script type=&quot;text/javascript&quot;&gt; var btn = document.getElementById(&quot;btn&quot;); function qingqiu(URL,callback){ //你第二个传入的参数就是哈哈函数 window.fun= callback; var oscript = document.createElement(&quot;script&quot;); oscript.src = URL; document.head.appendChild(oscript); document.head.removeChild(oscript); } qingqiu(&quot;haha.txt&quot;,function(data){ alert(data.nianling); }); &lt;/script&gt; jQuery中使用JSONP和使用正经Ajax一样一样的，你完全看不出来，只是些许有些语法不一样。 3、JSONP的jQuery使用首先： $.get(URL,function(data){ }); $.post(URL,function(data){ }); jQuery中最全活的API是： $.ajax(); 比如： $.ajax({ &quot;url&quot; : &quot;php/job.php&quot;, &quot;data&quot; : { &quot;page&quot; : 2 }, &quot;type&quot; : &quot;get&quot;, &quot;success&quot; : function(data){ alert(data); } }); 等价于： $.get(&quot;php/job.php?page=2&quot;,function(data){ alert(data); }) 此时jQuery实现JSONP跨域： &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.12.3.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $.ajax({ //请求的地址，下面是一个域外的地址 &quot;url&quot; : &quot;http://127.0.0.2/haha.txt&quot;, //请求类型是jsonp类型，注意是dataType属性而不是type属性 &quot;dataType&quot; : &quot;jsonp&quot;, //定义我们传进来的success函数叫什么名字 &quot;jsonpCallback&quot; : &quot;fun&quot;, //定义一个函数，这个函数马上会成为window.fun &quot;success&quot; : function(data){ alert(data.xingming); alert(data.nianling); alert(data.xingbie); } }); &lt;/script&gt; 特别的，如果后台哥哥给你写了callback GET请求参数，可以任意设置调用的函数名字，此时jQuery中可以用？代替这个部分，jQuery会自动帮你填入随机乱码： $.ajax({ &quot;url&quot; : &quot;https://sclub.jd.com/comment/productPageComments.action?productId=4048938&amp;score=0&amp;sortType=3&amp;page=1&amp;pageSize=10&amp;callback=?&quot;, &quot;dataType&quot; : &quot;jsonp&quot;, &quot;success&quot; : function(data){ alert(data.comments.length); } }); 此时jQuery就会把请求发往： https://sclub.jd.com/comment/productPageComments.action?productId=4048938&amp;score=0&amp;sortType=3&amp;page=1&amp;pageSize=10&amp;callback=jQuery112306426957034965071_1480068166765 工作中这种模式最最常用。","categories":[{"name":"JSONP","slug":"JSONP","permalink":"http://yoursite.com/categories/JSONP/"}],"tags":[{"name":"JSONP","slug":"JSONP","permalink":"http://yoursite.com/tags/JSONP/"}]},{"title":"Ajax中的GET请求和POST请求","slug":"title41","date":"2016-12-09T09:27:56.000Z","updated":"2017-02-20T10:37:51.699Z","comments":true,"path":"2016/12/09/title41/","link":"","permalink":"http://yoursite.com/2016/12/09/title41/","excerpt":"","text":"1、GET请求GET请求参数在URL中，所以参数非常好携带。GET请求没有上行报文体，所以send里面是null。 xhr.open(&quot;get&quot;,&quot;check.php?username=考拉&amp;age=12&quot;,true); xhr.send(null); 研究两个事情：字符转码的问题、用JSON来转为query string。 我们观察一个事情，此时在地址栏中输入你好： 复制出来就是： http://127.0.0.1/test.txt?%E4%BD%A0%E5%A5%BD 也就是说中文汉字就是：%AA%AA%AA 其中AA是一个两位16进制数字。 这个叫做URI转码（Uniform Resource Identifier，统一资源标识符），URI和URL差不多，只不过URL强调的是地址，URI强调的是具体的写法。 因为网址只能是英语字符和数字，不能是中文、日语、韩语、阿拉伯文等等，所以URI就想了个办法，用16进制数字来表示非英语文字。 JavaScript内置了转码的函数，各个浏览器兼容很好： 从中文 → URI编码：encodeURIComponent(“我爱你”)URL编码 → 中文：decodeURIComponent(“%E4%BD%A0%E5%A5%BD”) 此时任何后台语言都不需要再次解码就能识别标准URI编码。所以你要知道这个东西不是密码，就是在传输过程中为了防止非英语文字变形，用的临时编码。 &lt;?php $ciyu = $_GET[&quot;ciyu&quot;]; echo $ciyu; ?&gt; 为了防止传输过程中变形，所以我们的Ajax程序要： xhr.open(&quot;get&quot;,&quot;check.php?yonghuming=&quot; + encodeURIComponent(yonghuming) + &quot;&amp;age=&quot; + encodeURIComponent(12)); 再来研究一个事情，能不能写一个函数，接受一个JSON，返回query string。比如传入： { &quot;yonghuming&quot; : &quot;小明&quot;, &quot;age&quot; : 12, &quot;sex&quot; : &quot;男&quot; } 返回 &quot;?yonghuming=%E5%B0%8F%E6%98%8E&amp;age=12&amp;sex=%E7%94%B7&quot; 函数很好写，利用数组的join方法，是个神器！一旦你遇见让你返回字符串，然后字符串之间有符号，开头、结尾没有符号，就要想到join方法。 function changeJSON2QueryString(JSON){ var temp = []; for(var k in JSON){ temp.push(k + &quot;=&quot; + encodeURIComponent(JSON[k])); } return temp.join(&quot;&amp;&quot;); } 所以现在我们Ajax的open语句可以这么玩儿： var querystring = changeJSON2QueryString({ &quot;yonghuming&quot; : &quot;小明&quot;, &quot;age&quot; : 12, &quot;sex&quot; : &quot;男&quot; }); xhr.open(&quot;get&quot;,&quot;check.php?&quot; + querystring , true); 2、POST请求POST请求是通过request报文体来传输，所谓open简单，send里面有内容。PHP程序需要我们加上一个Request Header中的Content-type为普通表单，才能在后台用$_POST[]识别。 任何一个post的表单的上行报文头里面，都有这样的K-V对儿： Content-Type:application/x-www-form-urlencoded 所以我们在Ajax中也要设置（今后遇见node.js就不用设置）： xhr.open(&quot;post&quot;,&quot;dopost.php&quot;,true); xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); xhr.send(&quot;yonghuming=%E5%B0%8F%E6%98%8E&amp;age=12&amp;sex=%E7%94%B7&quot;); 3、JSON的识别JSON是一个通用信息交换格式，比如PHP工程师，可以使用json_encode()函数把别名数组转为标准JSON： &lt;?php $arr = array( &quot;result&quot; =&gt; array( array(&quot;xingming&quot; =&gt; &quot;小明&quot; , &quot;nianling&quot; =&gt; 12 , &quot;xingbie&quot; =&gt;&quot;男&quot;), array(&quot;xingming&quot; =&gt; &quot;小红&quot; , &quot;nianling&quot; =&gt; 15 , &quot;xingbie&quot; =&gt;&quot;女&quot;), array(&quot;xingming&quot; =&gt; &quot;小刚&quot; , &quot;nianling&quot; =&gt; 13 , &quot;xingbie&quot; =&gt;&quot;男&quot;) ) ); echo json_encode($arr); ?&gt; JSON显示在页面上的时候，不方便我们看JSON的结构，此时推荐安装一个浏览器插件，叫做JSONView。 Chrome应用商店打不开，并且网上下载的都不适合现在的Chrome版本。所以我们可以安装QQ浏览器，它的内核也是Chrome内核，中国人没有自己的浏览器内核。在应用中心中，安装“JSONView”。 安装完插件之后，访问JSON页面： 4、JSON识别我们使用Ajax读取一个JSON的时候，此时明明是JSON，但是读进来是String。此时就要把String变为JSON。 $.get(&quot;04_JSON.php&quot;,function(data){ console.log(data); console.log(typeof data); }); 一共有三种方法。 方法1：使用内置构造函数JSON的方法 var dataobj = JSON.parse(data); console.log(dataobj); console.log(typeof dataobj); JSON是系统内置的构造函数，和Number、String、Array一样。它IE8才开始有，IE6、7不支持JSON内置构造函数。 它一共就有两个方法： JSON.parse() 字符串 → 对象 JSON.stringify() 对象 → 字符串 JSON.parse()函数里面的字符串必须是标准JSON，必须有双引号引用所有的key。 方法2：使用eval语句 eval语句可以把字符串变为语句，是JS中的一个特色。 var str = &quot;alert(1+2+3)&quot;; //字符串 eval(str); //字符串变为了语句 弹出6。 eval()一般都是当做奇淫技巧使用，注意任何文本框都需要用正则表达式阻止eval。比如让你输出一个用户名，你叫做eval(“setInterval(function(){alert(‘哈哈’);},1)”); 极其危险！ 我们可以利用eval语句来把JSON字符串变为对象的JSON，但是此时要注意：如果直接eval一个JSON字符串，会报错： 语法要求必须用圆括号括起来： 所以： var dataobj = eval(&quot;(&quot; + data + &quot;)&quot;); console.log(dataobj); console.log(typeof dataobj); 方法3：借助Function函数 var sum = new Function(&quot;a&quot;,&quot;b&quot;,&quot;return a + b&quot;); alert(sum(3,4)); Function你仔细琢磨，也可以把字符串变为语句啊！ var dataobj = (new Function(&quot;return &quot; + data))(); console.log(dataobj); console.log(typeof dataobj); 5、复杂JSON的JS处理现在拿一个JSON举例子： 请用Ajax读取它，在HTML页面上枚举所有点击数大于1000的文章标题。 &lt;script type=&quot;text/javascript&quot;&gt; $.get(&quot;system/baijiayanshi.txt&quot;,function(data){ //把字符串转为真正的JSON var dataobj = eval(&quot;(&quot; + data + &quot;)&quot;); //如鱼得水，“JSON回家了” var arr = dataobj.data.list; for(var i = 0 ; i &lt; arr.length ; i++){ if(arr[i].hotcount &gt; 1000){ $(&quot;&lt;p&gt;&quot; + arr[i].m_title + &quot;【点击数：&quot; + arr[i].hotcount + &quot;】&lt;/p&gt;&quot;).appendTo(&quot;#box&quot;); } } }); &lt;/script&gt;","categories":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"原生Ajax的实现","slug":"title40","date":"2016-12-08T09:27:56.000Z","updated":"2017-02-20T10:37:44.760Z","comments":true,"path":"2016/12/08/title40/","link":"","permalink":"http://yoursite.com/2016/12/08/title40/","excerpt":"","text":"原生Ajax的实现原生Ajax要依赖一个内置构造函数，XMLHttpRequest()，字面理解“XML HTTP 请求者”。这个对象的实例有能力异步发出HTTP请求的能力。 要实例化这个对象： var xhr = new XMLHttpRequest(); 此时IE6不兼容这个对象： //实例化XMLHttpRequest对象，有兼容问题 if(window.XMLHttpRequest){ //高级浏览器 var xhr = new XMLHttpRequest(); }else{ //IE6 var xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); } 我们可以配置它的发送请求： xhr.open(&quot;get&quot;,&quot;test.txt&quot;,true); 三个参数分别是请求的类型、URL、是否是异步。第三个参数一定是true，否则就不是异步读取了。请求没有真正发出，仅仅是配置了打开了发送“窗口”。 此时用send方法发出请求。send就是发送请求，参数是上行请求的报文体。get请求不需要报文体，就是null。 xhr.send(null); 原生JS中没有提供给一个明显的回调函数，此时需要监听一个事件，就绪状态改变事件： xhr.onreadystatechange = function(){ console.log(&quot;就绪状态改变了&quot; + xhr.readyState); } 对我们有用的两个readyState就是3、4。当readyState为3的时候，已经可以得到服务器的信息，因为header已经回来了，做倒计时秒杀的收，就用3这个状态。4表示所有内容已经成功返回，更有用，因为只有状态是4的时候才能得到完整的文件信息。 接受到的信息是xhr.responesText。 xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ info.innerHTML = xhr.responseText; } } 有规定，onreadystatechange必须写在open和send前。所以至此代码： //① 实例化XMLHttpRequest对象，有兼容问题 if(window.XMLHttpRequest){ //高级浏览器 var xhr = new XMLHttpRequest(); }else{ //IE6 var xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); } //② 监听一个事件，叫做“就绪状态”改变的事件 xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ info.innerHTML = xhr.responseText; } } // ③ 配置一个请求，open可以理解为打开一个请求“窗口” xhr.open(&quot;get&quot;,&quot;test.txt&quot;,true); // ④ 发送请求，send就是发送请求，参数是上行请求的报文体。get请求不需要报文体，就是null。 xhr.send(null); 此时我们需要让程序更加鲁棒，当文件不存在的时候，整个页面的错误信息也读到本页面来了： 所以就要用HTTP状态码来验证文件是否已经成功发送。 HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。这个代码是后台哥哥可以随便设置的，阿帕奇服务器也会帮我们自动生成状态码。 重要的状态码是： 200-成功 302-临时移动 304-没有更改 400-错误的请求 401-没有权限 403-禁止 404-页面丢失，没有找到 500-服务器错误 502-错误的网关 503-服务无效 504-访问超时 xhr对象的status属性可以得到状态码。从而可以用来验证页面是不是真的发过来了，此时验证字头是2开头的或者是304。 xhr.onreadystatechange = function(){ if(xhr.readyState == 4){ if(xhr.status.toString().charAt(0) == &quot;2&quot; || xhr.status == &quot;304&quot;){ info.innerHTML = xhr.responseText; } } } 也可以： if(xhr.status == &quot;200&quot; || xhr.status == &quot;304&quot;){ } 也可以： if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){ } Ajax的缓存比较严重，此时可以通过每次访问的时候带一个不同的参数即可。此时可以挂一个随机数，或者时间戳： xhr.open(&quot;get&quot;,&quot;test.txt?&quot; + Date.parse(new Date()),true); xhr.open(&quot;get&quot;,&quot;test.txt?&quot; + Math.random(),true); 至此，已经学习了xhr的： ● 一个事件 xhr.onreadystatechange 就绪状态改变事件 ● 两个方法 xhr.open()方法 打开一个发射窗口xhr.send()方法 发送请求 ● 三个属性 xhr.responseText 返回的文本xhr.readyState 就绪状态xhr.status 3位数字的状态码number类型","categories":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/categories/Ajax/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://yoursite.com/tags/Ajax/"}]},{"title":"游戏开发中canvas常见要点","slug":"title39","date":"2016-12-05T09:27:56.000Z","updated":"2017-02-20T10:37:03.766Z","comments":true,"path":"2016/12/05/title39/","link":"","permalink":"http://yoursite.com/2016/12/05/title39/","excerpt":"","text":"1 游戏图片、音乐资源的管理不管游戏中有多少元素在运动，游戏仅仅有1个定时器，这1个定时器让所有的演员更新、渲染。实际上，一个游戏需要大量的图片，只有当所有图片都load了，游戏才能开始。换句话说，只有当所有图片都load了，主循环setInterval()才能启动。 所以我们的思路就是用JSON imagesObj 存放所有的资源图片的名字，用循环语句for..in…去创建他们的Image对象，然后监听他们的load事件，load一个计数器加1，当load完一个图片的时候，计数器正好等于了数组总长度，此时表示所有图片加载完毕。比较巧妙的是，我们创建了一个R对象，这个对象和imagesObj 的key是一样的，但是v是图片的Image实体，用图片的时候，要通过R打点来找到图片。 &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //如果要使用图片，必须要创建一个Image的实例，然后监听这个img的load事件 //只有load的图片才能上画布 var imagesObj = { &quot;shibing&quot; : &quot;images/shibing.png&quot;, &quot;baozha&quot; : &quot;images/baozha.png&quot; }; //图片资源对象，k和imagesObj是一样的，v是真正的图片Image对象 var R = {}; //已经加载好的图片个数 var count = 0; var cutx = 0; var baozhaxuhao = 0; for(var k in imagesObj){ //创建图片节点 R[k] = new Image(); //设置src R[k].src = imagesObj[k]; //监听是否load R[k].onload = function(){ count++; if(count === 2){ //全部都加载完毕 setInterval(function(){ cutx ++; baozhaxuhao++; if(cutx &gt; 7){ cutx = 0; } if(baozhaxuhao &gt; 11){ baozhaxuhao = 0; } //清屏 ctx.clearRect(0, 0, 800, 600); ctx.drawImage(R.shibing,120 * cutx,150 * 3,120,150,100,100,120,150); ctx.drawImage(R.baozha,192 * (baozhaxuhao % 5),192 * parseInt(baozhaxuhao / 5),192,192,100,100,192,192); },20); } } } &lt;/script&gt; 2、Game类Game类就是中介者模式中的中介者 ##。中介者就是全局变量！比如我们以前 var idx = 10; 信号量，就是全局变量，现在把这个量放入一个类的实例身上，此时这个类就是中介者。 信号量在中介者身上： var game = new Game(); game.idx = 10; 以后所有的元素都是Game类new出来的，我们只需要new出中介者，其他元素都是Game帮我们new出来的。 其他元素如果要互相通信，要通过Game类： game.bird.y 在HTML5游戏中，Game类还将有：主循环、游戏资源管理两个任务。 图片资源管理利用两个对象，RObj和R对象。Robj就是Ajax请求来的文本转为的对象，v是路径； R对象的拥有Robj相同的k，但是v是真实对象： 3 背景类背景类的实例化在Game的start函数里面。而start函数的调用的前提是所有资源已经加载完毕了。说白了，背景类里面可以直接使用图片资源。 canvas里面也有猫腻，也有模式。渲染三张，目的是无缝连续滚动，当猫腻图的左边框到达0点，就拉回来。 4、cancas变形canvas中，提供了变形属性，需要注意的是，所有的变形都是针对画布上下文ctx对象的，而不是某一个要绘制的元素的。 var mycanvas = document.getElementById(“mycanvas”); var ctx = mycanvas.getContext(&quot;2d&quot;); //保存当前的上下文状态 ctx.save(); //移动坐标系 ctx.translate(100,100); //画圆 ctx.fillStyle = &quot;blue&quot;; ctx.beginPath(); ctx.arc(0,0,50,0,Math.PI * 2,true); ctx.fill(); //恢复上下文存档状态 ctx.restore(); //画方块 ctx.fillRect(100, 100, 100, 100); &lt;/script&gt; 坐标系还可以通过 ctx.rotate(1);渲染1弧度。同样的，旋转的是整个坐标系，而不是某一个元素。 &lt;script type=&quot;text/javascript&quot;&gt; var mycanvas = document.getElementById(&quot;mycanvas&quot;); var ctx = mycanvas.getContext(&quot;2d&quot;); ctx.rotate(1); //1弧度，顺时针 ctx.fillStyle = &quot;orange&quot;; ctx.fillRect(100, 100, 100, 100); &lt;/script&gt; 如果想要让一个元素以自己的几何中心点旋转，此时需要： ① 先让坐标系的原点移动到它的中心点，此时盒子的渲染位置就是负的自己的宽度的一半，负的自己的高度的一半。 ② 旋转 公式： t指的是开始下落后的时间，此时小鸟就要维护自己的小帧号birdF。 //物理公式：s = 1/2gt^2 //掉 birdF++; birdY = 100 + 1.3 * birdF * birdF; birdRotate+=0.08; 5、碰撞检测但是游戏中我们一般使用AABB盒检测。 AABB盒是英语Axis Aligned Bounding Box 轴对齐包围盒。 鸟是一个不规则形状，判断碰撞的时候取一个大概，用矩形盒子来判断： //更新自己的碰撞检测盒 this.A = this.y + 7; this.B = this.x + 41; this.C = this.y + 41; this.D = this.x + 7; 鸟这个图片本身是48宽度，碰撞盒是34，所以两边有误差7。 所谓的ABCD都是边的x或者y，横边就取y值，纵边就取x值。碰撞检测： if( game.bird.A &lt; this.C1 &amp;&amp; game.bird.B &gt; this.D1 &amp;&amp; game.bird.D &lt; this.B1 || game.bird.C &gt; this.A2 &amp;&amp; game.bird.B &gt; this.D2 &amp;&amp; game.bird.D &lt; this.B2 ){ console.log(&quot;撞！&quot;); clearInterval(game.timer); } 6、合成canvasctx.globalCompositeOperation = type 一共有12种值，表示新画的图形和老图形的关系，称为“合成”。 比如： ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(100,100,100,100); ctx.globalCompositeOperation = &quot;source-in&quot;; ctx.beginPath(); ctx.arc(180,180,50,0,7,false); ctx.fillStyle = &quot;red&quot;; ctx.fill(); 像素操作到目前为止，我们尚未深入了解Canvas画布真实像素的原理，事实上，你可以直接通过ImageData对象操纵像素数据，直接读取或将数据数组写入该对象中。稍后我们也将深入了解如何控制图像使其平滑（反锯齿）以及如何从Canvas画布中保存图像。 得到像素： var myImageData = ctx.getImageData(0,0,560,300); 0,0表示起点位置，560是宽度，300是高度。 得到的值可以被使用作为查看初始像素数据。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是”RGBA”格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。 7、事件监听canvas上必须检测范围，因为得不到元素。 贝塞尔曲线： ctx.moveTo(100,100); ctx.bezierCurveTo(200, 50, 400, 50, 400, 100); ctx.stroke(); 点击鼠标的时候，要遍历每个元素，看看点击到了谁，点击到的这个元素，就存入变量。然后让变量中的元素x、用、跟随你的鼠标变化即可。 if(x &gt; ctrl1.x - 5 &amp;&amp; x &lt; ctrl1.x + 5 &amp;&amp; y &gt; ctrl1.y - 5 &amp;&amp; y &lt; ctrl1.y + 5){ diandaodedian = ctrl1; } if(x &gt; ctrl2.x - 5 &amp;&amp; x &lt; ctrl2.x + 5 &amp;&amp; y &gt; ctrl2.y - 5 &amp;&amp; y &lt; ctrl2.y + 5){ diandaodedian = ctrl2; } if(x &gt; start.x - 5 &amp;&amp; x &lt; start.x + 5 &amp;&amp; y &gt; start.y - 5 &amp;&amp; y &lt; start.y + 5){ diandaodedian = start; } if(x &gt; end.x - 5 &amp;&amp; x &lt; end.x + 5 &amp;&amp; y &gt; end.y - 5 &amp;&amp; y &lt; end.y + 5){ diandaodedian = end; } 8、场景Scene管理开始画面、游戏过程、结束画面。 场景现在开始接手管理自己的演员！！但是，场景还是应该把演员注册到game身上，但是管理的权限、谁上台、谁下台，是场景管理器的任务。 监听都是场景管理器负责注册！！ http://squishybird.com/ http://so2.4399.com/","categories":[{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/categories/Canvas/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/tags/Canvas/"}]},{"title":"移动端缓冲ease事件","slug":"title37","date":"2016-11-30T09:27:56.000Z","updated":"2017-02-20T10:36:48.263Z","comments":true,"path":"2016/11/30/title37/","link":"","permalink":"http://yoursite.com/2016/11/30/title37/","excerpt":"","text":"1、缓冲easeCSS中的transition第三个参数就是缓冲描述： transition:all 1s linear 0s; transition:all 1s ease 0s; JS也有，但是要自己推理： 让div用100帧，从left100变化到left800。匀速的话，非常好计算： 总变化量就是700，所以每帧的变化量应该是7。 帧编号t 距起点的增量tc/d 绝对位置b + tc/d 假设帧编号为t（本例中t自增），t就是time的意思 起点成为b（本例中b为100），b就是begin起点的意思 总变化量c（本例中c为700），c就是change变化量的意思 总帧数d（本例中d为100），d就是duration持续时间的意思 所以刚才的推理就变为了一个函数： function linear(t,b,c,d){ return b + t * c / d; } 此时这个函数接受四个参数的意义，上面已经说明了，返回的是绝对位置。此时观察这个函数， t=0的时候，返回值是b （运动没有开始） ； t= d的时候，返回值就是b+c （运动结束）。 所以我们就可以自己写一些函数，比如二次的： function haha(t,b,c,d){ return b + t * t * c / (d *d); } Excel中做图： 上网能下载到很多t、b、c、d的函数 jQuery中实现缓冲，下载jQuery.easing.js的包 $().animate({},1000,&quot;easeInOut&quot;); 2、手指滚滚屏手机滚滚屏中，希望有一个loading界面，当所有图片都加载好支持，再从容给用户观看。所以我们要管理好资源，我们的想法就是使用一个JSON列出所有的图片资源： { &quot;tu1&quot; : &quot;images/1.jpg&quot;, &quot;tu2&quot; : &quot;images/2.jpg&quot;, &quot;tu3&quot; : &quot;images/3.jpg&quot; } 用JS写程序创建一个个孤儿节点，图片对象存储在和这个JSON相同的另一个对象中： { &quot;tu1&quot; : Image(), &quot;tu2&quot; : Image(), &quot;tu3&quot; : Image() } 此时HTML页面上，仅仅用img标签的“模板”来占位，用JS的真实图片孤儿节点，替换这个节点。 &lt;img data-name=&quot;tu1&quot; /&gt;","categories":[{"name":"移动web","slug":"移动web","permalink":"http://yoursite.com/categories/移动web/"}],"tags":[{"name":"移web","slug":"移web","permalink":"http://yoursite.com/tags/移web/"}]},{"title":"移动端JS事件","slug":"title36","date":"2016-11-30T09:27:56.000Z","updated":"2017-02-20T10:36:38.746Z","comments":true,"path":"2016/11/30/title36/","link":"","permalink":"http://yoursite.com/2016/11/30/title36/","excerpt":"","text":"##1、触摸事件 ##移动端JS事件，重要就是触摸事件。触摸事件和鼠标事件完全不一样，因为鼠标不可能离开屏幕，鼠标在屏幕上可以点击可以不点击；但是手指可以离开屏幕，手指一旦碰到屏幕，就被视为点击了。所以，JS设计了一套完整的触摸事件系列，适应移动端web开发。 touchstart 开始触摸 touchmove 手指移动 touchend 结束触摸 touchstart 在手指触摸的一瞬间发生，如果有多个手指触摸，每个手指触摸的时候都会发生。 touchend 在手指离开屏幕的一瞬间发生，如果有多个手指离开，每个手指离开的时候都是触发这个事件。 绑定他们的时候，只能用DOM2级来绑定，不能用window.on*来绑定。 &lt;script type=&quot;text/javascript&quot;&gt; var box = document.querySelector(&quot;#box&quot;); box.addEventListener(&quot;touchstart&quot;, function(){ box.innerHTML = &quot;你触摸了我&quot;; }, true); box.addEventListener(&quot;touchend&quot;, function(){ box.innerHTML = &quot;你结束触摸了我&quot;; }, true); &lt;/script&gt; 注意，touchstouch事件和touchmove事件中event事件对象中有一个属性叫做touches是一个数组，里面封装了每个手指的信息，包括手指的位置、手指的粗细、力度（仅仅iPhone7提供）都有： 手指的数量： var fingers = event.touches.length; 每根手指的位置信息： //触摸移动 box.addEventListener(&quot;touchmove&quot;, function(event){ //阻止默认事件 event.preventDefault(); //得到每个手指的信息 var fingers = event.touches; //清空 box.innerHTML = &quot;&quot;; //遍历每个手指，显示信息 for(var i = 0 ; i &lt; fingers.length ; i++){ box.innerHTML += &quot;第&quot; + i + &quot;根手指位置&quot; + fingers[i].clientX + &quot;,&quot; + fingers[i].clientY + &quot;&lt;br /&gt;&quot;; } }, true); touchend事件中比较特殊，touches属性是一个数组，表示现在仍然在屏幕上的手指；而changedTouches属性也是一个数组，表示离开的手指的信息。先离开屏幕的手指，先被push进入数组。 事件比较简单就是三个事件，和里面的event.touches属性。难点在于程序，在于三个事件的配合。手机端，要注意几个模型：拖拽、轮播图、抛掷、滑动拖出。 最后说一个问题，就是手机中也有click事件，但是click事件比touchstart要晚触发200ms到300ms左右，因为浏览器有默认的一些手指快捷操作，比如双击两次放大视口。如果你用click写了一个div的单击事件，此时点击之后浏览器会等待200~300ms时间看看你有没有第二次点击，如果200~300ms以内没有点击，此时触发你的click事件，如果有点击，则你的click事件业务不发生，而是放大视口。但是touchstart不会等待，只要你碰到了屏幕一定会执行touchstart事件。 注意，a标签执行的是类似click事件，等于说a标签被延迟了200~300触发，所以手机web中越来越不使用a标签跳转了，而是touchstart事件跳转。方法就是让元素携带data-href属性，然后用js批量给他们绑定的touchstart事件，让window.location切换为自己携带的data-href属性的值。 &lt;div id=&quot;box&quot; data-herf=&quot;http://m.taobao.com&quot;&gt;&lt;/div&gt; &lt;div id=&quot;box&quot; data-herf=&quot;http://m.dangdang.com&quot;&gt;&lt;/div&gt; var herfBoxs = document.querySelectorAll(&quot;[data-herf]&quot;); for(var i = 0 ; i &lt; herfBoxs.length ; i++){ herfBoxs[i].index = i; herfBoxs[i].addEventListener(&quot;touchstart&quot;, function(){ window.location = this.getAttribute(&quot;data-herf&quot;); }, true); } 2、拖拽拖拽是一切的基础，我们之前在鼠标的事件中已经学习过，但是你会发现： box.onmousedown = function(){ document.onmousemove = function(){ } } document.onmouseup = function(){ document.onmousemove = null; } 鼠标事件和触摸事件不一样，因为手指移动一定是在屏幕上的。所以touchmove事件不需要写在touchstart事件里面。其他的原理完全一致。 三个事件各自有各自的用处： &lt;script type=&quot;text/javascript&quot;&gt; var img = document.querySelector(&quot;#yangyang&quot;); //信号量 var x = 100; var y = 100; var startX,startY,dx,dy; //触摸开始 img.addEventListener(&quot;touchstart&quot;, function(event){ //阻止页面有默认事件 event.preventDefault(); //拿到这个手指 var thefinger = event.touches[0]; //记录开始触摸的位置 startX = thefinger.clientX; startY = thefinger.clientY; console.log(startX,startY); }, true); //触摸移动 img.addEventListener(&quot;touchmove&quot;, function(event){ //阻止页面有默认事件 event.preventDefault(); //拿到这个手指 var thefinger = event.touches[0]; //记录开始触摸的位置 dx = thefinger.clientX - startX; dy = thefinger.clientY - startY; img.style.left = x + dx + &quot;px&quot;; img.style.top = y + dy + &quot;px&quot;; }, true); //触摸结束 img.addEventListener(&quot;touchend&quot;, function(event){ //阻止页面有默认事件 event.preventDefault(); //改变信号量 x += dx; y += dy; }, true); &lt;/script&gt; 3、指滑轮播图有人研究过，top、left属性的效率，不如transform属性的效率。所以要进行移动什么东西，多考虑transform属性。 屏幕旋转的时候触发window的onresize事件，HTML5也提供了事件onorientationchange，但是这个事件不好用，有些浏览器不支持。所以onresize还是不错的。 4、惯性抛掷拖拽，但是停不下来，有惯性，会慢慢停下来。主要制作方法有两大种： 方法1：overflow:auto; 很智能的就把移除的内容就变成可以滑动、抛掷、惯性的了。 触摸的时候的颜色： -webkit-tap-highlight-color: rgba(0,0,0,0); 方法2：自己写函数，自己模拟 比如新浪首页：https://sina.cn/: 比如我们现在按住了图片，拖拽，松手的地方是-500px，此时它应该根据我们的速度继续让这个盒子运动到终点，每一次都有衰减。 难点就是在获得用户的抛掷速度上面，我们都是使用touchmove事件的最后两个点的距离间隔。 touchmove事件不是移动1px就触发一次！不是！而是CPU有一个时钟周期，3.5GHz，每秒钟再玩命的检测你的鼠标位置，所以你的鼠标的位置值，不是连续的。 很快的抛掷的最后几个点的横坐标： 很慢的抛掷的最后几个点的横坐标： 取最后两个点的间隔，间隔越大表示用户抛掷的速度越快，间隔越小，就是抛掷的慢。 就是用定时器去模拟几次滑动即可，模拟几帧？衰减多快？ 模拟几帧：50帧以上，跟速度成正比 衰减多块：速","categories":[{"name":"移动web","slug":"移动web","permalink":"http://yoursite.com/categories/移动web/"}],"tags":[{"name":"移web","slug":"移web","permalink":"http://yoursite.com/tags/移web/"}]},{"title":"移动web百分比布局","slug":"title35","date":"2016-11-28T09:27:56.000Z","updated":"2017-02-20T10:36:11.774Z","comments":true,"path":"2016/11/28/title35/","link":"","permalink":"http://yoursite.com/2016/11/28/title35/","excerpt":"","text":"1 百分比布局手机web页面都没有版心，都是撑满的，这是因为： 手机本身就小，你再留白边，寸土寸金的地方都浪费了； APP一般都是撑满的，大家手机上网的时候，也希望撑满。 此时就会给制作带来难度，因为尺寸不能写px单位了，比如版心设置为360px，此时iPhone6plus的414视口会看见白色边： 2 百分比布局基础用百分比设置宽度、高度（绝大多数高度可以写为px）、padding、margin的布局方式，叫做流式布局，页面有弹性，所以也叫弹性布局。 &lt;body&gt; &lt;div&gt;&lt;/div&gt; → div是body的亲儿子，60%指的是窗口宽度的60% &lt;/body&gt; &lt;body&gt; &lt;div&gt; &lt;main&gt; → 60%指的是div的width的60%，无视div的padding。 &lt;p&gt;&lt;/p&gt; → 60%指的是main的width的60%，无视div的padding。 &lt;/main&gt; &lt;/div&gt; &lt;/body&gt; 看看padding，都参考父亲的width。注意，竖直方向上的padding也是看父亲的width，而不是height。 &lt;div&gt; &lt;main&gt;&lt;/main&gt; → padding-left:10%;指的是父亲的width的10%，而不是父亲的padding。 padding-top:10%;指的是父亲的width的10%，而不是父亲的height。 &lt;/div&gt; 再来看border，不能用百分比写。 border: 10% solid #000; 再来看margin，一律参考父亲width，不参考父亲的margin和height。 &lt;style type=&quot;text/css&quot;&gt; *{ margin: 0; padding: 0; } div{ width: 200px; height: 600px; border: 10% solid #000; } p{ margin: 10%; } &lt;/style&gt; 总结： 无论margin、padding、width、height，无论竖直方向还是水平方向，参考的都是父亲的width。 3 边框带来的麻烦因为边框不能用百分比来写，所以会带来麻烦： &lt;div&gt; &lt;p&gt;1&lt;/p&gt; → float: left;width:50%; border:1px solid red; &lt;p&gt;2&lt;/p&gt; → float: left;width:50%; border:1px solid red; &lt;/div&gt; p就不能浮动成功，因为总宽度已经是100%多了4个px。 此时边框不能写成百分比，所以就不好减！ div{ width: 80%; height: 200px; margin: 0 auto; background-color: #eee; } p{ float: left; width: 50%; → 这里不能轻松减去2px height: 200px; background: orange; border: 1px solid #000; } 谁说不能？！CSS3中增加了calc函数： div{ width: 80%; height: 200px; margin: 0 auto; background-color: #eee; } p{ float: left; width: calc(50% - 2px); → 谁说不能？！CSS3中增加了calc函数 height: 200px; background: orange; border: 1px solid #000; } 使用的时候一定要在运算符前后加上空格： calc(50%-2px); 应该是 calc(50% - 2px); 兼容性不好，至少安卓4.4还不是特别兼容。 4 CSS3新的盒模型我们之前的盒模型padding、border、margin都是外扩的， div{ width : 200px; height : 200px; padding:10px 20px 30px 40px; } 此时真实面积： 260 × 240 此时加上： div{ width : 200px; height : 200px; padding:10px 20px 30px 40px; box-sizing:border-box; } box表示“盒子”，sizing“尺寸”，“border-box”表示border这一圈的宽度、高度。 此时padding就是内减的，而不是外扩的了： 但是border还是在外面： div{ width : 200px; height : 200px; box-sizing:border-box; padding:10px 20px 30px 40px; border-top:10px solid red; border-left:20px solid red; border-right:30px solid red; border-bottom:40px solid red; margin: 10px; }","categories":[{"name":"移动web","slug":"移动web","permalink":"http://yoursite.com/categories/移动web/"}],"tags":[{"name":"移web","slug":"移web","permalink":"http://yoursite.com/tags/移web/"}]},{"title":"Less语法的使用简介","slug":"title32","date":"2016-11-27T09:27:56.000Z","updated":"2017-02-20T10:35:48.947Z","comments":true,"path":"2016/11/27/title32/","link":"","permalink":"http://yoursite.com/2016/11/27/title32/","excerpt":"","text":"1 概述PHP和HTML的关系就是LESS和CSS的关系。 PHP是超文本预处理器 &lt;h1&gt;好高兴啊，我买了一个iPhone&lt;?php echo 3+4; ?&gt;&lt;/h1&gt; 编译为： &lt;h1&gt;好高兴啊，我买了一个iPhone7&lt;/h1&gt; LESS也是CSS预处理器： @a : 100px; div{ width:@a; } 编译为： div{ width:100px; } 用的时候还是用CSS！浏览器不能直接渲染PHP、不能直接渲染Less，必须转为HTML、CSS之后才能渲染。但是写的时候PHP就是比HTML厉害，Less就是比CSS厉害。 2 浏览器编译试着写一个a.less文件： @a : 200px; div{ width:@a; } @a表示定义一个变量。 Less现在先解决编译的问题，然后再学习语法！ 编译有两种，浏览器编译是最简单的： &lt;link rel=&quot;stylesheet/less&quot; type=&quot;text/css&quot; href=&quot;a.less&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/less.js&quot;&gt;&lt;/script&gt; 此时这个js文件就会发出Ajax请求，去请求a.less文件，此时会把返回的文本，用正则表达式进行编译。编译好的内容，直接内嵌到当前HTML文件中。 3、服务器端编译使用nodejs编译less。 nodejs是一个js的运行环境，可以让js运行在服务器端。原来js运行在浏览器中，JS现在开始可以和PHP、ASP、JSP平起平坐！ 4 less编译工具的安装（手动编译）所以有很多人发明了一些工具，发布出去了，发布到了npm的世界中，nodejs package management，nodejs包管理器。安装完node之后，npm已经被自动安装了。我们可以使用npm命令，轻松的从互联网上下载各式各样的nodejs程序。 npm install命令表示通过连接互联网，从网上下载工具，我们下载的就是less工具。 npm install表示安装，-g表示安装到全局，每个人的全局地址都不一样，请通过 npm root -g来查看 装好less处理器之后，就能通过lessc命令来编译less文件了。 5 利用Grunt自动监控less文件自动编译 Grunt是一个自动化构建工具，依赖NodeJS，说白了就是NodeJS程序而已。要使用Grunt必须现在系统的全局安装grunt-cli程序，cli就是命令行界面的意思。 需要先安装grunt-cli程序，打开系统CMD，输入下面的命令（保证计算机已经联网）： npm install -g grunt-cli 不要忘记-g，必须装在全局。 此时，你的神秘全局文件夹中就有了，此时你就可以在CMD中输入grunt命令而不会报错了。 现在，我们要安装grunt，刚才安装的是grunt-cli，此时来到你的项目文件夹中，注意这句话，来到你的项目文件夹中。 cd 你的项目路径 然后在这个文件夹中安装grunt，不要加-g。 npm install grunt 此时你的项目文件夹中就会出node_modules文件夹： 接下来我们就要告诉Grunt你要做什么，所以我们建立一个Gruntfile.js的文件，告诉Grunt你的任务。注意这个文件的名字不能换！ 下面就是这个Gruntfile.js的代码清单： 配置任务，列出了三个任务：pkg、less、watch。pkg任务是必须写的；less任务就是编译less的任务，watch任务就是监控任务。 部分在罗列插件。grunt-contrib-less、grunt-contrib-watch。 部分是事务队列、清单。 module.exports = function (grunt) { //任务配置,所有插件的配置信息 grunt.initConfig({ pkg: grunt.file.readJSON(&apos;package.json&apos;), //less插件配置 less: { main: { expand: true, src: [&apos;less/*.less&apos;], //核心语句，编译less dest: &apos;desc&apos;, ext: &apos;.css&apos; }, dev: { options: { compress: true, yuicompress:false } } }, watch: { scripts: { files: [&apos;less/*.less&apos;], tasks: [&apos;less&apos;] } } }); //告诉grunt我们将使用插件 grunt.loadNpmTasks(&apos;grunt-contrib-less&apos;); grunt.loadNpmTasks(&apos;grunt-contrib-watch&apos;); //告诉grunt当我们在终端中输入grunt时需要做些什么(注意先后顺序) grunt.registerTask(&apos;default&apos;, [&apos;less&apos;,&apos;watch&apos;]); }; 在项目文件夹里面再次放入一个package.json的文件： { &quot;name&quot;: &quot;text&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;devDependencies&quot;: { &quot;grunt&quot;: &quot;~0.4.5&quot;, &quot;grunt-contrib-less&quot;: &quot;~0.10.0&quot; } } 插件还没有装呢！所以要在项目文件夹中， npm install grunt-contrib-less npm install grunt-contrib-watch 如果全部操作都正确的话，此时你可以在项目文件的CMD中，输入grunt一个单词，可以实时监控你的less文件夹中的less文件。实时编译到dest文件夹中。 6、Less语法http://less.bootcss.com/ 变量： @hong : rgb(252,0,0); div{ background: @hong; border-top: 1px solid @hong; box-shadow: 1px 1px 1px 1px @hong; } 选择器也可以用变量： @dahezideleiming : container; .@{dahezideleiming}{ width:100px; } 文件路径： @imagesURL : &quot;../images&quot;; background: url(&quot;@{imagesURL}/1.jpg no-repeat center center&quot;); 导入文件： @import &quot;01.less&quot;; @import &quot;02.less&quot;; 属性也能用变量： @property: color; .widget { @{property}: #0ee; background-@{property}: #999; } 混合： .xiao{ width: 200px; height: 200px; } .cu{ font-weight: 500; } .xian{ text-decoration: underline; } .zhongyao{ .cu(); .xian(); } 嵌套： nav{ width:100px; height:100px; ul{ float:left; } } 可以接受参数，类似一个函数： .yuanjiao(@dushu){ -webkit-border-radius: @dushu; -moz-border-radius: @dushu; -ms-border-radius: @dushu; -o-border-radius: @dushu; border-radius: @dushu; } when逻辑判断： .haha(@a) when (@a &gt; 100){ width:300px; height: 300px; } .haha(@a) when (@a &lt; 100){ width:200px; height: 200px; } div{ .haha(900); } 编译之后： div { width: 300px; height: 300px; } 循环语句： .zihao(@n) when (@n =&lt; 60) { .fs@{n}{ font-size:1px * @n; } .zihao(@n + 1); } .zihao(10);","categories":[{"name":"Less","slug":"Less","permalink":"http://yoursite.com/categories/Less/"}],"tags":[{"name":"Less","slug":"Less","permalink":"http://yoursite.com/tags/Less/"}]},{"title":"PHP操作SQL语言","slug":"title34","date":"2016-11-26T09:27:56.000Z","updated":"2017-02-20T12:51:31.541Z","comments":true,"path":"2016/11/26/title34/","link":"","permalink":"http://yoursite.com/2016/11/26/title34/","excerpt":"","text":"1 SQL语言数据库的增删改查操作，CRUD操作。 C create增加，创建 R read 查找，访问 U update 更改 D delete 删除要使用SQL语言对数据库进行CRUD操作。SQL就是Structure Query Language结构化查询语言。是操作数据库的语言，注意，这个语言是使用的软件平台无关。比如你用ASP、PHP、JSP都要使用相同的SQL语言。 2 查询看好SQL语句在哪里输入： 查询所有表中的条目： SELECT * FROM 表名字 比如： 查询banji0910表中的所有条目： SELECT * FROM banji0910 查询banji0910表中的所有条目的姓名： SELECT xingming FROM banji0910 可以后缀WHERE子句，查找banji0910中所有男生 SELECT * FROM banji0910 WHERE xingbie = “男” 可以加上与或逻辑，AND表示且，OR表示或查找banji0910中所有男生且年龄大于11岁 SELECT * FROM banji0910 WHERE xingbie = ‘男’ AND nianling 11 注意，字符串用单引号包裹；注意，等号就是相等的意思。 可以排序，查找banji0910中所有男生，并按年龄倒叙： SELECT * FROM banji0910 WHERE xingbie = “男” ORDER BY nianling DESC 3 增加条目用INSERT语句插入条目： INSERT INTO banji0910 VALUE (‘小青’,9,’女’,324234); 如果不是想插入所有的字段，必须罗列所有的字段： INSERT INTO banji0910 (xingming,nianling,xingbie) VALUE (‘小宝’,9,’男’) 3 改变条目更改小红的性别为男： UPDATE banji0910 SET xingbie = “男” WHERE xingming = “小红” 更改所有年龄大于等于10的人性别为女： UPDATE banji0910 SET xingbie = “女” WHERE nianling &gt;= 10 4 删除条目删除小明： DELETE FROM banji0910 WHERE xingming = “小明” 删除所有女生： DELETE FROM banji0910 WHERE xingbie = ‘女’ 5 SQL的备份和恢复我的数据库想给你，不能通过U盘直接把数据库拷贝走，因为数据库在计算机的多个文件夹中分布。只能在我的电脑里面把数据库备份为SQL文件，传递给你SQL文件，你执行SQL文件就行了。 备份数据库为SQL文件 从SQL文件恢复： 记住要刷新 6、PHP操作数据库数据库自己用没有意义，可以提供给多种语言使用，SQL就是中间的一层。 LAMP沆瀣一气，Linux、Apache、MySQL、PHP，他们四个非常亲，彼此非常打通。PHP中仅仅几条语句就能操作数据库： &lt;?php //链接数据库。参数：数据库地址、用户名、密码 mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;123456&quot;); //选择操作哪个数据库 mysql_select_db(&quot;student&quot;); //识别中文 mysql_query(&quot;SET NAMES UTF8&quot;); //写SQL语句 $sql = &quot;INSERT INTO banji0910 VALUE (&apos;宝宝&apos;,12,&apos;男&apos;,1932434)&quot;; //执行SQL mysql_query($sql); ?&gt; 使用了里面的诸多内置函数，他们都是mysql开头的。php就是这样，把内置函数都加上了前缀，比如数组的方法，都是array开头，关于数据库的函数都是mysql_开头。 mysql_connect : 链接数据库 mysql_select_db : 选择数据库 mysql_query : 执行查询 比较复杂的是，从数据库中读取数据： &lt;?php mysql_connect(&quot;localhost&quot;,&quot;root&quot;,123456); mysql_select_db(&quot;student&quot;); mysql_query(&quot;SET NAMES UTF8&quot;); //准备一条sql $sql = &quot;SELECT * FROM banji0910&quot;; //执行sql语句，此时的结果是类数组对象 $result = mysql_query($sql); //把结果转为数组 $row = mysql_fetch_array($result); //输出 print_r($row); //把结果转为数组 $row = mysql_fetch_array($result); //输出 print_r($row); //把结果转为数组 $row = mysql_fetch_array($result); //输出 print_r($row); ?&gt; 如果是SELECT语句执行，此时的结果是类数组对象。必须使用mysql_fetch_array()来转为数组。此时比较坑的是，转的时候只能转一条，此时如果想转第二条，必须再来一次mysql_fetch_array();执行完毕SQL之后拿到类数组对象，我们一般来说用while语句去循环得到所有数组： &lt;?php mysql_connect(&quot;localhost&quot;,&quot;root&quot;,123456); mysql_select_db(&quot;student&quot;); mysql_query(&quot;SET NAMES UTF8&quot;); //准备一条sql $sql = &quot;SELECT * FROM banji0910&quot;; //执行sql语句，此时的结果是类数组对象 $result = mysql_query($sql); //把结果转为数组 while($row = mysql_fetch_array($result)){ //输出 print_r($row); } ?&gt; 注意，每个$row都是一个数组，并且里面有数字下标，也有别名下标。 &lt;?php mysql_connect(&quot;localhost&quot;,&quot;root&quot;,123456); mysql_select_db(&quot;student&quot;); mysql_query(&quot;SET NAMES UTF8&quot;); //准备一条sql $sql = &quot;SELECT * FROM banji0910&quot;; //执行sql语句，此时的结果是类数组对象 $result = mysql_query($sql); //把结果转为数组 while($row = mysql_fetch_array($result)){ //输出 echo $row[&quot;xingming&quot;] . &quot;&lt;br /&gt;&quot;; } ?&gt; 主键的概念，姓名能够重复，但是id不能重复。id就是主键，不重复的字段就是主键。 查看信息的超级链接，是样子写的： &lt;td&gt;&lt;a href=&quot;ziliao.php?id=&lt;?php echo $row[&apos;id&apos;]; ?&gt; &quot;&gt;查看信息&lt;/a&gt;&lt;/td&gt;","categories":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/categories/SQL/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"PHP后台语言介绍","slug":"title31","date":"2016-11-25T09:27:56.000Z","updated":"2017-02-20T10:35:33.853Z","comments":true,"path":"2016/11/25/title31/","link":"","permalink":"http://yoursite.com/2016/11/25/title31/","excerpt":"","text":"1 从一个实验说开去我们做一个实验，新建一个php文件（就是由txt变的）： &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;好高兴啊，我买了一个iPhone&lt;?php echo 1+2+3+1;?&gt;啊，真开心！&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; 我们直接在本地拖到浏览器里面查看，我么你发现红色部分浏览器没有渲染： 这是因为浏览器把&lt;?php ?&gt;当做注释了： 此时把1.php上传到服务器上，然后通过浏览器输入网址访问发现这个7被算出来了。此时我们查看源代码： 你会发现之前的&lt;?php ?&gt;里面的内容，变成了7，此时你根本察觉不到这个7从何而来。 2 后台语言后台语言就是执行在服务器上的语言，以php为例，在服务器上执行&lt;?php ?&gt;里面的语句，这个操作我们称为“预处理”。当php执行完毕之后，会发回给浏览器纯的、平的HTML文件。 PHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。它是一个后台语言，后台语言：● 在服务器上运行● 运行之后，发给浏览器就是不带任何后台标记的纯HTML了● 可以操作数据库 常见后台语言：PHP、JSP、ASP、.net、python、scala、node.js等等。 3、在自己的电脑上运行PHPPHP是后台语言，必须运行在服务器上，所以我们不便于调试，只能让自己的电脑也变为服务器。 Apache是世界上第一名的服务器软件，如果你安装了Apache你的电脑就是服务器了。 光安装Apache没有用，还要安装PHP的语言解析引擎。 MySQL是著名的数据库之一，免费开源。 中国人发明了三合一的安装包，叫做phpnow或者WampServer。我们学习phpnow，如果你电脑装不上phpnow，此时就安装wampserver。 4 运行php所有的php文件必须放到根目录运行，一定要通过127.0.0.1来运行，而不能直接把php拖入浏览器。 4.1 壳子所有的php程序要写在： &lt;?php ?&gt; 的壳子里面。 4.1 echo输出 &lt;h1&gt;我买了一个iPhone&lt;?php echo 3.5 * 2; ?&gt;我很开心&lt;/h1&gt; 注意echo是一个关键字，不是函数，所以不要加圆括号： echo(); 注意，php要求所有语句必须有分号结尾，没有分号致命。和JS一样，所有的字符串都要有引号包裹。 &lt;p&gt;&lt;?php echo &quot;你好&quot;; ?&gt;&lt;/p&gt; 4.3 变量PHP中的变量不需要定义，可以直接使用，变量必须以$开头，剩余部分的命名规范和JS一样。 &lt;?php $a = 100; echo $a; ?&gt; 注释和js一样。 &lt;?php // $a = 100; // $b = 200; // echo $a + $b; ?&gt; 连字符是.而不是加号。 &lt;?php $year = 2016; echo “今年是” . $year . “年”; ?&gt; 而在双引号中，用{$}的形式，可以不用连字符，来拼接变量和字符串： echo &quot;今年是{$year}年&quot;; 4.4 for语句、if语句、switch语句、while、do while语句 和js一样一样的,讲讲壳子： &lt;?php for($i = 0 ; $i &lt; 100 ; $i++){ ?&gt; &lt;p&gt;★&lt;/p&gt; &lt;?php } ?&gt; 页面上出现100个星星 4.5 函数和js一样一样。php中的函数不是构造函数，不能被new调用。 编写函数，检查一个数字是不是质数，并且用数字88来测试： &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php function checkZhishu($num){ $count = 0; for($j = 1 ; $j &lt;= $num ; $j++){ if($num % $j == 0){ $count ++; } } if($count == 2){ return true; }else{ return false; } } if(checkZhishu(88)){ echo &quot;是&quot;; }else{ echo &quot;不是&quot;; } ?&gt; &lt;/body&gt; &lt;/html&gt; 4.6 数组array()函数创建数组： &lt;?php $arr = array(&quot;东风&quot;,&quot;二条&quot;,&quot;大饼&quot;,&quot;幺鸡&quot;,&quot;六万&quot;); echo $arr[3]; ?&gt; php是所有语言中，方法第一多的语言！ 数组可以有别名，和js的json很像： &lt;?php $arr = array(&quot;xingming&quot; =&gt; &quot;小明&quot; , &quot;age&quot; =&gt; 12 , &quot;sex&quot; =&gt; &quot;男&quot;); echo $arr[&quot;sex&quot;]; ?&gt; 输出男。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://yoursite.com/tags/PHP/"}]},{"title":"Canvas基本用法","slug":"title29","date":"2016-11-24T09:27:56.000Z","updated":"2017-02-20T10:35:20.812Z","comments":true,"path":"2016/11/24/title29/","link":"","permalink":"http://yoursite.com/2016/11/24/title29/","excerpt":"","text":"1、Canvas概述 Canvas和Flash的思路完全不一样，Flash是上屏幕之后还是对象，编程语言叫做Action Script也是ECMAScript范畴。Canvas上屏幕之后像素化了，再也不能得到这个对象了，所以要想让这个元素运动，必须擦除整个屏幕、重绘这个元素。Canvas更流畅，手机端也嗷嗷流畅。 canvas是一个双标签，里面的内容是不支持canvas浏览器显示的内容： &lt;canvas width=&quot;800&quot; height=&quot;600&quot;&gt;对不起，你的浏览器不支持画布，请升级浏览器！&lt;/canvas&gt; 宽度、高度写在标签里面，如果写在css中，就变形、扭曲了。 编程： &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 ctx.fillStyle = &quot;lightseagreen&quot;; ctx.fillRect(100,100,300,200); &lt;/script&gt; 坐标系： API： ctx.fillStyle = &quot;red&quot;; //设置填充颜色 ctx.fillRect(100,100,300,200); //绘制一个填充矩形 2、笔触填充笔触也叫作“描边”，Canvas中的任何形状都是由这两个部分组成的。 笔触在canvas中视为一个“Path”的实例，必须stroke之后才能上屏幕；填充用fill才能上屏幕。 制作一个笔触需要用到的API： ctx.beginPath(); //开始绘制路径 ctx.closePath(); //自动封闭路径 ctx.moveTo(100,200); //将画笔移动到某一个点 ctx.lineTo(200,200); //用画笔划线，此时的参数是终点位置，起点就是画笔此时的位置 ctx.stroke(); //划线 比如： //得到画布标签 var myCanvas = document.querySelector(“#myCanvas”); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(“2d”); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.moveTo(100,100); ctx.lineTo(300,300); ctx.lineTo(600,300); ctx.moveTo(600,400); ctx.lineTo(700,400); ctx.stroke(); 在划线之前可以设置线的宽度和颜色： ctx.lineWidth = &quot;10&quot;; ctx.strokeStyle = &quot;red&quot;; ctx.stroke(); 当ctx上已经有一些path之后，此时调用fill()将自动填充。 &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.moveTo(100,100); ctx.lineTo(300,300); ctx.lineTo(600,300); ctx.closePath(); ctx.lineWidth = &quot;10&quot;; ctx.strokeStyle = &quot;red&quot;; ctx.stroke(); ctx.fillStyle = &quot;lightseagreen&quot;; ctx.fill(); &lt;/script&gt; 绘制新的形状的时候，要重新beginPath() &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.moveTo(100,100); ctx.lineTo(300,300); ctx.lineTo(600,300); ctx.closePath(); ctx.lineWidth = &quot;10&quot;; ctx.strokeStyle = &quot;red&quot;; ctx.stroke(); ctx.fillStyle = &quot;lightseagreen&quot;; ctx.fill(); ctx.beginPath(); ctx.moveTo(600,100); ctx.lineTo(600,200); ctx.lineTo(750,200); ctx.lineTo(790,40); ctx.closePath(); ctx.fillStyle = &quot;orange&quot; ctx.fill(); ctx.stroke(); &lt;/script&gt; fillRect()是一个快捷方法，让你省略了beginPath、moveTo、lineTo。所以fillRect (100,100,300,200)等价于： ctx.move(100,100); ctx.lineTo(400,100); ctx.lineTo(400,300); ctx.lineTo(100,300); ctx.closePath(); ctx.fill(); 3、弧和圆形画弧线用arc方法，它属于Path。所以画弧之前要beginPath()一下。 &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //开始绘制路径 ctx.beginPath(); ctx.arc(200,200,100,0,1,true); //圆心坐标200,200。100是半径。0开始角度，1终止角度，true表示逆时针 ctx.stroke(); &lt;/script&gt; 坐标系，Canvas中的角度都是弧度制，1弧度等于57.3度： 完整的圆终止角度就是Mathi.PI * 2 ctx.arc(200,200,200,0,Math.PI*2,false); 画20个同心圆。 for(var i = 10 ; i &lt;= 400 ; i+=5){ ctx.beginPath(); ctx.arc(200,200,i,0,Math.PI * 2,true); ctx.strokeStyle = &quot;rgb(&quot; + i + &quot;,&quot; + i + &quot;,&quot; + i + &quot;)&quot;; ctx.stroke(); } https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Applying_styles_and_colors 4、文字fillText函数用来写字，参数是：文字内容、坐标位置 ctx.fillText(&quot;文字内容&quot;,100,100); 可以使用font属性来调整字号和字形： ctx.font = &quot;50px 微软雅黑&quot;; ctx.fillText(&quot;你好&quot;,100,100); 5、new Image()使用图片使用图片有一个固定的语法，必须new Image()然后设置src，监听load事件，使用ctx.drawImage()函数上画布。 var img = new Image(); img.src = &quot;images/0.jpg&quot;; img.onload = function(){ ctx.drawImage(img,100,100); } ctx.drawImage()里面的参数是图片对象、左上角的坐标。 ctx.drawImage()里面可以有四个数字参数，增加了宽度、高度的设置，此时图片会被扭曲： var img = new Image(); img.src = &quot;images/0.jpg&quot;; img.onload = function(){ ctx.drawImage(img,100,100,250,80); } 如果要使用切片，就是9个参数： var img = new Image(); img.src = &quot;images/0.jpg&quot;; img.onload = function(){ ctx.drawImage(img,168,150,126,141,100,100,300,300); } 红色部分描述的是切片的事儿： 蓝色部分是上屏幕之后的事儿： 公式： ctx.drawImage(img,切片x,切片y,切片w,切片h,上屏x,上屏y,上屏w,上屏h); 6、运动canvas中元素不能运动的，因为上屏幕之后就再也得不到它了，没有任何变量能够持有一个: var box = ctx.fillRect(100,100,200,200); 必须重绘一个新的矩形！利用视觉暂留，形成运动！ 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 →清屏 → 更新 → 渲染 → 清屏 → 更新 → 渲染 →…… 清屏： ctx.clearRect(0,0,800,600); 实际上是清除一个矩形区域，我们一般清除整个画布。 面向对象制作运动，结构： function Circle(){ } Circle.prototype.render = function(){ } Circle.prototype.update = function(){ } var yuan = new Circle(); setInterval(function(){ ctx.clearRect(0,0,800,600); yuan.update(); yuan.render(); },20); 每一帧都要更新演员、渲染演员。只要这个东西是演员，它必须提供update、render方法。 面向接口编程，接口就是具有一定方法的类的集合。说白了，就比如说很多类都有render、update方法，此时Actor（演员）就是一个接口，Circle和Fang类都是这个接口的实现。“接口就是类的类”。 说白了：我们要制作Actor类，Actor类提供update、render方法，并且会把自己放入总数组中。所有演员类，都必须继承这个类，重写Actor和render方法。","categories":[{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/categories/Canvas/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/tags/Canvas/"}]},{"title":"游戏开发中canvas常见要点","slug":"title30","date":"2016-11-24T09:27:56.000Z","updated":"2017-02-20T10:35:27.067Z","comments":true,"path":"2016/11/24/title30/","link":"","permalink":"http://yoursite.com/2016/11/24/title30/","excerpt":"","text":"1 游戏图片、音乐资源的管理不管游戏中有多少元素在运动，游戏仅仅有1个定时器，这1个定时器让所有的演员更新、渲染。实际上，一个游戏需要大量的图片，只有当所有图片都load了，游戏才能开始。换句话说，只有当所有图片都load了，主循环setInterval()才能启动。 所以我们的思路就是用JSON imagesObj 存放所有的资源图片的名字，用循环语句for..in…去创建他们的Image对象，然后监听他们的load事件，load一个计数器加1，当load完一个图片的时候，计数器正好等于了数组总长度，此时表示所有图片加载完毕。比较巧妙的是，我们创建了一个R对象，这个对象和imagesObj 的key是一样的，但是v是图片的Image实体，用图片的时候，要通过R打点来找到图片。 &lt;script type=&quot;text/javascript&quot;&gt; //得到画布标签 var myCanvas = document.querySelector(&quot;#myCanvas&quot;); //上下文，就相当于打开Photoshop之后让你新建画布 var ctx = myCanvas.getContext(&quot;2d&quot;); //今后的操作都是这个画布的事情，都是ctx的事情，和myCanvas没有关系了。 //如果要使用图片，必须要创建一个Image的实例，然后监听这个img的load事件 //只有load的图片才能上画布 var imagesObj = { &quot;shibing&quot; : &quot;images/shibing.png&quot;, &quot;baozha&quot; : &quot;images/baozha.png&quot; }; //图片资源对象，k和imagesObj是一样的，v是真正的图片Image对象 var R = {}; //已经加载好的图片个数 var count = 0; var cutx = 0; var baozhaxuhao = 0; for(var k in imagesObj){ //创建图片节点 R[k] = new Image(); //设置src R[k].src = imagesObj[k]; //监听是否load R[k].onload = function(){ count++; if(count === 2){ //全部都加载完毕 setInterval(function(){ cutx ++; baozhaxuhao++; if(cutx &gt; 7){ cutx = 0; } if(baozhaxuhao &gt; 11){ baozhaxuhao = 0; } //清屏 ctx.clearRect(0, 0, 800, 600); ctx.drawImage(R.shibing,120 * cutx,150 * 3,120,150,100,100,120,150); ctx.drawImage(R.baozha,192 * (baozhaxuhao % 5),192 * parseInt(baozhaxuhao / 5),192,192,100,100,192,192); },20); } } } &lt;/script&gt; 2、Game类Game类就是中介者模式中的中介者 ##。中介者就是全局变量！比如我们以前 var idx = 10; 信号量，就是全局变量，现在把这个量放入一个类的实例身上，此时这个类就是中介者。 信号量在中介者身上： var game = new Game(); game.idx = 10; 以后所有的元素都是Game类new出来的，我们只需要new出中介者，其他元素都是Game帮我们new出来的。 其他元素如果要互相通信，要通过Game类： game.bird.y 在HTML5游戏中，Game类还将有：主循环、游戏资源管理两个任务。 图片资源管理利用两个对象，RObj和R对象。Robj就是Ajax请求来的文本转为的对象，v是路径； R对象的拥有Robj相同的k，但是v是真实对象： 3 背景类背景类的实例化在Game的start函数里面。而start函数的调用的前提是所有资源已经加载完毕了。说白了，背景类里面可以直接使用图片资源。 canvas里面也有猫腻，也有模式。渲染三张，目的是无缝连续滚动，当猫腻图的左边框到达0点，就拉回来。 4、cancas变形canvas中，提供了变形属性，需要注意的是，所有的变形都是针对画布上下文ctx对象的，而不是某一个要绘制的元素的。 &lt;script type=&quot;text/javascript&quot;&gt; var mycanvas = document.getElementById(&quot;mycanvas&quot;); var ctx = mycanvas.getContext(&quot;2d&quot;); //保存当前的上下文状态 ctx.save(); //移动坐标系 ctx.translate(100,100); //画圆 ctx.fillStyle = &quot;blue&quot;; ctx.beginPath(); ctx.arc(0,0,50,0,Math.PI * 2,true); ctx.fill(); //恢复上下文存档状态 ctx.restore(); //画方块 ctx.fillRect(100, 100, 100, 100); &lt;/script&gt; 坐标系还可以通过 ctx.rotate(1); 渲染1弧度。同样的，旋转的是整个坐标系，而不是某一个元素。 &lt;script type=&quot;text/javascript&quot;&gt; var mycanvas = document.getElementById(&quot;mycanvas&quot;); var ctx = mycanvas.getContext(&quot;2d&quot;); ctx.rotate(1); //1弧度，顺时针 ctx.fillStyle = &quot;orange&quot;; ctx.fillRect(100, 100, 100, 100); &lt;/script&gt; 如果想要让一个元素以自己的几何中心点旋转，此时需要： ① 先让坐标系的原点移动到它的中心点，此时盒子的渲染位置就是负的自己的宽度的一半，负的自己的高度的一半。 ② 旋转 公式： t指的是开始下落后的时间，此时小鸟就要维护自己的小帧号birdF。 //物理公式：s = 1/2gt^2 //掉 birdF++; birdY = 100 + 1.3 * birdF * birdF; birdRotate+=0.08; 5、碰撞检测AABB盒是英语Axis Aligned Bounding Box 轴对齐包围盒。 //更新自己的碰撞检测盒 this.A = this.y + 7; this.B = this.x + 41; this.C = this.y + 41; this.D = this.x + 7; 所谓的ABCD都是边的x或者y，横边就取y值，纵边就取x值。碰撞检测： if( game.bird.A &lt; this.C1 &amp;&amp; game.bird.B &gt; this.D1 &amp;&amp; game.bird.D &lt; this.B1 || game.bird.C &gt; this.A2 &amp;&amp; game.bird.B &gt; this.D2 &amp;&amp; game.bird.D &lt; this.B2 ){ console.log(&quot;撞！&quot;); clearInterval(game.timer); } 6、合成canvasctx.globalCompositeOperation = type 一共有12种值，表示新画的图形和老图形的关系，称为“合成”。 比如： ctx.fillStyle = &quot;blue&quot;; ctx.fillRect(100,100,100,100); ctx.globalCompositeOperation = &quot;source-in&quot;; ctx.beginPath(); ctx.arc(180,180,50,0,7,false); ctx.fillStyle = &quot;red&quot;; ctx.fill(); 像素操作到目前为止，我们尚未深入了解Canvas画布真实像素的原理，事实上，你可以直接通过ImageData对象操纵像素数据，直接读取或将数据数组写入该对象中。稍后我们也将深入了解如何控制图像使其平滑（反锯齿）以及如何从Canvas画布中保存图像。 得到像素： var myImageData = ctx.getImageData(0,0,560,300); 0,0表示起点位置，560是宽度，300是高度。 得到的值可以被使用作为查看初始像素数据。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是”RGBA”格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。 7、事件监听canvas上必须检测范围，因为得不到元素。 贝塞尔曲线： ctx.moveTo(100,100); ctx.bezierCurveTo(200, 50, 400, 50, 400, 100); ctx.stroke(); 点击鼠标的时候，要遍历每个元素，看看点击到了谁，点击到的这个元素，就存入变量。然后让变量中的元素x、用、跟随你的鼠标变化即可。 if(x &gt; ctrl1.x - 5 &amp;&amp; x &lt; ctrl1.x + 5 &amp;&amp; y &gt; ctrl1.y - 5 &amp;&amp; y &lt; ctrl1.y + 5){ diandaodedian = ctrl1; } if(x &gt; ctrl2.x - 5 &amp;&amp; x &lt; ctrl2.x + 5 &amp;&amp; y &gt; ctrl2.y - 5 &amp;&amp; y &lt; ctrl2.y + 5){ diandaodedian = ctrl2; } if(x &gt; start.x - 5 &amp;&amp; x &lt; start.x + 5 &amp;&amp; y &gt; start.y - 5 &amp;&amp; y &lt; start.y + 5){ diandaodedian = start; } if(x &gt; end.x - 5 &amp;&amp; x &lt; end.x + 5 &amp;&amp; y &gt; end.y - 5 &amp;&amp; y &lt; end.y + 5){ diandaodedian = end; } 8、场景Scene管理开始画面、游戏过程、结束画面。 场景现在开始接手管理自己的演员！！但是，场景还是应该把演员注册到game身上，但是管理的权限、谁上台、谁下台，是场景管理器的任务。 监听都是场景管理器负责注册！！ http://squishybird.com/ http://so2.4399.com/","categories":[{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/categories/Canvas/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"http://yoursite.com/tags/Canvas/"}]},{"title":"常见字符串、数组算法","slug":"title28","date":"2016-11-22T09:27:56.000Z","updated":"2017-02-20T12:50:49.393Z","comments":true,"path":"2016/11/22/title28/","link":"","permalink":"http://yoursite.com/2016/11/22/title28/","excerpt":"","text":"常见字符串算法1、短横变驼峰把单词border-left-color变为borderLeftColor。 此时有两种方法： 方法1：border-left-color用字符串的split方法变为数组：[“border”,”left”,”color”]，然后遍历这个数组第1项开始的每项，把首字母toUpperCase()变为大写然后与剩余字母连接，然后join到一起，就是borderLeftColor。 // 短横变驼峰函数 function change(str){ //拆为数组 var strArr = str.split(&quot;-&quot;); //遍历数组 for(var i = 1 ; i &lt; strArr.length ; i++){ var chars = strArr[i]; //将数组的这一项的字符串变为首字母变为大写，与剩余字母做拼接 strArr[i] = chars[0].toUpperCase() + chars.slice(1); } //拼接 return strArr.join(&quot;&quot;); } 方法2：正则表达式。border-left-color用正则表达式去replace替换，替换什么？替换所有(-字母)变为大写字母。 var str = &quot;我爱周杰伦，周杰伦很帅，我要和周杰伦生猴子&quot;; str = str.replace(/周杰伦/g,&quot;杨洋&quot;); console.log(str); var str = &quot;我买了一个手机3000元，电脑5000元，电饭锅100元。今天很热，18度。&quot;; str = str.replace(/(\\d+)元/g,function(match,$1,index){ return parseInt($1 / 6) + &quot;美元&quot;; }); console.log(str); var str = &quot;border-left-color&quot;; str = str.replace(/\\-(\\w)/g,function(match,$1){ return $1.toUpperCase(); }); console.log(str); 2 、寻找连续三项相同字符串现在给你一个字符串，判断里面有没有连续三位或者三位以上相同，如果有，就返回下标数组。 比如： “aabbbccddddee” 返回[2,3,4,7,8,9,10]。 双指针法。在字符串的题目中，基本99%都能用双指针法，比如最大连续相同子串、最大连续重复子串等等，都能用双指针法。 &lt;script type=&quot;text/javascript&quot;&gt; var str = &quot;aabbbccddddee&quot;; //位置是0、1 var i = 0; var j = 1; //结果 var result = []; while(i &lt; str.length){ if(str[i] != str[j]){ //判断是不是到了3位 if(j - i &gt;= 3){ //为位号推入数组 for(var m = i; m &lt;= j-1 ; m++){ result.push(m); } } //i追上j，j后移一位 i = j; } //不管怎么样j都要后移 j++; } console.log(result); &lt;/script&gt; 3 给数字加上千分位符输入12345678901，返回”12,345,678,901”。 数组和字符串的相互转换方法很好用，要敏感一些！实际上就是[12,345,678,901]进行join(“,”)就是结果。所以问题就简化为把12345678901这个数字拆分为数组！数组长度11。 找找规律： 12345678901 str.slice(-3) → 很特殊，没有第二个参数 12345678901 str.slice(-6,-3) 12345678901 str.slice(-9,-6) 12345678901 str.slice(-12,-9) 程序： &lt;script type=&quot;text/javascript&quot;&gt; var num = 12433245245432; //除了null、undefined之外的任何字面量都有toString()方法，表示变为字符串 var length = num.toString().length; //循环终点 var end = -Math.ceil(length / 3) * 3; //结果数组，把特殊的末尾三位放入数组 var result = [num.toString().slice(-3)]; //遍历-6、-9、-12、-15…… //截取的是slice(-6,-3) slice(-9,-6) slice(-12,-9) for(var i = -6 ; i &gt;= end ; i-=3){ result.unshift(num.toString().slice(i,i+3)); } //把数组变为字符串 console.log(result.join(&quot;,&quot;)); &lt;/script&gt; 还可以用正则表达式，我们慢慢推导： \\B是一个特殊的正则的东西，表示字母边界，非单词边界。\\b表示单词边界。 &lt;script type=&quot;text/javascript&quot;&gt; var str = &quot;abc,adsf haha xixi&quot;; str = str.replace(/\\B/g,&quot;★&quot;); console.log(str); &lt;/script&gt; 出现★的地方就是字母边界 然后说正则中的(?=)语法，表示定语从句，位置描述。 比如，我们想替换字符串中所有后面是“你”字的“爱”字. var str = &quot;我爱你，你却爱着他&quot;; str = str.replace(/爱(?=你)/g,&quot;★&quot;); console.log(str); 替换字符串中所有后面有“3位数字”的字母\\B ： var str = &quot;12324324324&quot;; str = str.replace(/\\B(?=\\d{3})/g,&quot;★&quot;); console.log(str); 比较乱，因为我们没有限制边界 替换字符串中所有后面到单词结尾有“3位数字”的\\B ： var str = &quot;12324324324&quot;; str = str.replace(/\\B(?=\\d{3}$)/g,&quot;★&quot;); console.log(str); 替换字符串中所有后面到单词结尾有一个或多个“3位数字”的\\B ： var str = &quot;12324324324&quot;; str = str.replace(/\\B(?=(\\d{3})+$)/g,&quot;★&quot;); console.log(str); 这就是答案，只需要把★改为逗号即可。 常见数组算法数组没有indexOf方法，也就是说我给你一个数组，问你这个数组中没有一个项是数字6，你必须遍历所有项目，一个项目一个项目的比对，是不是数字6。 1 数组的去重给你一个数组[3,4,6,32,2,3,4,57,6] 返回去掉重复项的数组[3,4,6,32,2,57]。难点就是验证数字是不是已经在数组中了，而如果要遍历，产生的时间复杂度是很高的。 大家的普遍算法就是，创建一个新的空数组[]，然后遍历原数组，遍历到原数组的每一项的时候，再遍历新的这个数组依次比对，如果新数组中没有这个项，就push进去。 var arr = [3,4,6,32,2,3,4,57,57,6]; var result = []; for(var i = 0 ; i &lt; arr.length ; i++){ for(var j = 0 ; j &lt; result.length ; j++){ //如果遇见相同的数字，立即终止内层循环 if(arr[i] == result[j]) break; } //验收，看看是不是result中的每一项都不等于arr[i] if(j == result.length){ result.push(arr[i]); } } console.log(result); 我们可以升级，升级为可以对原来的数组排序，把[3,4,6,32,2,3,4,57,6] 先排序，变为[2, 3, 3, 4, 4, 6, 6, 32, 57]。 再次做一个结果空数组[]，把数组中的每一项和结果数组中的最后一项进行比较，如果不同就说明真的不同了。 方法3是我们要着重介绍的，就是给数组简历一个索引对象。我们创建一个空对象，{}。每次验证对象中有没有这个项，如果没有就push进入result数组，同时把对象中创建一个属性就是你这个数字，值设为1。 {&quot;3&quot; : 1 , &quot;4&quot; : 1 , &quot;6&quot; :1 , &quot;32&quot;:1 , &quot;2&quot;:1 , &quot;57&quot;:1} 哲学就是用对象弥补数组没有indexOf的缺陷！ var arr = [3,4,6,32,2,3,4,57,6]; var temp = {}; var result = []; for(var i = 0 ; i &lt; arr.length ; i++){ //检查对象中有没有这个属性，如果没有这个属性，那么推入结果数组，并且让对象添加这个属性。属性值设置为1。 if(!temp[arr[i]]){ result.push(arr[i]); temp[arr[i]] = 1; } } console.log(result); console.log(temp); 2 数组的差集返回在arr1里面但是不在arr2里面的项，比如： arr1是[1,2,3,4,5,3] arr2是[3,4,5,6,7] 返回[1,2] 根据我们刚才数组去重的经验，我们可以先遍历arr2，设置一个空对象，把arr2的所有值作为这个对象的属性添加上。然后遍历arr1的时候，只需要看对象身上有没有这个属性即可。","categories":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/categories/字符串/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"animate常见知识","slug":"title27","date":"2016-11-20T09:27:56.000Z","updated":"2017-02-20T10:34:55.244Z","comments":true,"path":"2016/11/20/title27/","link":"","permalink":"http://yoursite.com/2016/11/20/title27/","excerpt":"","text":"1、概述animate是动画的意思。是jQuery自己的一个运动方法。非常好用的方法。 原生js动画必须依靠setInterval，根据步长和间隔时间来操作运动。 animate动画方法内部给我们用setInterval已经封装好了。不用自己去计算步长。 方法通过两个参数决定运动的结束位置和总时间。 语法： 1 .animate(结束位置JSON，运动总时间) 第一个参数必须是JSON对象：即便只有一个属性变化也需要写在JSON。 第二个参数是总时间：经过多长时间运动停止，习惯给一个变量during。 原来JS的代码： 1 var demo = document.getElementById(&quot;demo&quot;); 2 var now = 100; 3 var timer = setInterval(function(){ 4 now += 10; 5 if(now &gt;= 400){ 6 now = 400; 7 clearInterval(timer); 8 } 9 demo.style.width = now + &quot;px&quot;; 10 },50); jQuery的方法： 1 $(&quot;.demo&quot;).animate({&quot;width&quot;:400},1500); 什么样的css属性能够做animate动画。 很多属性值为数值的属性可以参与运动。css3里面也有一部分可以参与，大部分不能参与的。 不能参与的： “background-color” : “red” //css3的过渡动画可以完成 “background-position”:”0 0” 1 //jQuery的运动函数方法 2 $(“.demo”).animate({ 3 “width”:200, 4 “height”:200, 5 “opacity”:0.5, 6 “border-width”:20, 7 “left”:200, 8 “top”:200, 9 “padding”:50, 10 “border-radius”:”50%”, 11 //不能参与动画 12 //“background-color” : “red”//css3的过渡动画可以完成 13 //“background-position”:”0 0” 14 },400); 2、动画排序①同一个元素身上的运动有一个叫做“动画排队”的现象。 如果同一个元素，身上加了多个运动函数，会进行排队，谁先写的，谁先动。 1 $(&quot;.demo&quot;).animate({&quot;left&quot;:600},during); 2 $(&quot;.demo&quot;).animate({&quot;top&quot;:400},during); 3 $(&quot;.demo&quot;).animate({&quot;left&quot;:0},during); 4 $(&quot;.demo&quot;).animate({&quot;top&quot;:0},during); 给一个元素添加事件中有运动函数，多次触发事件也会造成动画排队。知道最后一个事件动画结束。 1 $(&quot;.demo&quot;).mouseenter(function(){ 2 $(this).children(&quot;p&quot;).slideDown(during); 3 }); 4 $(&quot;.demo&quot;).mouseleave(function(){ 5 $(this).children(&quot;p&quot;).slideUp(during); 6 }); ②不同元素之间都有动画，不会排队。 原理：animate函数封装时，用的是setInterval异步语句。同一个元素的动画有一个函数节流操作。 animate就是一个异步语句，异步语句在执行的时候，不会影响后面语句的执行。 1 $(&quot;.demo1&quot;).animate({&quot;left&quot;:600},during); 2 $(&quot;.demo1&quot;).animate({&quot;top&quot;:400},during); 3 $(&quot;.demo1&quot;).animate({&quot;left&quot;:0},during); 4 $(&quot;.demo1&quot;).animate({&quot;top&quot;:0},during); 5 $(&quot;.demo2&quot;).animate({&quot;left&quot;:600,&quot;top&quot;:400},during); ③不是动画的语句，也不会等待。 1 $(&quot;div p&quot;).css(&quot;display&quot;,&quot;block&quot;); 3、异步语句和回调函数animate运动方法就是一个异步语句，我们也可以给它一个回调函数，告诉我们运动结束之后我可以做什么事。 animate方法有一个回调函数的参数，第三个参数可以传递一个回调函数。 1 $(&quot;.demo1&quot;).animate({&quot;top&quot;:0},during,function(){ 2 $(&quot;.demo1 p&quot;).css(&quot;display&quot;,&quot;block&quot;); 3 }); 4 $(&quot;.demo2&quot;).animate({&quot;left&quot;:600,&quot;top&quot;:400},during,function(){ 5 $(&quot;.demo2 p&quot;).css(&quot;display&quot;,&quot;block&quot;); 6 }); 其他的运动方法也有回调函数： slideDown()、slideUp()、fadeIn()、fadeOut()、show(1000)、hide(1000)这几个方法也是运动的方法，都有一个回调函数。 1 $(&quot;.demo1 p&quot;).slideDown(500,function(){ 2 alert(&quot;出现啦&quot;); 3 }); 4、delay()延迟动画所有的动画语句都可以在前面有一个延迟语句。表示这条语句执行之后，动画不是立即执行，要等待一段时间再执行。 书写位置：在动画语句之前。 参数：规定的是延迟时间。 1 $(&quot;.demo2&quot;).delay(2000).animate({&quot;left&quot;:600,&quot;top&quot;:400},during,function(){ 2 $(&quot;.demo2 p&quot;).css(&quot;display&quot;,&quot;block&quot;); 3 }); 只要是动画方法都可以写delay延迟。 slideDown()、slideUp()、fadeIn()、fadeOut()、show(1000)、hide(1000)都可以进行延迟。 1 $(&quot;.demo2 p&quot;).delay(1000).slideDown(1000); 2 $(&quot;.demo2 p&quot;).delay(1000).slideUp(1000); 要想延迟一个运动，前面必须每次都加delay。 写法等价于： 1 $(&quot;.demo2 p&quot;).delay(1000).slideDown(1000).delay(1000).slideUp(1000); 5、stop()停止动画可以停止我们的动画。 两个参数：都是布尔值。 第一个参数：表示是否清空排队的动画。true表示清空，false表示不清。 第二个参数：表示是否立即完成当前动画。true表示立即完成，false表示立即停止不动。 默认不写：两个参数都是false。 1 //如果参数都是false，不清空动画队列，立即停止当前动画，进入下一个排队的动画 2 $(&quot;#ff&quot;).click(function(){ 3 $(&quot;.demo1&quot;).stop(); 4 }); 5 //第一个是true，第二个是false，清空后面的动画，立即停止当前动画 6 $(&quot;#tf&quot;).click(function(){ 7 $(&quot;.demo1&quot;).stop(true); 8 }); 9 //第一个是true，第二个是true，清空后面的动画，立即走完当前动画 10 $(&quot;#tt&quot;).click(function(){ 11 $(&quot;.demo1&quot;).stop(true,true); 12 }); 13 //第一个是false，第二个是true，不清空后面的动画，立即走完当前动画，并且进入下一个排队的动画 14 $(&quot;#ft&quot;).click(function(){ 15 $(&quot;.demo1&quot;).stop(false,true); 16 }); 6、解决动画排队问题我希望新的动画被触发时，希望前面的这个元素动画全部清空，立即停止。 防止用户频繁触发事件，动画等待。 方法1： 用stop()。清空前面所有动画队列，立即停止当前。参数值需要传第一个true。 1 $(&quot;.demo&quot;).mouseenter(function(){ 2 $(this).children(&quot;p&quot;).stop(true).slideDown(during); 3 }); 4 $(&quot;.demo&quot;).mouseleave(function(){ 5 $(this).children(&quot;p&quot;).stop(true).slideUp(during); 6 }); 为了防止频繁流氓操作，只要添加一个运动动画，前面都必须加一个stop(true)。 方法2： 节流方法：判断元素是否在运动过程中，如果是，就不执行后面的其他操作，如果不是，就执行后面的动画。 元素都有一个方法叫做is（）,判断是否处于某种状态。 1 $(“p”).is(“:animated”); 返回true和false。 1 var during = 500; 2 $(&quot;.demo&quot;).mouseenter(function(){ 3 if($(this).children(&quot;p&quot;).is(&quot;:animated&quot;)){ 4 return; 5 } 6 $(this).children(&quot;p&quot;).slideDown(during); 7 }); 8 $(&quot;.demo&quot;).mouseleave(function(){ 9 if($(this).children(&quot;p&quot;).is(&quot;:animated&quot;)){ 10 return; 11 } 12 $(this).children(&quot;p&quot;).slideUp(during); 13 });","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery排序常见方法","slug":"title26","date":"2016-11-20T09:27:56.000Z","updated":"2017-02-20T10:34:50.742Z","comments":true,"path":"2016/11/20/title26/","link":"","permalink":"http://yoursite.com/2016/11/20/title26/","excerpt":"","text":"jQuery排序1、eq（）整体排序通过$()得到jQuery对象，可以继续通过eq()获得某一个元素。 下标问题：jQuery对象得到的原生对象会进行一个自己的排列，组成一个队列。eq()方法是从这个队列里去进行排序。与原来页面的结构无关。 1 //不能用一个下标1全部选中，选中的仅仅是所有被选中的p组成的队列里的第一个 2 // $(&quot;div p&quot;).eq(1).css(&quot;background&quot;,&quot;red&quot;); 3 // $(&quot;div p&quot;).eq(5).css(&quot;background&quot;,&quot;red&quot;); 4 // $(&quot;div p&quot;).eq(9).css(&quot;background&quot;,&quot;red&quot;); 5 // $(&quot;div p&quot;).eq(13).css(&quot;background&quot;,&quot;red&quot;); 上面的排序：将所有的p选出来之后，进行新的排序，新顺序是eq方法的下标。 1 $(&quot;div p.cur&quot;).eq(1).css(&quot;background&quot;,&quot;red&quot;); 上面的排序：将所有类名叫做cur的元素全部选取出来，进行排序，新顺序是我们的eq的下标顺序，与原来节点关系的排序没关系。 2、index()在兄弟关系中的排序Index()这个方法获得的是元素在html结构中，在自己的同级元素中的位置，与获得的jQuery新队列没关系。 1 //给p标签绑定事件，点击输出自己的index（） 2 $(&quot;div p&quot;).click(function(){ 3 console.log($(this).index()); 4 }); 1 //给p标签绑定事件，点击输出自己的index（） 2 $(&quot;div p.cur&quot;).click(function(){ 3 console.log($(this).index()); 4 }); 与新队列无关，与兄弟中的排行有关。 3、对应和排他tab栏效果：给上面的元素添加事件，对应的下面的新闻显示。 可以通过相同的index（）得到的兄弟之间的排序，找到对应关系。 排他：将不是与我对应的内容设置成默认，与我对应的元素设置特殊。 1 $(&quot;.top span&quot;).mouseenter(function(){ 2 //自己的排他 3 $(this).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;); 4 //具体信息的排他 5 $(&quot;.bottom ul&quot;).eq($(this).index()).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;); 6 }); 出现一个问题：就是我们所有的ul元素的一个大排队，我们选中的永远是第一个tab栏的ul。 解决方法：不要拆开去选择元素，所有的元素都是通过节点关系，从自身出发。 1 //避免所有的tab栏大排序，所有的代码都是从事件元素自身出发去找关系 $(this).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;).parent().siblings().children().eq($(this).index()).addClass(&apos;current&apos;).siblings().removeClass(&apos;current&apos;); 4、each()遍历jQuery对象each()遍历我们jQuery对象里的元素队列。 有一个参数：function，函数参数，规定了遍历过程中对每一个元素做的工作。 1 $(“p”).each(function(){ 2 对每一个元素的操作。 3 }); function函数内部有一个默认的参数：i，指的就是这一次遍历的元素在整体队列里的下标。 1 $(&quot;div&quot;).each(function(i){ 2 //i就是每次进来遍历的元素的下标 3 //this指向的就是每次进来的那个元素 4 $(this).children().eq(1).css(&quot;background&quot;,&quot;red&quot;); 5 }); 如果遇到：每一个元素内怎么样，一定要用each方法。 1 $(&quot;div&quot;).each(function(i){ 2 //i就是每次进来遍历的元素的下标 3 //this指向的就是每次进来的那个元素 4 $(this).children().eq(1).css(&quot;background&quot;,&quot;red&quot;); 5 }); 制作：折叠选项卡的效果 1 //获取h2元素，每一个添加点击事件 2 // ＋号和-号切换，兄弟元素展开或收起 3 $(&quot;.box h2&quot;).each(function(){ 4 var $h2 = $(this).parent().siblings().children(&quot;h2&quot;); 5 $(this).click(function(){ 6 //自己的兄弟展开 7 var $span = $(this).children(&quot;span&quot;); 8 $span.html($span.html() == &quot;+&quot; ? &quot;-&quot; : &quot;+&quot;); 9 $(this).siblings().slideToggle(300); 10 //其他h2的兄弟隐藏 11 $h2.children(&quot;span&quot;).html(&quot;+&quot;); 12 $h2.siblings().slideUp(300); 13 }) 14 })","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"jQuery节点关系","slug":"title25","date":"2016-11-20T09:27:56.000Z","updated":"2017-02-20T10:34:46.456Z","comments":true,"path":"2016/11/20/title25/","link":"","permalink":"http://yoursite.com/2016/11/20/title25/","excerpt":"","text":"节点关系jQuery控制元素时，都是批量控制。 添加事件，元素本身运动、或者其他元素运动，都想跟事件元素找一些关系。 jQuery帮我们简化了这个找关系的过程，封装了一系列的方法可以帮我们找到父亲、儿子、兄弟、祖先、孙子等元素。 1、$(this)自己事件内部有一个$(this)的对象，指向的就是触发事件的这个元素本身。 就是原生js里的事件函数内的那个this，用$()将this转成jQuery对象，就能调用jQuery的方法。this不要加引号。 1 // 谁触发事件谁动 2 $(&quot;p&quot;).click(function(){ 3 $(this).animate({&quot;left&quot;:1000},1000); 4 }); 2、parent()父亲寻找元素父级的方法：必须加小括号，找到的也是亲生的父亲。爷爷和叔叔都不能。 案例：点击一个元素，让他的父亲背景变色。 1 $(&quot;p&quot;).click(function(){ 2 $(this).parent().css(&quot;background&quot;,&quot;lightblue&quot;); 3 }); 说明：方法返回的是某一个元素的父亲的jQuery对象，继续打点调用jQuery方法。 3、children()儿子寻找子级元素的方法：必须加小括号，选中的是元素的所有儿子级元素。孙子级的元素选不中。 案例：点击一个元素，让他的子级全部消失。 1 //让点击元素的子级全部消失 2 $(&quot;div&quot;).click(function(){ 3 $(this).children().hide(300); 4 }); 方法可以传递参数：还是一个选择器，指的是我要选择儿子级里面还要满足选择器要求的那些元素。 1 //要选择儿子级元素中符合选择器要求的部分 2 $(&quot;div&quot;).click(function(){ 3 $(this).children(&quot;.cur&quot;).hide(300); 4 }); 4、siblings()兄弟 寻找的是同级的兄弟元素：方法必须加小括号，找到的是亲兄弟元素。 案例：点击一个元素，让他的兄弟都变色，自身不变色。 1 $(&quot;div&quot;).children().click(function(){ 2 $(this).siblings().css(&quot;background&quot;,&quot;red&quot;); 3 }); 可以通过参数进行选择器筛选. 1 //筛选h2的兄弟元素 2 $(&quot;div&quot;).children().click(function(){ 3 $(this).siblings(&quot;h2&quot;).css(&quot;background&quot;,&quot;red&quot;); 4 }); 指的是选中的是兄弟元素中的h2标签。 5、连续打点调用案例：点击一个元素，让他自己变红，让他的兄弟编绿，父亲变蓝，父亲的兄弟变紫色，兄弟的儿子变金色。 1 $(&quot;div&quot;).children().click(function(){ 2 $(this).css(&quot;background&quot;,&quot;red&quot;) //自己 3 .siblings().css(&quot;background&quot;,&quot;green&quot;) //自己的兄弟 4 .parent().css(&quot;background&quot;,&quot;blue&quot;)//自己和兄弟的父亲 5 .siblings().css(&quot;background&quot;,&quot;purple&quot;) //父亲的兄弟 6 .children().css(&quot;background&quot;,&quot;gold&quot;); //父亲兄弟的儿子 7 }); 原理：一个jQuery对象打点调用完自己的任何方法，都会return一个对象，就是jQuery对象本身。 1 $(&quot;p&quot;).html(&quot;哈哈&quot;).css(&quot;background&quot;,&quot;skyblue&quot;); 6、其他节点关系find()：找的是元素的后代的一些元素，根据参数的选择器去选择。 1 $(&quot;div&quot;).find(&quot;span&quot;).css(&quot;background&quot;,&quot;#00f&quot;) next()：选中的是当前元素的下一个元素，必须是同级的。 1 $(&quot;div&quot;).children().click(function(){ 2 $(this).next().css(&quot;background&quot;,&quot;#f00&quot;); 3 }) nextAll()：选中的是当前元素后面的所有兄弟元素。内部可以传参数，选择符合选择器的后面的兄弟。 1 $(&quot;div&quot;).children().click(function(){ 2 $(this).nextAll().css(&quot;background&quot;,&quot;#f00&quot;); 3 }) prev()：选中的是当前元素的上一个元素，必须是同级的。 1 $(&quot;div&quot;).children().click(function(){ 2 $(this).prev().css(&quot;background&quot;,&quot;#f00&quot;); 3 }) prevAll()：选中的是当前元素前面的所有兄弟元素。内部可以传参数，选择符合选择器的后面的兄弟 1 $(&quot;div&quot;).children().click(function(){ 2 $(this).prevAll().css(&quot;background&quot;,&quot;#f00&quot;); 3 }) parents()：选择的是包含html标签在内的所有祖先元素。内部可以传参数，选择符合选择器的祖先元素。 1 $(&quot;p&quot;).parents(&quot;div&quot;).css(&quot;background&quot;,&quot;pink&quot;)","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"延时器setTimeout讲解","slug":"title23","date":"2016-11-18T09:27:56.000Z","updated":"2017-02-20T10:34:21.044Z","comments":true,"path":"2016/11/18/title23/","link":"","permalink":"http://yoursite.com/2016/11/18/title23/","excerpt":"","text":"1、延时器延时器：setTimeout()。在指定时间之后，执行1次函数。 window方法，可以省略书写。 比喻定时炸弹：在多少时间之后，炸弹爆炸。 1 语法：setTimeout(函数，等待时间); 1 console.log(1); 2 console.log(2); 3 console.log(3); 4 setTimeout(function(){ 5 console.log(&quot;booom shakalaka&quot;); 6 },1000); 7 console.log(4) 使用情况：setTimeout，如果需要在一段时间之后才执行某一个函数。只执行一次。setInterval，如果需要每隔一段时间执行函数一次，反复执行。 2、函数节流函数被调用的时候，最好有一个时间间隔，现在函数不具备这个功能。 事件被频繁触发，事件函数就会频繁调用。 解决方法：函数节流。用一个变量限制函数后面的语句到底能不能走到。定义一个延时器，将变量的限制解开。 1 //给函数上一把锁，锁开的时候，执行函数的语句，锁关上之后，不能执行函数 2 var lock = true ; //表示锁是开的能够执行事件函数 3 btn.onclick = function(){ 4 //如果锁开着可以执行后面的语句，如果关闭，直接return返回，不执行后面的代码 5 if(lock == false){ 6 return; 7 } 8 //给函数上一把锁 9 lock = false; 10 //隔一段时间打开锁 11 setTimeout(function(){ 12 lock = true; 13 },2000); 14 console.log(Math.random()); 15 }","categories":[{"name":"setTimeout","slug":"setTimeout","permalink":"http://yoursite.com/categories/setTimeout/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"jQuery常用方法","slug":"title24","date":"2016-11-18T09:27:56.000Z","updated":"2017-02-20T10:34:41.640Z","comments":true,"path":"2016/11/18/title24/","link":"","permalink":"http://yoursite.com/2016/11/18/title24/","excerpt":"","text":"jQuery常用方法1、html()相当于我们原生js里面的innerHTML方法。给元素内部添加内容。 参数必须是字符串。 1 $(&quot;div&quot;).html(&quot;你好，这是一个div&quot;); 手动的给标签内部加其他标签。 1 $(&quot;div&quot;).html(&quot;&lt;p&gt;&lt;a href=\\&quot;#\\&quot;&gt;你好&lt;/a&gt;&lt;/p&gt;&quot;); 读取内容：只能读取第一个元素内的内容。 1 console.log($(&quot;div&quot;).html()); 2、addClass()和removeClass()增加类名：addClass 移除类名：removeClass 要添加或移除的类名作为参数传入小括号内。 1 $(&quot;.ad&quot;).click(function(){ 2 $(&quot;.box&quot;).addClass(&quot;demo&quot;); 3 }); 4 $(&quot;.re&quot;).click(function(){ 5 $(&quot;.box&quot;).removeClass(&quot;demo&quot;); 6 }); 操作过程中，不会影响元素原有的类名或其他类名。 3、attr()调用或更改html元素的属性和属性值。 1 //获取某一个属性值 2 // console.log($(&quot;.ad&quot;).attr(&quot;type&quot;)); 3 //添加属性，传两个参数，第一个属性名，第二个属性值 4 // $(&quot;.box&quot;).attr(&quot;id&quot;,&quot;demo&quot;); 修改属性值。 1 $(&quot;input&quot;).click(function(){ 2 $(&quot;img&quot;).attr(&quot;src&quot;,&quot;images/cat2.jpg&quot;); 3 }); 4、常用的事件jQuery的事件不需要写on。 单击事件：click()； 1 $(&quot;input&quot;).click(function(){ 2 $(&quot;img&quot;).attr(&quot;src&quot;,&quot;images/cat2.jpg&quot;); 3 }); 鼠标移上：mouseenter鼠标进入 1 //鼠标移上元素添加类名 2 $(&quot;.box&quot;).mouseenter(function(){ 3 $(&quot;.box&quot;).addClass(&apos;demo&apos;); 4 }); 鼠标移出：mouseleave鼠标离开方法 1 //鼠标移出元素移除类名 2 $(&quot;.box&quot;).mouseleave(function(){ 3 $(&quot;.box&quot;).removeClass(&apos;demo&apos;); 4 }); 还有一种on的写法：本身也是一个方法，有两个参数，第一个参数是事件类型，第二个参数是事件函数。 1 //on方法添加事件 2 $(&quot;input&quot;).on(&quot;click&quot;,function(){ 3 $(&quot;img&quot;).attr(&quot;src&quot;,&quot;images/cat2.jpg&quot;); 4 }); 5、css()作用：调用和更改css 样式。 css()方法可以传递两个参数：如果只传一个参数，调用属性计算后的样式，如果传递两个参数，就是修改这个样式。 1 语法：jQuery.css(属性名，属性值); 传递一个参数，表示调用属性值： 得到的值是一个字符串形式的数据，不能直接参与运算。 1 console.log($(&quot;.box&quot;).css(&quot;width&quot;)); 传递两个参数，表示赋值： 1 $(&quot;img&quot;).css(&quot;width&quot;,&quot;200px&quot;); 属性名既可以写驼峰也可以写css写法： 1 //既可以写驼峰也可以写css写法 2 // $(&quot;div&quot;).css(&quot;background-color&quot;,&quot;yellowgreen&quot;); 3 $(&quot;div&quot;).css(&quot;backgroundColor&quot;,&quot;skyblue&quot;); 属性值很灵活，可以直接写数字不带单位，还可以写带单位或不带单位的字符串。 1 $(&quot;div&quot;).css(&quot;width&quot;,200); 2 $(&quot;div&quot;).css(&quot;height&quot;,&quot;200px&quot;); 3 $(&quot;div&quot;).css(&quot;border-width&quot;,&quot;5&quot;); 数值甚至可以写成加等的形式： 1 $(&quot;div&quot;).click(function(){ 2 $(&quot;div&quot;).css(&quot;width&quot;,&quot;+=20px&quot;); 3 }); 如果我们设置多个属性，将多个属性写在JSON对象。 1 //同时设置多个属性 2 $(&quot;div&quot;).css({ 3 &quot;width&quot; : 200, 4 &quot;height&quot; : 200, 5 &quot;border-width&quot; : 5 6 }); 6、hide()和show()就是隐藏和显示某一个元素。 1 $(&quot;.hide&quot;).click(function(){ 2 $(&quot;img&quot;).hide(); 隐藏 3 }) 4 $(&quot;.show&quot;).click(function(){ 5 $(&quot;img&quot;).show(); 显示 6 }) 可以传递一个时间参数，控制隐藏和显示的中间时间。 1 $(&quot;.hide&quot;).click(function(){ 2 $(&quot;img&quot;).hide(1000); 3 }) 4 $(&quot;.show&quot;).click(function(){ 5 $(&quot;img&quot;).show(1000); 6 }) 隐藏：伴随着透明度从设置透明度到0的变化，还有宽高从设置值到0的动画。 方法可以在显示和隐藏之间进行切换：toggle()； 1 $(&quot;.toggle&quot;).click(function(){ 2 $(&quot;img&quot;).toggle(1000); 3 }); 7、slideDown和slideUpslideDown()：滑动显示（方向不一定）； slideUp()：滑动隐藏； 本身就有运动过程。默认运动时间400毫秒。 1 $(&quot;.up&quot;).click(function(){ 2 $(&quot;img&quot;).slideUp(); 3 }); 4 $(&quot;.down&quot;).click(function(){ 5 $(&quot;img&quot;).slideDown(); 6 }); 隐藏的前提：必须是display:block; 显示的前提：必须是display:none; 中间有自己定义的动画：内部的结构，说明我们以什么方式隐藏和显示。 切换：slideToggle()。可以自定义运动时间： 1 $(&quot;.up&quot;).click(function(){ 2 $(&quot;img&quot;).slideUp(1000); 3 }); 4 $(&quot;.down&quot;).click(function(){ 5 $(&quot;img&quot;).slideDown(1000); 6 }); 7 $(&quot;.toggle&quot;).click(function(){ 8 $(&quot;img&quot;).slideToggle(1000); 9 }); 8、fadeIn和fadeOut表示淡入和淡出：透明度发生的变化。 fadeIn：透明度变大，显示元素，淡入。 fadeOut：透明度变到0，隐藏元素，淡出。 默认运动时间是400毫秒，可以自定义时间。 1 $(&quot;.out&quot;).click(function(){ 2 $(&quot;img&quot;).fadeOut(1000); 3 }); 4 $(&quot;.in&quot;).click(function(){ 5 $(&quot;img&quot;).fadeIn(1000); 6 }); 7 $(&quot;.toggle&quot;).click(function(){ 8 $(&quot;img&quot;).fadeToggle(1000); 9 }); 淡入淡出到某一个透明度：fadeTo（）。有两个参数，第一个叫做速度参数。第二个透明度的终点。 1 $(&quot;.to&quot;).click(function(){ 2 $(&quot;img&quot;).fadeTo(&quot;slow&quot;,0.5); 3 }); 1 $(&quot;.out&quot;).click(function(){ 2 $(&quot;img:first&quot;).fadeOut(3000); 3 $(&quot;img:last&quot;).fadeIn(3000); 4 });","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/categories/jQuery/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"call和apply","slug":"title22","date":"2016-11-18T09:27:56.000Z","updated":"2017-02-20T10:34:14.376Z","comments":true,"path":"2016/11/18/title22/","link":"","permalink":"http://yoursite.com/2016/11/18/title22/","excerpt":"","text":"call和apply了解普通函数内部有没有this关键，指向是谁。 1 var box = document.getElementById(&quot;box1&quot;); 2 animate(box,{&quot;left&quot;:300},1000,function(){ 3 console.log(this); 4 }); 5 function move(){ 6 console.log(this); 7 } 普通函数（事件函数除外）内部的this默认指向window对象。 call方法和apply方法能够帮我们制定函数内部this的指向。 1 fun.call(obj); 2 fun.apply(obj); obj就是内部this规定的指向元素。 1 //作用：第一个执行函数，第二个指定this。 2 move.call(box); 3 move.apply(box); 两种方法都能用。 区别：就是函数传参的方式不同。 1 fn.call(obj,参数1,参数2,参数3……); 2 fn.apply(obj,[参数1,参数2,参数3……]);3 1 // call方法直接传递 2 sum.call(box,1,2,3); 3 //apply必须将参数放在一个数组 4 sum.apply(box,[2,3,4]); 对封装的函数制定内部的回调函数的this。 1 move(box1); 2 function move(obj){ 3 animate(obj,{&quot;left&quot;:400},1000,function(){ 4 //运动执行完，回调函数内执行的语句 5 this.style.background = &quot;#0f0&quot;; 6 animate(this,{&quot;top&quot;:400},1000,function(){ 7 this.style.background = &quot;#00f&quot;; 8 //在调用运动函数 9 animate(this,{&quot;left&quot;:0},1000,function(){ 10 this.style.background = &quot;#0ff&quot;; 11 //在调用运动函数 12 animate(this,{&quot;top&quot;:100},1000,function(){ 13 this.style.background = &quot;#f00&quot;; 14 move(this); 15 }); 16 }); 17 }); 18 }); 19 }","categories":[{"name":"call\u0007pply","slug":"callpply","permalink":"http://yoursite.com/categories/callpply/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"异步和回调函数","slug":"title21","date":"2016-11-16T09:27:56.000Z","updated":"2017-02-20T12:49:58.487Z","comments":true,"path":"2016/11/16/title21/","link":"","permalink":"http://yoursite.com/2016/11/16/title21/","excerpt":"","text":"1、异步异步（Asynchronous），是计算机多线程的异步处理。与同步处理相对，异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。 js如果没有特殊语句：都是单线程，必须等到前面语句执行完之后，才能执行下面的语句。 同步： 1 console.log(1); 2 console.log(2); 3 console.log(3); 4 console.log(4); 5 //for循环，必须跳出循环才能走后面的语句 6 for(var i = 0 ; i &lt;= 100000 ; i++){ 7 console.log(1); 8 } 9 //后面的语句必须等到前面执行完才嫩执行，否则，只能排队等待。 10 console.log(5); 同步：工作中，完成一个demo，拿给项目经理去看，你就在旁边站着等，经理看完之后，告诉你这个可以了，继续下一个工作。 异步：工作中，完成一个demo，拿给项目经理去看，在经理看的过程，你回工位做下一个demo，经理同时也在检查你的原demo，他做完了之后告诉你，你这个可以了，继续工作。 如果要做异步：必须有异步语句的参与，setInterval、setTimeout、Ajax、node.js。 1 //定时器做异步 2 console.log(1); 3 console.log(2); 4 console.log(3); 5 console.log(4); 6 setInterval(function(){ 7 console.log(1); 8 },30) 9 console.log(5); 2、回调函数回调函数：定时器走完，可以利用一个回调函数告诉我的程序，某一个线程走完了，可以做什么工作了。 1 var timer; 2 var sum = 0; 3 timer = setInterval(function(){ 4 sum++; 5 console.log(1); 6 if(sum == 100){ 7 //清除定时器 8 clearInterval(timer); 9 //可以告诉程序下一步做什么 10 //回调函数，告诉我们定时器结束之后要做的工作 11 end(); 12 } 13 },30); 14 function end(){ 15 alert(&quot;定时器走完了&quot;); 16 } 一般有一个固定的写法：将结束后的回调函数作为一个参数。每次执行可以传递函数参数。 1 function yundong(callback){ 2 var timer; 3 var sum = 0; 4 timer = setInterval(function(){ 5 sum++; 6 console.log(1); 7 if(sum == 100){ 8 //清除定时器 9 clearInterval(timer); 10 //可以告诉程序下一步做什么 11 //回调函数，告诉我们定时器结束之后要做的工作 12 callback(); //必须写函数的调用 13 } 14 },30); 15 } 某一段代码结束后，继续执行的下一个内容。 1 animate(box1,{&quot;left&quot;:400},1000,function(){ 2 //运动执行完，回调函数内执行的语句 3 box1.style.background = &quot;#0f0&quot;; 4 animate(box1,{&quot;top&quot;:400},800,function(){ 5 box1.style.background = &quot;#00f&quot;; 6 }); 7 });","categories":[{"name":"回调函数","slug":"回调函数","permalink":"http://yoursite.com/categories/回调函数/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"JS封装简单运动框架","slug":"title20","date":"2016-11-14T09:27:56.000Z","updated":"2017-02-20T10:33:57.464Z","comments":true,"path":"2016/11/14/title20/","link":"","permalink":"http://yoursite.com/2016/11/14/title20/","excerpt":"","text":"##1 封装简单运动框架 ## 两个属性要变动：left从0变到400，width从100变到300，间隔时间50毫秒。 可以随意定义left的步长，可以计算次数，同样可以计算宽度的步长 1 △left = 20； 2 次数 = （400 - 0） / 20 = 20 3 △width = (300 - 100) / 20 = 10 傻瓜版程序：给固定的值进行运动，耦合性太强。 1 //两个属性要变动：left从0变到400，width从100变到300，间隔时间50毫秒。 2// 全局信号量 3var nowleft = box.offsetLeft; 4var nowwidth = box.offsetWidth; 5var interval = 50; 6var timer; 7start.onclick = function(){ 8 timer = setInterval(function(){ 9 //全局信号量变动 10 nowleft += 20; 11 nowwidth += (300 - 100) / ((400 - 0) / 20 ); 12 //判断 13 if(nowleft &gt;= 400){ 14 //同时拉到终点 15 nowleft = 400; 16 nowwidth = 300; 17 clearInterval(timer); 18 } 19 //赋值 20 box.style.left = nowleft + &quot;px&quot;; 21 box.style.width = nowwidth + &quot;px&quot;; 22 },interval); 23 }; 封装一个运动框架：运动：运动元素，运动的结束位置以及运动的属性，运动总时间，间隔时间可以在内部定义一个具体值。 多个属性变动结束位置，可以一个JSON对象。 1 var jieshujson = { 2 “width” : 300, 3 “left” : 400 4 } 封装一个函数：animate(obj,jieshuJson,time); 1 // 封装运动函数 2 function animate(obj,jieshuJson,time){ 3 //准备三个数据，开始的JSON，结束的JSON，还有步长JSON 4 //开始JSON有多少个属性，由jieshuJson决定 5 //给开始JSON添加新属性，来源于jieshuJson。 6 var kaishiJson = {}; 7 for(var k in jieshuJson){ 8 //通过赋初始值，用到计算后样式，将字符串转数字 9 //结束后的样式名k 10 kaishiJson[k] = parseFloat(getStyle(obj,k)); 11 } 12 //console.log(kaishiJson); 13 //步长JSON = （jieshuJson - kaishiJson） / 总次数 14 //总次数 = 总时间 / 间隔时间 15 var interval = 50; 16 var zongcishu = time / interval; 17 //获得步长JSON 18 var buchangJson = {}; 19 for(var k in jieshuJson){ 20 //避免输入的是字符串，先转数字 21 jieshuJson[k] = parseFloat(jieshuJson[k]); 22 buchangJson[k] = (jieshuJson[k] - kaishiJson[k]) / zongcishu; 23 } 24 // console.log(buchangJson); 25 //============三个JSON都准备完了=============== 26 //程序部分 27 //全局信号量接收初始值，每次的步长 28 //定义信号量JSON 29 var xinhaoliangJson = {}; 30 for(var k in kaishiJson){ 31 xinhaoliangJson[k] = kaishiJson[k]; 32 } 33 //执行次数等于总次数，停止运动 34 //累加器 35 var cishu = 0; 36 var timer ; 37 timer = setInterval(function(){ 38 //每执行一次，次数增加 39 cishu++; 40 //信号量JSON每次加一个步长 41 for(var k in xinhaoliangJson){ 42 xinhaoliangJson[k] += buchangJson[k]; 43 } 44 //验收，停止定时器 45 if(cishu &gt;= zongcishu){ 46 //拉终停表 47 for(var k in xinhaoliangJson){ 48 xinhaoliangJson[k] = jieshuJson[k]; 49 } 50 clearInterval(timer); 51 } 52 //赋值,如果是透明度属性，需要单独设置 53 for(var k in xinhaoliangJson){ 54 if(k == &quot;opacity&quot;){ 55 obj.style.opacity = xinhaoliangJson[k]; 56 obj.style.filter = &quot;alpha(opacity=&quot; + xinhaoliangJson[k] * 100 +&quot;)&quot;; 57 }else{ 58 obj.style[k] = xinhaoliangJson[k] + &quot;px&quot;; 59 } 60 } 61 },interval); 62 }","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JSON对象使用方法","slug":"title19","date":"2016-11-12T09:27:56.000Z","updated":"2017-02-20T10:33:32.601Z","comments":true,"path":"2016/11/12/title19/","link":"","permalink":"http://yoursite.com/2016/11/12/title19/","excerpt":"","text":"概述 数组：存储的是一组数据，可以操作每一项内容，有自己的局限性，通过具体下标才能获得某一项。 数据多的时候，数组的使用效率变低。 JSON对象可以解决这个问题。也可以存多个数据，每个数据都有自己的名字。可以通过数据的名字得到数据的值。 JSON叫做JavaScript Object Notation， JavaScript对象表示法。 JSON对象创建的最简单的方式，就是字面量，一对大括号{}。 语法：{}内部包括多个数据，每个数据之间用逗号隔开，最后一个数据后不能写逗号。每一项数据都包含属性名和属性值，属性名必须用引号包括，属性值根据数据类型单独设置，键值对写法”k”:v。 1 语法：{“k”: v, “k”: v} 创建一个最简单的JSON对象。 1 var json = { 2 &quot;name&quot; : &quot;kaola&quot;, 3 &quot;age&quot; : 18, 4 &quot;sex&quot; : &quot;男&quot;, 5 &quot;tall&quot; : 100, 6 &quot;weight&quot; : 178 7 }; 8 console.log(typeof json); 数据类型：对象型。引用类型数据，变量存的是地址。 调用每一项数据的方法：JSON对象点语法调用属性名即可，或者用[属性名]。 1 //调用 2 console.log(json.name); 3 console.log(json.age); 4 console.log(json.sex); 5 console.log(json.tall); 6 console.log(json[&quot;weight&quot;]); JSON对象内部还能嵌套JSON对象。 1 var json = { 2 &quot;name&quot; : &quot;kaola&quot;, 3 &quot;age&quot; : 18, 4 &quot;sex&quot; : &quot;男&quot;, 5 &quot;tall&quot; : 100, 6 &quot;weight&quot; : 178, 7 &quot;couple&quot; : { 8 &quot;name&quot; : &quot;daishu&quot;, 9 &quot;age&quot; : 17, 10 &quot;sex&quot; : &quot;女&quot;, 11 &quot;tall&quot; : 160, 12 &quot;weight&quot; : 90 13 } 14 }; 如果想调用内部JSON的属性，继续打点调用即可。 1 console.log(json.couple.tall); 修改某一个属性：给调用的属性名去直接赋值。 1 json.tall = 170; 2 console.log(json); 删除：用到一个delete关键字，后面必须加空格，书写他的属性。 1 //删除 2 delete json.couple; 3 console.log(json); 添加：直接给JSON对象打点添加属性，属性值同时赋值。 1 //添加 2 json.hobby = &quot;台球&quot;; 3 console.log(json); 2、JSON的遍历for……in语法：通过属性名去遍历所有属性，从前到后依次去遍历，直到最后一个数据被遍历完。循环结束。 1 for(var k in json){ 2 语句3 } k：表示属性名 json：你要遍历的那个JSON对象。输出每一个属性值： 1 //输出每一个属性值，需要遍历JSON对象 2 for(var k in json){ 3 console.log(json[k]); 4 } 复制一个JSON对象： 属性名都一样，属性值也一样。 过程：新的JSON对象接收复制来的数据。给新对象添加新属性，新属性等于原对象属性，再给新属性赋值，值等于原对象属性的值。 1 var newJson = {}; //必须是空的JSON对象 2 for(var k in json){ 3 //定义新属性并赋值 4 newJson[k] = json[k]; //红色是添加属性，绿色是调用原JSON的属性值 5 } 6 //循环完之后得到一个新的JSON 7 console.log(newJson);","categories":[{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/categories/JSON/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"setInterval定时器","slug":"title18","date":"2016-11-10T09:27:56.000Z","updated":"2017-02-20T12:48:45.913Z","comments":true,"path":"2016/11/10/title18/","link":"","permalink":"http://yoursite.com/2016/11/10/title18/","excerpt":"","text":"1、概念window给我们提供的一个方法，setInterval定时器。 1 window.setInterval(函数,间隔时间); 1 //获得div标签 2 var box = document.getElementsByTagName(&quot;div&quot;)[0]; 3 //全局变量累加 4 var nowleft = 0; 5 window.setInterval(function(){ 6 //每次执行函数都让nowleft递加 7 nowleft += 20; 8 //赋值给left属性值 9 box.style.left = nowleft + &quot;px&quot;; 10 },100) 定时器执行的功能由第一个参数，函数来决定： 1 window.setInterval(function(){ 2 console.log(1); 3 },100); 第一个参数可以是一个匿名函数，也可以是一个函数的函数名。 1 window.setInterval(shuchu,100); 2 function shuchu(){ 3 console.log(1);4 } 第二种方法是工作中常用的。 定时器第二个参数：间隔时间。单位：毫秒，1000毫秒等于1秒。规定的是我们函数执行间隔。 1 window.setInterval(function(){ 2 //每次执行函数都让nowleft递加 3 nowleft += 20; 4 //赋值给left属性值 5 box.style.left = nowleft + &quot;px&quot;; 6 },10); 时间间隔可以决定运动的速度。间隔时间越短，函数在一秒钟内执行的次数越多，变量变动的越快。 运动内：时间越短，速度越快。 定时器的启动是不需要其他条件，只要遇到setInterval语句就会立即开启一个定时器。 常用的形式：会省略window对象。 1 setInterval(move,50); 2、简单运动原理：利用定时器，每个多长时间，走多少步。 不需要知道要走多远，只要知道每隔多长时间走多长。 视觉暂留：视觉残留。人的视觉有一个残留时间０.１秒－０.４秒。 1 //定义定时器，让宽度每隔100毫秒变宽一点 2 setInterval(move,100); 3 function move(){ 4 now += 10; 5 //给元素宽度赋值 6 box.style.width = now + &quot;px&quot;; 7 } 间隔时间在一秒钟内让函数执行几次，次数可以叫做帧频，frame percent second，每秒执行几帧，简称fps。一个运动的帧频是24fps，指的是一秒钟动24次。 控制运动速度：帧频越大，1秒运动的次数越多。间隔时间变短，帧频变大。 第一种方法：缩短间隔时间。 1 setInterval(move,20); 第二种方法：增大步长。 1 now += 30; 3、清除定时器clearInterval又叫停止定时器。 clearInterval：清空一个定时器的作用。 方法：将定时器setInterval给一个变量，要停止的时候，将变量传给clearInterval的参数。 1 var timer; 2 start.onclick = function(){ 3 timer = setInterval(move,100); 4 }; 5 end.onclick = function(){ 6 //关闭定时器 7 clearInterval(timer); 8 }; 4、存在的问题第一个问题： 如果多次点击一个运动开始的按钮，会开启多个定时器，在一个时间内有多个定时器都在隔一段时间执行函数。造成一个现象，运动的变量每一个间隔时间变动的值是多个定时器累加的效果。运动速度回越来越快。 防骚扰操作：每开启一个定时器之前，先停止一次定时器。设表先关。 1 var timer; 2 start.onclick = function(){ 3 //设表先关 4 clearInterval(timer); 5 timer = setInterval(move,100); 6 }; 7 end.onclick = function(){ 8 //关闭定时器 9 clearInterval(timer); 10 }; 第二个问题： 有时需要元素停在一个固定位置，如果步长给的不合理，不会正好停在这个位置，有误差。解决方法：先将变量判断，if语句的后验收，如果大于终点值，强制给变量赋值，再停止定时器。拉终停表。 1 start.onclick = function(){ 2 timer = setInterval(function(){ 3 //设置步长 4 now += 13; 5 // 给元素属性赋值 6 //后验收 7 if(now &gt; 500){ 8 //拉回到终点，然后停止定时器 9 now = 500; 10 clearInterval(timer); 11 } 12 box.style.left = now + &quot;px&quot;; 13 console.log(now); 14 15 }, 50);16 }","categories":[{"name":"setInterva","slug":"setInterva","permalink":"http://yoursite.com/categories/setInterva/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"获取尺寸和位置的方法","slug":"title17","date":"2016-11-08T09:27:56.000Z","updated":"2017-02-20T10:33:19.904Z","comments":true,"path":"2016/11/08/title17/","link":"","permalink":"http://yoursite.com/2016/11/08/title17/","excerpt":"","text":"前面封装的函数得到的值都是字符串，使用的时候，一部分需要转成数字取计算。JS提供了几个常用的快捷尺寸，得到的就是数字类型的数据。 offsetLeft offsetTop offsetWidth offsetHeight clientWidth clientHeight 1、offsetLeft和offsetTop严重的兼容性问题。以offsetLeft为例。offset具有偏移量的含义。元素天生具有一个属性，认识一个叫做offsetParent的元素，偏移参考元素。 调用方法：打点调用offsetLeft。 兼容IE9以上及高级浏览器 1 &lt;div class=&quot;box1&quot;&gt; 2 &lt;div class=&quot;box2&quot;&gt; 3 &lt;div class=&quot;box3&quot;&gt; 4 &lt;p&gt;&lt;/p&gt; //本身不管有没有定位，祖先元素都没有定位，偏移参考元素就是body 5 &lt;/div&gt; 6 &lt;/div&gt; 7 &lt;/div&gt; 8 &lt;div class=&quot;box1&quot;&gt;//有定位 9 &lt;div class=&quot;box2&quot;&gt; //有定位 距离p元素最近且有定位，是offsetParent 10 &lt;div class=&quot;box3&quot;&gt; //无定位 11 &lt;p&gt;&lt;/p&gt; //本身不管有没有定位，祖先元素有定位，偏移参考元素就是距离最近的box2 12 &lt;/div&gt; 13 &lt;/div&gt; 1 &lt;/div&gt; offsetParent：不管元素自身有没有定位，如果祖先元素有定位，偏移参考元素就是距离该元素最近的有定位的祖先元素。如果祖先元素都没有定位，偏移参考元素变成body。 offsetLeft：就是自身元素的左边框外到offsetParent的左边框内部的距离。 offsetTop与offsetLeft一样：自身元素的上边框外到offsetParent的上边框内部的距离。 IE6/7浏览器： 区分两种情况，元素自身有没有定位： 第一种：元素自身没有定位。 offsetParent：距离最近的有宽高的祖先元素，如果都没有宽高，参考body。 offsetLeft：与高级浏览器一样，元素左边框外到offsetParent的左边框内部的距离。 1","categories":[{"name":"offsetLeft","slug":"offsetLeft","permalink":"http://yoursite.com/categories/offsetLeft/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"getComputedStyle使用方法","slug":"title16","date":"2016-11-05T09:27:56.000Z","updated":"2017-02-20T10:33:13.264Z","comments":true,"path":"2016/11/05/title16/","link":"","permalink":"http://yoursite.com/2016/11/05/title16/","excerpt":"","text":"计算后样式点语法不能得到计算后样式，只能得到和更改行内样式。计算后样式：其实是多个选择器叠加的最终样式。 1、高级浏览器1 var box = document.getElementById(&quot;box&quot;); 2 console.log(box.style.width); W3C制定的标准API，所有现代浏览器（包括IE9，但不包括之前的版本）都window.getComputedStyle()，该方法接收一个要进行样式计算的元素，并返回一个可以进行属性查询的接口。返回接口提供了一个名为getPropertyValue()的方法，用于检索特定样式属性的计算样式。getPropertyValue方法接收css属性名称，而不是驼峰式的名称。getPropertyValue()可以不写，直接用方括号来检索属性也可以。 兼容问题：在高级浏览器和IE9以上才能使用。 window.getComputedStyle：window指的是浏览器对象，可以省略window。内部有一个获得计算后样式的方法。 传入一个元素对象，返回时这个元素的所有计算后样式。直接写在参数位置，不需要加引号，因为我是传的是元素对象的变量。 1 console.log(window.getComputedStyle(box)); 进一步可以打点调用getPropertyValue：获得属性值。 第一种方法：小括号内的参数直接写css属性名，直接在小括号内的引号内书写，必须写css内的名字格式，不能用驼峰。 1 //var a = window.getComputedStyle(box).getPropertyValue(&quot;width&quot;); 2 var a = window.getComputedStyle(box).getPropertyValue(&quot;backgroundColor&quot;); 必须使用css的写法。 第二种方法：不用小括号调用，用中括号调用，将属性名写在中括号内部。不需要getPropertyValue。属性名必须用引号包裹。这种方法可以用驼峰命名法。 1 var a = window.getComputedStyle(box)[&quot;width&quot;]; 复合属性既能用css写法，也能用驼峰。 1 var a = window.getComputedStyle(box)[&quot;backgroundColor&quot;]; 2、低版本浏览器IE6/7/8IE9之前的版本提供了一个专有API访问计算后样式：附加在元素身上的currentStyle属性，它表现和style点语法一样，使用驼峰式访问。 使用方法与点语法调用style一模一样。点语法继续调用属性。 1 //低版本浏览器 2 var a = box.currentStyle.width; 1 //var b = box.currentStyle.backgroundColor; 3 4 box.innerHTML = a; 也可以用中括号的方式调用：只能用驼峰，不能用css写法。 2 var a = box.currentStyle[&quot;width&quot;]; 3 var b = box.currentStyle[&quot;background-color&quot;]; 3、兼容写法 ## 不是去测试浏览器版本，检测浏览器能力。如果浏览器具备调用某一个方法的能力，就使用。 能力检测：将方法作为判断条件。 1 var box = document.getElementById(&quot;box&quot;); 2 //通过能力检测写兼容 3 if(window.getComputedStyle){ 4 //高级浏览器 5 var a = window.getComputedStyle(box)[&quot;background-color&quot;]; 6 }else if(box.currentStyle){ 7 var a = box.currentStyle[&quot;backgroundColor&quot;] 8 } 9 box.innerHTML = a; 去封装一个函数，输入一个属性名，输出一个兼容后的属性值。 1 //封装一个函数，兼容高级浏览器和低版本浏览器 2 function fetchComputedStyle(ele,property){ 3 //判断是高级浏览器还是低版本 4 //能力测试判断 5 if(window.getComputedStyle){ 6 //针对用户输入的属性名进行兼容写法，不管是不是驼峰，都改成横线写法 7 property = property.replace(/([A-Z])/g,function(match,$1){ 8 return &quot;-&quot; + $1.toLowerCase(); 9 }); 10 return window.getComputedStyle(ele)[property]; 11 }else if(ele.currentStyle){ 12 //针对用户输入的属性名进行兼容写法，不管是不是驼峰，都改成驼峰 13 property = property.replace(/\\-([a-z])/gi,function(match,$1){ 14 return $1.toUpperCase(); 15 }); 16 return ele.currentStyle[property]; 17 } 18 }","categories":[{"name":"getComputedStyle","slug":"getComputedStyle","permalink":"http://yoursite.com/categories/getComputedStyle/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"getElementsByTagName使用方法","slug":"title15","date":"2016-11-03T09:27:56.000Z","updated":"2017-02-20T10:32:49.639Z","comments":true,"path":"2016/11/03/title15/","link":"","permalink":"http://yoursite.com/2016/11/03/title15/","excerpt":"","text":"1、概述getElementsByTagName：get获取 elements多个元素 by 通过 tagname标签名字。 参数：引号包裹标签名。 通过p标签获得元素：查找所有页面上的p标签，得到的是所有标签元素对象组成的数组。 1 &lt;p&gt;1&lt;/p&gt; 2 &lt;p&gt;2&lt;/p&gt; 3 &lt;p&gt;3&lt;/p&gt; 4 &lt;p&gt;4&lt;/p&gt; 5 &lt;p&gt;5&lt;/p&gt; 6 &lt;p&gt;6&lt;/p&gt; 7 &lt;script&gt; 8 //通过p标签获取元素 9 var ps = document.getElementsByTagName(&quot;p&quot;); 10 console.log(ps); 11 console.log(typeof ps); 12 &lt;/script&gt; 1 //得到的是数组，得到一个具体的p元素 2 console.log(ps[0]); 3 console.log(ps.innerHTML); 4 console.log(ps[0].innerHTML); 通过数组下标得到的数据才是我们的具体的元素对象，才有控制元素的属性和方法。 操作内部的每个元素对象，必须遍历元素 1 //我要看得到的元素内部的html内容 2 //遍历对象数组，得到每一个元素对象，打点调用属性和方法 3 for(var i = 0 ; i &lt; ps.length ; i++){ 4 console.log(ps[i].innerHTML); 5 } 通过标签名获得元素，是页面内所有的这个名的元素，不论嵌套多深。 1 &lt;div&gt; 2 &lt;div&gt; 3 &lt;p&gt;7&lt;/p&gt; 4 &lt;/div&gt; 5 &lt;/div&gt; 数组有下标，下标顺序按照什么来排序：按照元素出现的顺序排序，首标签出现靠前，在数组里位置靠前。跟嵌套关系无关。 1 &lt;div class=&quot;box1&quot;&gt; 2 &lt;div class=&quot;box2&quot;&gt; 3 &lt;div class=&quot;box3&quot;&gt; 4 &lt;div class=&quot;box4&quot;&gt;&lt;/div&gt; 5 &lt;div class=&quot;box5&quot;&gt;&lt;/div&gt; 6 &lt;/div&gt; 7 &lt;div class=&quot;box6&quot;&gt;&lt;/div&gt; 8 &lt;/div&gt; 9 &lt;/div&gt; 10 //遍历得到的div数组的单个元素的class。 11 for(var i = 0 ; i &lt; divs.length ; i++){ 12 console.log(divs[i].className); 13 } 如果得到元素在页面内只有一个，使用元素对象时也必须用数组的方法得到这个对象。 1 //选中的如果只有一个p元素 2 console.log(ps); 3 ps[0].style.background = &quot;yellowgreen&quot;; 连续打点调用：不仅仅document可以使用这个方法， 任何HTML元素也能调用这个方法。可以连续打点调用get系列方法。 1 //连续打点调用方法 2 //将范围缩小到id为box1的标签内部 3 var ps = document.getElementById(&quot;box1&quot;).getElementsByTagName(&quot;p&quot;); 4 for(var i = 0 ; i &lt; ps.length ; i++){ 5 ps[i].style.background = &quot;#f00&quot;; 6 } 等价写法： 1 var box1 = document.getElementById(&quot;box1&quot;); 2 //在box1里去找p 元素 3 var ps = box1.getElementsByTagName(&quot;p&quot;); 还可以对getElementsByTagName连续打点调用。 1 //连续使用getElementsByTagName获得元素，不用id。 2 var spans = document.getElementsByTagName(&quot;div&quot;)[1].getElementsByTagName(&quot;p&quot;)[2].getElementsByTagName(&quot;span&quot;); 3 spans[2].style.color = &quot;#f00&quot;; 错误写法： 1 var spans = document.getElementsByTagName(&quot;div&quot;)[1].document.getElementsByTagName(&quot;p&quot;)[2].getElementsByTagName(&quot;span&quot;); 更加好用的方法：先用id限制范围，用标签选元素。 1 var spans = document.getElementById(&quot;p1&quot;).getElementsByTagName(&quot;span&quot;); 2、批量控制①批量添加事件 通过标签名得到的是一个元素对象的数组，对数组遍历，里面每一项分别添加事件。批量添加过程。过程中注意闭包影响： 第一种解决方法：IIFE 1 // 选取第一个盒子的所有p 2 var box1 = document.getElementById(&quot;box1&quot;); 3 var ps = box1.getElementsByTagName(&quot;p&quot;); 4 5 //批量添加，for循环 6 //闭包对函数内部语句的影响 7 for(var i = 0 ; i &lt; ps.length ; i++){ 8 //用IIFE解决闭包问题 9 (function(a){ 10 ps[a].onclick = function(){ 11 ps[a].style.background = &quot;yellowgreen&quot;; 12 // console.log(ps[i].innerHTML); 13 }; 14 })(i); 15 } 第二种方法：我们可以给一个对象自定义属性，用这个属性存储每次循环是传进来的变量的值。事件函数内部有一个关键字叫做this，它本身就是指代的触发事件的对象本身。 1 //用自定义属性和事件函数内部的this来解决闭包问题 2 for(var i = 0 ; i &lt; ps.length ; i++){ 3 //自定义一个属性存储下标 4 ps[i].index = i; 5 //绑定事件 6 ps[i].onclick = function(){ 7 //谁触发事件，它就有一个this指向他自身，this本身就是这个对象 8 //this.index的值就是触发的这个对象的index。 9 ps[this.index].style.background = &quot;yellowgreen&quot;; 10 } 11 } 第二种方法较为常用。 ②批量控制 第一种：用两个按钮控制 1 //选中所有input标签 2 var checks = document.getElementById(&quot;box&quot;).getElementsByTagName(&quot;input&quot;); 3 var all = document.getElementById(&quot;all&quot;); 4 var none = document.getElementById(&quot;none&quot;); 5 6 //批量全选 7 all.onclick = function(){ 8 //遍历每一个多选框，添加checked属性 9 for(var i = 0 ; i &lt; checks.length ; i++ ){ 10 checks[i].checked = &quot;checked&quot;; 11 } 12 }; 13 none.onclick = function(){ 14 //遍历每一个多选框，更改checked属性 15 for(var i = 0 ; i &lt; checks.length ; i++ ){ 16 checks[i].checked = &quot;&quot;; 17 } 18 } 第二种方法：一个按钮控制。 1 //给all这个元素添加点击事件 2 all.onclick = function(){ 3 //判断all的value值如果是全选，将前面全部选中，将自己的value改成全不选 4 // 如果是全不选，将前面全部取消选择，将自己改成全选 5 if(all.value == &quot;全选&quot;){ 6 //全部选中 7 for(var i = 0 ; i &lt; checks.length ; i++ ){ 8 checks[i].checked = &quot;checked&quot;; 9 } 10 // value改为全不选 11 all.value = &quot;全不选&quot;; 12 }else{ 13 //全部不选中 14 for(var i = 0 ; i &lt; checks.length ; i++ ){ 15 checks[i].checked = &quot;&quot;; 16 } 17 // value改为全选 18 all.value = &quot;全选&quot;; 19 } 20 }; 第三种：一个按钮。用一个全局信号量当做一个中间值。全选和全不选作为两种状态。 1 //信号量方法 2 //如果信号量为1，表示我要全选，0表示全不选 3 var sema = 1; 4 var str = &quot;&quot;; 5 //添加点击事件 6 all.onclick = function(){ 7 //判断信号量是谁，如果是1，表示全选，str变成checked选中，信号量要改为0，value要变成全不选 8 //如果是1，str变成checked选中，如果不是变成“” 9 str = sema == 1 ? &quot;checked&quot; : &quot;&quot;; 10 //信号量更改 11 sema = sema == 1 ? 0 : 1; 12 //改按钮的value 13 all.value = sema == 0 ? &quot;全不选&quot; : &quot;全选&quot;; 14 //调用变动函数 15 choose(); 16 } 17 //变动函数 18 function choose(){ 19 for(var i = 0 ; i &lt; checks.length ; i++ ){ 20 checks[i].checked = str; 21 } 22 } 3、对应控制用一个元素去控制另外一个元素的变动。需要找到之间的关系。一般找数组下标。 1 //获取所有元素 2 var ps1 = document.getElementById(&quot;box1&quot;).getElementsByTagName(&quot;p&quot;); 3 var ps2 = document.getElementById(&quot;box2&quot;).getElementsByTagName(&quot;p&quot;); 4 5 //批量给PS1里的元素加事件 6 for(var i = 0 ; i &lt; ps1.length ; i++){ 7 //自定义属性存储下标 8 ps1[i].index = i; 9 ps1[i].onclick = function(){ 10 ps2[this.index].style.background = &quot;yellowgreen&quot;; 11 } 12 } 4、排他控制保留自己，排除别人。 排他控制方法：在点击事件函数内部多做一步工作，先将所有元素回归默认样式，给对应的元素再添加单独样式。 1 //获取所有元素 2 var ps1 = document.getElementById(&quot;box1&quot;).getElementsByTagName(&quot;p&quot;); 3 var ps2 = document.getElementById(&quot;box2&quot;).getElementsByTagName(&quot;p&quot;); 4 5 //批量给PS1里的元素加事件 6 for(var i = 0 ; i &lt; ps1.length ; i++){ 7 //自定义属性存储下标 8 ps1[i].index = i; 9 ps1[i].onclick = function(){ 10 //先将所有元素回归默认样式，给对应的元素再添加单独样式 11 //排他操作 12 for(var j = 0 ; j &lt; ps1.length ; j++){ 13 ps1[j].style.background = &quot;skyblue&quot;; 14 ps2[j].style.background = &quot;skyblue&quot;; 15 } 16 17 //给这个元素和对应的p加特殊样式 18 ps1[this.index].style.background = &quot;yellowgreen&quot;; 19 ps2[this.index].style.background = &quot;pink&quot;; 20 } 21 }","categories":[{"name":"getElementsByTagName","slug":"getElementsByTagName","permalink":"http://yoursite.com/categories/getElementsByTagName/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"DOM操作方法","slug":"title14","date":"2016-10-31T09:27:56.000Z","updated":"2017-02-20T10:32:40.906Z","comments":true,"path":"2016/10/31/title14/","link":"","permalink":"http://yoursite.com/2016/10/31/title14/","excerpt":"","text":"1、DOM体验DOM（Document Object Model，文档对象模型）描绘了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。这使得JavaScript操作HTML，不是在操作字符串，而是在操作节点，极大地降低了编程难度。编写例子整体感知一下这个事儿。 1 //获得元素 2 var oDiv = document.getElementById(&quot;box&quot;); 3 var oKaola = document.getElementById(&quot;kaola&quot;); 4 //添加点击事件，盒子变色，图片变图 5 oDiv.onclick = function(){ 6 oDiv.style.backgroundColor = &quot;yellowgreen&quot;; 7 oKaola.src = &quot;images/kaola2.jpeg&quot;; 8 } DOM规范在1998年10月制定，称为“DOM1级规范”。随着ECMAScript的升级，DOM也发展出了2级规范、3级规范。另外，早于1998年的DOM也有事实上的标准，我们称为0级规范。 DOM对很多东西做了抽象，提供了丰富的API：取得元素、css样式、事件、运动、元素尺寸位置、节点操作。每个知识体系都非常庞大，千丝万缕。我们今天的课程，把一些线头都掐出来，日后的课程深入研究每个线头。 2、获取元素JavaScript通过document对象表示文档，它表示整个页面。它有很多属性和方法，包含了绝大多数多页面的特征和操作。学习DOM，说白了就是学习document对象。例如document.title属性，就是页面的标题。 1 document.title = &quot;获取元素&quot;; 2 alert(document.title); DOM操作，往往都是从取得某个（些）HTML元素开始，然后对这个（些）元素进行一些操作。所以得到元素是非常重要的。得到元素的操作可以使用document对象的两个方法来完成： document.getElementById() document.getElementsByTagName() getElementById：get得到 element 元素 by 通过 id id属性值。通过id名字获得某一个元素。 驼峰命名法：一个标识符由多个英文单词组成，首个单词正常小写，从第二个开始每个单词首字符要大写，其他的小写。 JS的书写位置：如果要想获得某一个元素，那么获得之前，元素必须是加载过的。js的书写顺序，需要写在标签后面。 1 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; //标签写在获取元素的前面 2 &lt;script&gt; 3 // document.title = &quot;获取元素&quot;; 4 // alert(document.title); 5 6 //获取div元素 7 var box = document.getElementById(&quot;box&quot;); 8 box.onclick = function(){ 9 box.style.border = &quot;10px solid #0f0&quot;; 10 } 11 &lt;/script&gt; 获取元素语法：直接将获得的这个元素的id属性值写在参数里。名字必须加引号。跟css区别，不需要加#。 错误写法： 1 var box = document.getElementById(&quot;#box&quot;); 正确写法： 1 var box = document.getElementById(&quot;box&quot;); 获得的元素的数据类型。通过检测，得到一个对象类型。 1 console.log(typeof box); 也就是说，我们通过id获得元素本身又是一个对象类型的数据，内部还包含了一些属性和方法。可以对这些元素打点继续调用属性和方法。 注意：id名不能重复。 1 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; 2 &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; 3 //id名字不能重复，如果有重复的，只得到第一个 4 var oBox = document.getElementById(&quot;box&quot;); 5 oBox.style.backgroundColor = &quot;#0f0&quot;; id大小写要严格区分，但是在IE6、7中，大小写是不区分的。 IE7及较低版本还有一个怪癖，表单元素name特性也会被当做id。为了避免这个问题，所以页面上的name最好也不要和任何id相同。 3、操作html获取一个html标签之后，得到一个对象类型变量。 可以控制html的属性：得到属性、更改属性。 有两种选择：getAttribute()和setAttribute()方法，或者使用点语法。 点语法： 获得元素属性：直接在元素对象后点语法调用，输出属性值。 1 //获得img标签的src属性 2 console.log(oImg.src); 3 console.log(oImg.id); 4 console.log(oImg.alt); 更改html标签属性：可以通过点语法调用相关属性后，通过等号给这个属性赋值，更改属性值的方法。 1 //通过点语法得到相关属性，等号赋新值 2 oImg.src = &quot;images/kaola2.jpeg&quot;; 3 //不要去更改id属性，id是只读。 第二种方法： 得到属性值getAttribute()，需要得到什么属性，直接将名字写在小括号内。 1 console.log(oImg.getAttribute(&quot;src&quot;)); //得到的就是属性值的字符串 2 console.log(oImg.getAttribute(&quot;alt&quot;)); //得到的就是属性值的字符串 设置属性值setAttribute()，设置属性的新的属性值，直接写在小括号内，用引号包裹。 1 oImg.setAttribute(&quot;src&quot;,&quot;images/kaola.jpg&quot;); 第一个参数：设置属性名，第二个参数：新的属性值，中间用逗号隔开。 区别： ①html标签可以使用自定义属性，自定义属性调用和更改都不能使用点语法实现。getAttribute（）可以获得自定义属性，setAttribute（）可以更改自定义属性。 1 //自定义属性 2 oImg.setAttribute(&quot;kaola&quot;,&quot;yuanxing&quot;); 3 console.log(oImg.kaola); 4 console.log(oImg.getAttribute(&quot;kaola&quot;)); ②点语法调用html属性时，有一些属性名需要进行更改，这些属性名可能是其他的关键字，规避这些名字。getAttribute方法不用规避，直接写原属性名。 class 改为className for 改为htmlFor rowspan 改为rowSpan colspan 改为colSpan 1 //更改一些属性名的写法，只限于点语法 2 console.log(oImg.class); 3 console.log(oImg.className); getAttribute方法不需要改变写法，如果改了反而错。 1 console.log(oImg.getAttribute(&quot;className&quot;)); 2 console.log(oImg.getAttribute(&quot;class&quot;)); ③如果调用style属性得到的还是一个css对象，可以继续打点调用css的样式，遇到复合属性的单一写法，点语法需要些驼峰命名，另外一种方法不需要。 text- font- line- background- border- margin- padding- 1 //console.log(oImg.style.border-color); 2 console.log(oImg.style.borderColor); getAttribute方法直接写css内的命名就行。 ④点语法得到的style属性是一个对象，可以继续打点调用内部的属性。getAttribute方法得到style属性，是一个字符串，不能再继续打点调用。 1 //console.log(oImg.style.border-color); 2 console.log(typeof oImg.style); 3 console.log(typeof oImg.getAttribute(&quot;style&quot;)); 点语法才能继续打点调用css样式属性。 总结：除了自定义属性用getAttribute和setAttribute之外，其他情况都用点语法。 4、操作css通过对一个元素对象打点调用style属性，得到的是css样式的一个对象。可以通过得到css样式的对象，进行css属性的读取和更改。 通过点语法读取和更改的css样式都是行内样式。 1 &lt;img src=&quot;images/kaola.jpg&quot; alt=&quot;这是一只考拉&quot; style=&quot;border:2px solid #f00;&quot; class=&quot;tupian&quot; id=&quot;image&quot; kaola=&quot;bianxing&quot; /&gt; 2 //点语法得到样式都是行内样式，更改的也是行内样式 3 console.log(oImg.style.width); 4 console.log(oImg.style.border); 通过点语法改的css样式属性都是在行内式进行更改的。 1 //更改样式 2 oImg.style.height = &quot;400px&quot;; 语法注意：点语法直接调用。如果给属性赋新值，通过等号赋值，右侧的值必须写在一对儿引号里，css里面怎么写属性值，引号里直接就这么些。 1 oImg.style.height = &quot;400px&quot;; 2 oImg.style.borderColor = &quot;#00f&quot;; innerHTML表示标签内的文本。 input标签有自己的获得方法，点语法直接调用value属性。 1 console.log(oBox.innerHTML); 2 console.log(oTxt.value); 5、事件 DOM0级事件： onclick 单击事件 ondblclick 双击事件 onmouseover 鼠标移上事件 onmouseout 鼠标移出事件 onmousedown 鼠标按下事件 onmouseup 鼠标弹起事件 onfocus 获得焦点事件 onblur 失去焦点事件 onload 加载事件 事件监听：给一个元素去添加事件，如果触发事件就会执行相应的功能。JS在加载的时候，先去整个页面去查看，看谁绑定了事件，引擎就会给这个元素进行监控（监听），监控我们的元素有没有被触发这个事件的动作，如果触发动作，在瞬间执行相应的功能。 语法：给哪个元素绑定事件，就给这个元素对象打点添加对应的事件，用等号给这个事件添加事件函数。 2 box.onmouseover = function(){ 3 事件触发之后要做的事。 4 }; 如果事件被触发，立即执行后面的事件函数，不需要加()调用函数。 6 //获取元素 7 var oImg = document.getElementById(&quot;image&quot;); 8 // 绑定鼠标移上的效果，变图片 9 oImg.onmouseover = function(){ 10 oImg.src = &quot;images/kaola2.jpeg&quot;; 11 }; 调用函数方法：用小括号调用，触发事件执行事件函数。 onclick：单击事件,鼠标单击事件元素触发事件。 5 //鼠标单击事件 6 oImg.onclick = function(){ 7 oImg.style.width = &quot;300px&quot;; 8 }; 4 //鼠标双击事件 5 oImg.ondblclick = function(){ 6 oImg.style.width = &quot;300px&quot;; 7 }; 3 //绑定鼠标移上的效果，变图片 4 oImg.onmouseover = function(){ 5 oImg.src = &quot;images/kaola2.jpeg&quot;; 6 }; 7 //鼠标移出效果，一般与鼠标移上成对出现 8 oImg.onmouseout = function(){ 9 oImg.src = &quot;images/kaola.jpg&quot;; 10 }; 2 //获取元素 3 var oBox = document.getElementById(&quot;box&quot;); 4 //添加鼠标移上和移出事件 5 oBox.onmouseover = function(){ 6 oBox.style.backgroundImage = &quot;url(images/jd2.png)&quot;; 7 }; 8 oBox.onmouseout = function(){ 9 oBox.style.backgroundImage = &quot;url(images/jd1.png)&quot;; 10 }; 5 //添加鼠标按下和弹起事件 6 oBtn.onmousedown = function(){ 7 oBtn.style.backgroundColor = &quot;pink&quot;; 8 }; 9 oBtn.onmouseup = function(){ 10 oBtn.style.backgroundColor = &quot;skyblue&quot;; 11 }; 点击： 松开： 4 //获得焦点事件，输入框清空 5 oTxt.onfocus = function(){ 6 oTxt.value = &quot;&quot;; 7 }; 8 oTxt.onblur = function(){ 9 oImg.src = &quot;images/kaola2.jpeg&quot;; 10 }; onload事件：表示元素加载完之后执行某一个事件函数。 3 //onload加载，图片加载完之后，弹出一句话，加载完了 4 oImg.onload = function(){ 5 alert(&quot;加载完毕&quot;); 6 }; 页面整体加载事件： window.onload:表示页面的所有html标签、css样式都加载完。JS就可以随意书写加载位置。 3 // 只有页面全部加载完了才会触发window.onload 4 window.onload = function(){ 5 //获取元素 6 var oImg = document.getElementById(&quot;image&quot;); 7 var oTxt = document.getElementById(&quot;txt&quot;); 8 //绑定鼠标移上的效果，变图片 9 oImg.onmouseover = function(){ 10 oImg.src = &quot;images/kaola2.jpeg&quot;; 11 }; 12 //鼠标移出效果，一般与鼠标移上成对出现 13 oImg.onmouseout = function(){ 14 oImg.src = &quot;images/kaola.jpg&quot;; 15 }; 16 }； window浏览器对象，alert就是window对象里面的一个方法。window可以省略。 window.alert(&quot;yes&quot;);","categories":[{"name":"Dom","slug":"Dom","permalink":"http://yoursite.com/categories/Dom/"}],"tags":[{"name":"Dom","slug":"Dom","permalink":"http://yoursite.com/tags/Dom/"}]},{"title":"arguments对象","slug":"title13","date":"2016-10-29T09:27:56.000Z","updated":"2017-02-20T10:32:07.628Z","comments":true,"path":"2016/10/29/title13/","link":"","permalink":"http://yoursite.com/2016/10/29/title13/","excerpt":"","text":"1、arguments对象在其他语言里，一个函数定义两次，每次有不同的形式参数，代表的就是两个不同的函数，叫做函数的重载（overloaded）。 1 function fun(a,b){ 2 console.log(1); 3 } 4 function fun(a,b,c){ 5 console.log(2); 6 } 以上在其他语言里，作为两个不同的函数执行，如果实际参数有2个，调用第一个函数，如果实际参数有三个，调用第二个函数。 JS语言没有函数重载的现象。一个标识符不能给两个函数，如果给了两个函数，第二个会覆盖前面的。不论参数是多少个，都会去执行最后一个函数内部的代码。 1 function fun(a,b){ 2 console.log(1); 3 } 4 function fun(a,b,c){ 5 console.log(2); 6 } 7 fun(1,2,3,4); JS的函数内部默认都有一个叫做arguments的类数组对象。在调用函数过程中，会传递参数，所有的实际参数不管有没有对应的形参都会存到arguments对面。 arguments对象内部存的是所有的实参，将实参以数组单独数据的形式存起来。 1 function fun(a,b){ 2 console.log(arguments); 3 } 4 fun(1,2,3,4,45,6,7); 1 function fun(a,b){ 2 // console.log(arguments); 3 arguments[5] = 10; 4 arguments.length = 10; 5 console.log(arguments.length); 6 var sum = 0; 7 for(var i = 0 ; i &lt; arguments.length ; i++){ 8 sum += arguments[i]; 9 } 10 console.log(sum); 11 } 12 fun(1,2,3,4,45,6,7); arguments并不能完全使用数组的所有方法。 1 var arr = arguments.slice(3,5); 2 console.log(arr); arguments常用于封装函数时，模拟函数重载现象。 一个函数有三个形式参数，用户传一个参数，直接给参数乘以2，传2个参数，求两个参数的和，如果穿3个参数，先比较前两个数的大小，大的数与第三个数求和。 1 function sum(a,b,c){ 2 //根据实际参数个数不同，走不同的分支 3 switch(arguments.length){ 4 case 1: 5 return a * 2; 6 break; 7 case 2: 8 return a + b; 9 break; 10 case 3: 11 return (a &gt; b ? a : b) + c; 12 break; 13 default: 14 throw new Error(&quot;参数个数必须是1到3个，请重新输入&quot;); 15 } 16 } 17 console.log(sum(1)); 18 console.log(sum(1,2)); 19 console.log(sum(1,2,3)); 20 console.log(sum(1,2,3,4)); 2、IIFEIIFE：immediately-invoked function expression。即时调用函数表达式。指的就是函数在声明、定义的同时，直接调用。 （）调用函数的操作符。不能直接用在关键字定义的函数后面。 1 function fun(){ 2 console.log(1); 3 }(); 可以用函数表达式直接调用。函数表达式中，将函数矮化成了表达式，表达式是可以参数数学运算。 1 var fun = function(){ 2 console.log(2); 3 }(); 可以通过将函数矮化成表达式的形式，直接进行调用。常用的其他方法：如果函数前面加一个数学运算符，就可以矮化成表达式。 1 2 +function fun(){ 3 console.log(1); 4 }(); 5 -function fun(){ 6 console.log(1); 7 }(); 8 !function fun(){ 9 console.log(1); 10 }(); 11 (function fun(){ //()是我们最常用 12 console.log(1); 13 })(); IIFE的函数不能再外面使用函数名调用，认为函数是未定义。 1 (function fun(){ 2 console.log(1); 3 })(); 4 fun(); IIFE将fun函数的作用域给关住，在外面调用找不到这个函数定义。最常见的IIFE的写法：内部的函数是一个匿名函数。 1 (function(){ 2 console.log(1); 3 })(); IIFE可以自身传递参数。 1 2 (function(a){ 3 a++; 4 console.log(a); 5 })(5); 6 (function(a){ 7 a++; 8 console.log(a); 9 })(5); 10 (function(a){ 11 a++; 12 console.log(a); 13 })(8); 在查找变量时，在IIFE内部查找，不会去全局。 1 var a = 5; 2 (function(a){ 3 a++; 4 console.log(a); 5 })(); 作用：用来解决一些闭包的问题。 3、通过数组观察闭包数组内部每一项都是一个函数。可以自动的通过遍历给数组添加项。 1 //在数组内添加十个函数 2 var arr = []; 3 for(var i = 0 ; i &lt; 10 ; i++){ 4 //闭包：记住自己的定义域环境、内部语句。 5 arr[i] = function(){ 6 console.log(i); 7 }; 8 } 9 console.log(arr[8]); 10 arr[0](); 11 arr[1](); 12 arr[2](); 13 arr[3](); 14 arr[4](); 15 arr[5](); 每个函数都记住了自己的定义域环境和内部语句，环境记住了一个i变量，最终执行时，i变量的值已经变成了10. 利用IIFE解决问题。 1 //在数组内添加十个函数 2 var arr = []; 3 for(var i = 0 ; i &lt; 10 ; i++){ 4 //闭包：记住自己的定义域环境、内部语句。 5 //IIFE可以关注函数的作用域 6 (function(a){ 7 //内部记住a的值是固定的了，就是这次循环传进来的i 8 arr[a] = function(){ 9 console.log(a); 10 } 11 })(i); 12 } 13 console.log(arr[8]); 14 arr[0](); 15 arr[1](); 16 arr[2](); 17 arr[3](); 18 arr[4](); 19 arr[5](); IIFE可以解决数组中闭包出现的问题。","categories":[{"name":"arguments","slug":"arguments","permalink":"http://yoursite.com/categories/arguments/"}],"tags":[{"name":"IIFE","slug":"IIFE","permalink":"http://yoursite.com/tags/IIFE/"}]},{"title":"正则的术语和操作符","slug":"title12","date":"2016-10-26T09:27:56.000Z","updated":"2017-02-20T10:31:52.410Z","comments":true,"path":"2016/10/26/title12/","link":"","permalink":"http://yoursite.com/2016/10/26/title12/","excerpt":"","text":"由一些普通字符和一些特殊字符（又叫元字符–metacharacters）组成。普通字符包括大小写的字母和数字，而元字符则具有特殊的含义。 特殊字符： （） [ ] { } \\ ^ $ | ? * + . 就想匹配特殊字符，将特殊字符进行转义。用到转义符号\\。 ( [ . 1、精确匹配精确匹配指的是我们要去匹配某一个固定值或者常量，匹配abc，正则表达式里必须用精确的术语进行匹配。 正则表达式：/abc/,表示我们要匹配的是三个字符，分别是a，b，c，必须是顺序在一起，顺序不能颠倒。 2、预定义特殊字符：\\t /\\t/ 制表符 eg: console.log(/\\t/.test(&apos; &apos;)) \\n /\\n 回车符 eg: console.log(/\\n/.test(`aaa bbb`)); \\f /\\f/ 换页符 \\b /\\b/ 空格 3、字符集用正则表达式中的一类字符去配字符串中的一个字符。字符集用[]包括。 比如[abc]，表示可以匹配a，也可以匹配b，也可以匹配c，只要存在其中任意一个都是对的。 简单类:正则的多个字符对应一个字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符。将所有可能性都列在[]内，不要任何其他字符，直接连写 范围类:有时匹配的东西过多，而且类型又相同，全部输入太麻烦，我们可以在中间加了个横线。[a-z]、[0-9]、[A-Z] 组合类:允许用中括号匹配不同类型的单个字符[0-9a-b]只要数字和小写字母：[0-9a-z] 负向类:[]前面加个元字符(^)进行取反，表示匹配不能为括号里面的字符。[^a] 4、修饰符g 修饰符用于执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 match、replace这两种方法可以使用。 i 修饰符用于执行对大小写不敏感的匹配。 注意：修饰符书写位置，都是在//写完之后，紧跟在后面。修饰符可以同时使用，连写就可以。 5、边界^ 开头 注意不能紧跟于左中括号的后面 界定的是我们的字符串必须以什么为开头。^后面的正则术语匹配的字符串就必须是开头。 $ 结尾 界定的是必须以$前面的字符为结尾，$写在正则的最后。 ^和$可以同时使用，必须以他们中间的内容当做开头和结尾，字符串只能有中间的内容。 \\b 单词边界，用于查找位于单词的开头或结尾的匹配。 对我们字符匹配是前后字符的界定。\\b写在前面，表示后面的那个字符匹配时必须是一个单词的开始，\\b写在后面，表示前面的那个字符匹配时必须是一个单词的结尾。 借用：\\w,表示单词字符，包括数字、大小写字母、下划线。 \\B 非单词边界，用于查找不处在单词的开头或结尾的匹配。 \\B写在前面，表示后面的那个字符匹配时必须不是一个单词的开始，\\B写在后面，表示前面的那个字符匹配时必须不是一个单词的结尾。 对比记忆：单词边界\\b必须包括单词边界。非单词边界\\B不能有单词边界。 6、预定义类预定义类其实都是对一些字符集的简写。 . [^\\n\\r] 除了换行和回车之外的任意字符 \\d [0-9] 数字字符 digital \\D [^0-9] 非数字字符 只要不是数字都可以 \\s [ \\t\\n\\x0B\\f\\r] 空白字符 空格、缩进、换行、换页 space \\S [^ \\t\\n\\x0B\\f\\r] 非空白字符 \\w [a-zA-Z_0-9] 单词字符(所有的字母/数字/下划线) word \\W [^a-zA-Z_0-9] 非单词字符 7、量词规定数量：作用范围是量词的前面的一个字符。 {n} 硬性量词 对应零次或者n次，n人为自定义的，可以是任意正数和0 {n,m} 软性量词 至少出现n次但不超过m次(中间不能有空格) {n,} 软性量词 至少出现n次(+的升级版) ? 软性量词 出现零次或一次 等价于{0,1} 软性量词 出现零次或多次(任意次) 等价于{0,} 软性量词 出现一次或多次（至少一次） 等价于{1,} 量词除了修饰前面的单个字符，还经常搭配预定义类使用。 8、或操作符可以使用竖线（|）字符表示或者的关系。 会匹配|前面或者后面。 a|bcd : 表示匹配的字符串，要么包括一个单独的a，要么包括一个整体的bcd。 可以利用小括号分组，将|操作符包裹起来，跟后面就没关系了。 (a|b)cd : 表示从a、b选一个，后面是cd。 验证一个月的31天： 1 ^((0?[1-9])|((1|2)[0-9])|30|31)$ 9、分组的反向引用反向引用标识是对正则表达式中的匹配组捕获的子字符串进行编号，通过“\\编号(在表达式中)”，“$编号（在表达式外）”进行引用。从1开始计数。 在正则表达式里反向引用。 1 &apos;123*456&apos;.replace(/(\\d{3})\\*(\\d{3})/, &apos;$2*$1&apos;) 除了直接反向引用 之外，还可以对引用的字符做一些复杂操作。 1 &apos;123*456&apos;.replace(/(\\d{3})\\*(\\d{3})/, function (match, $1, $2) { 2 return $2 + &apos;*&apos; + $1 3 })4 10、中文匹配固定用法：[\\u4e00-\\u9fa5] 1 var str = prompt(&quot;请输入用户名，必须是4-6位的汉字&quot;); 2 var reg = /^[\\u4e00-\\u9fa5]{4,6}$/; 3 if(reg.test(str)){ 4 alert(&quot;right&quot;); 5 }else{ 6 alert(&quot;wrong&quot;); 7 }","categories":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/categories/正则/"}],"tags":[{"name":"regular","slug":"regular","permalink":"http://yoursite.com/tags/regular/"}]},{"title":"字符串属性和方法","slug":"title11","date":"2016-10-23T09:27:56.000Z","updated":"2017-02-20T10:31:44.734Z","comments":true,"path":"2016/10/23/title11/","link":"","permalink":"http://yoursite.com/2016/10/23/title11/","excerpt":"","text":"1、length属性length 属性可返回字符串中的字符数目。 49 //数组可以存一组数据 50 var str = &quot;今天要多讲一会儿了hahaha，你能怎 样？&quot;; 51 console.log(str.length); 2、方法charAt() 方法可返回指定位置的字符。 index:字符索引值，从0开始。 36 语法：str.charAt(index); 52 var str = &quot;今天要多讲一会儿了hahaha，你能怎 样？&quot;; 53 console.log(str.charAt(3)); concat() 方法用于连接两个或多个字符串。原字符串不会被改变。 37 //concat() 方法用于连接两个或多个字符串。 38 var str2 = str.concat(&quot;不怎么样啊&quot;); 39 console.log(str); 40 console.log(str2); indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。得到的结果是字符串的索引值。 注意：区分字母大小写。如果找不到对应的字符，返回-1. 54 //indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 55 console.log(str.indexOf(&quot;多讲&quot;)); lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 注意：输出的还是索引值，它是从后面找第一次出现的位置。 41 console.log(str.indexOf(&quot;a&quot;)); 42 console.log(str.lastIndexOf(&quot;a&quot;)); slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。生成新的字符串，对原字符串没影响。 56 //slice() 方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。 57 var str2 = str.slice(4,8); 58 console.log(str); 59 console.log(str2); split() 方法用于把一个字符串分割成字符串数组。参数：分隔符。 43 var str2 = &quot;lsdfowekfsdfowekdowfefsfwepp&quot;; 44 var arr = str2.split(&quot;f&quot;); 45 console.log(str2); 46 console.log(arr); toLowerCase() 方法用于把字符串转换为小写。 toUpperCase() 方法用于把字符串转换为大写。 60 var str4 = str3.toUpperCase(); 61 var str5 = str4.toLowerCase(); 62 console.log(str3); 63 console.log(str4); 64 console.log(str5); substr() 方法可在字符串中抽取从 start 下标开始的指定数目的字符。 start：开始的索引值。可以为正、可以为负。 length：截取的字符串数量。可以写可以不写，不写截取到字符串结尾。 47 var str4 = str3.substr(5,6); 48 console.log(str3); 49 console.log(str4); substring() 方法用于提取字符串中介于两个指定下标之间的字符。 substring() 方法返回的子串包括 start 处的字符，但不包括 end 处的字符。与slice一样。 不一样：substring参数不能为负。两个参数位置可以互换，第一个参数字符位置可以在第二个参数位置之后。 如果 start 比 end 大，那么该方法在提取子串之前会先交换这两个参数。end参数可以不写。 29 //substring() 方法用于提取字符串中介于两个指定下标之间的字符。 30 var str4 = str3.substring(4,9); 31 var str5 = str3.substring(9,4); 32 console.log(str3); 33 console.log(str4); 34 console.log(str5);","categories":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/categories/字符串/"}],"tags":[{"name":"string","slug":"string","permalink":"http://yoursite.com/tags/string/"}]},{"title":"数组基本知识","slug":"title10","date":"2016-10-22T09:27:56.000Z","updated":"2017-02-20T12:47:40.007Z","comments":true,"path":"2016/10/22/title10/","link":"","permalink":"http://yoursite.com/2016/10/22/title10/","excerpt":"","text":"1、数组的概述数组：是一组有序的数据集合。存放的不是一个单独的数据，而是一组数据。 创建一个数组，最简单的方法是使用数组字面量。 数组字面量：[],中括号表示内部存放的是一个数组。 []里面可以放多个数据，每个数据之间用逗号隔开，最后一个数据后面不用加逗号。 1 //数组可以存一组数据 2 var arr = [1,2,3,4,5]; 一个数组内可以存不同数据类型的数据。实际工作还是存同一种的情况居多。 1 //数组内并不只存储一种类型的数据，能存各种数据类型，甚至存数组 2 var arr2 = [1,&quot;haha&quot;,undefined,true,null,function fun(){console.log(a)},[3,4,5]]; 索引值：index，数组有一个自己的属性，可以通过下标获得某一项具体的数据。索引值从0开始。 1 方法：arr[0]; 通过数组的下标获得数组每一项的数据。 1 var arr = [1,2,3,4,5]; 2 console.log(arr[0]); 3 console.log(arr[1]); 4 console.log(arr[2]); 5 console.log(arr[3]); 通过给数组的下标去赋值，可以更改数组内的对应的数据。 1 arr[1] = &quot;haha&quot;; 2 console.log(arr[0]); 3 console.log(arr[1]); 如果调用时索引值超过最大的项数，得到的值是undefined，表示这一项还没定义具体的值。 1 console.log(arr[9]); length：长度，数组内部存了多少个数据，length就输出几。 调用length的方法：数组名字.length。 1 console.log(arr2.length); 数组的length可以推算我们数组的最大索引值，length-1就是最大的index。 1 console.log(arr2[arr2.length - 1]); 数组长度是一个固定值，但是我们可以通过arr.length强制给数组改长度。如果长度大于原来的长度，强制将数组拉长了，多出来的数组项相当于未定义值。 1 arr2.length = 12; 2 console.log(arr2.length); 如果自定义的长度小于原来的数组长度，相当于删除了后面的项。 1 arr2.length = 4; 2 console.log(arr2); 3 arr2.length = 7; 4 console.log(arr2); 5 console.log(arr2[arr2.length - 1]); 1 arr[9] = 10; 2 console.log(arr.length); 数组是引用类型，它是一个对象。 1 console.log(typeof arr); 1 //数组赋值给变量时，变量存的是数组的地址 2 var arr = [1,2,3,4,5]; 3 var arr2 = arr; 4 arr2.length = 10; 5 console.log(arr.length); 2、数组的遍历需要将数组里面的每一项拿出来做某一个操作，可以利用循环通过数组下标将所有项都取出来，对每一项进行操作，这个过程就是数组遍历的过程。 1 //数组可以存一组数据 2 var arr = [1,2,3,4,5]; 3 for(var i = 0 ; i &lt;= arr.length - 1 ; i++){ 4 console.log(arr[i]); 5 } 请输出数组中每一项的阶乘的和。 1 //数组可以存一组数据 2 var arr = [1,2,3,4,5,6,7]; 3 //累加器 4 var sum = 0; 5 for(var i = 0 ; i &lt; arr.length ; i++){ 6 sum += jiecheng(arr[i]); 7 } 8 console.log(sum); 9 //阶乘函数 10 function jiecheng(a){ 11 if(a == 0){ 12 return 1; 13 }else{ 14 //累乘器 15 var mul = 1; 16 for(var i = 1 ; i &lt;= a ; i++){ 17 mul *= i; 18 } 19 return mul; 20 } 21 } 3、数组的方法3.1、首尾操作 push() 在数组末尾添加一个或多个元素，并返回数组操作后的长度。 pop() 从数组移出最后一个元素，并返回该元素。 shift() 从数组移出第一个元素，并返回该元素。 unshift() 在数组开头添加一个或多个元素，并返回数组的新长度。 push：推。在数组最后一项后面推入一个新数据。返回值是新的长度。 1 var arr = [1,2,3,4,5]; 2 //console.log(arr.push(8)); 3 console.log(arr.push(&quot;8&quot;,10,true,[2,3])); 4 console.log(arr); 1 //pop() 从数组移出最后一个元素，并返回该元素。 2 console.log(arr.pop()); 3 console.log(arr); 5 //unshift() 在数组开头添加一个或多个元素，并返回数组的新长度。 6 console.log(arr.unshift(&quot;haha&quot;)); 7 console.log(arr); 4 //shift() 从数组移出第一个元素，并返回该元素。 5 console.log(arr.shift()); 6 console.log(arr); 综合案例： 8 //将第一项删除，添加到最后一项 9 arr.push(arr.shift()); 10 console.log(arr); 11 arr.push(arr.shift()); 12 console.log(arr); 13 arr.push(arr.shift()); 14 console.log(arr); 15 arr.push(arr.shift()); 16 console.log(arr); 17 arr.push(arr.shift()); 18 console.log(arr); 19 //最后一项给第一项 20 arr.unshift(arr.pop()); 21 console.log(arr); 3.2、合并和拆分 concat() 连接两个数组并返回一个新的数组。 concat：合并的意思。将两个数组或者多个连接成一个新的数组，对原数组或数据没有任何影响。 7 //数组可以存一组数据 8 var arr = [1,2,3,4,5]; 9 var arr2 = [6,7,8,9]; 10 //合并 11 var arr3 = arr.concat(arr2); 12 console.log(arr); 13 console.log(arr2); 14 console.log(arr3); 拆分：slice() 从数组提取一个片段，并作为一个新数组返回。 15 语法：array.slice(start,end); 截取到的新数组：原数组的第start项开始到end结束（不包含end位置）的这一段数据。start、end表示的index索引值。 参数为正数：从start开始到end结束，不包含end。 23 var arr = [1,2,3,4,5,6,7,8,9,10,11,12]; 24 //拆分 25 var arr2 = arr.slice(3,8); 26 console.log(arr); 27 console.log(arr2); 不写end：表示从start开始截取到最后一个数据。 16 var arr3 = arr.slice(3); 参数为负数：从最后一个数据往前数多少个，从开始位置截取到最后位置不包含结束位置。 28 var arr4 = arr.slice(-6,-3); 参数为负，不写end：表示从start截取到最后。 3.3、删除、插入、替换 splice() 方法用于插入、删除或替换数组的元素。 三个功能是根据参数不同而产生。 arrayObject.splice(index,howmany,element1,.....,elementX) 前两个参数必须写。后面的参数可以选择。 删除：只写前两个参数。index表示删除的开始位置，howmany表示从这个位置开始删除多少个元素。 18 //数组可以存一组数据 19 var arr = [1,2,3,4,5,6,7,8,9,10,11,12]; 20 //删除.表示从起始位置下标为3开始删除5个 21 arr.splice(3,5); 22 console.log(arr); 插入：写三个参数，要求第二个参数必须为0.插入位置是在index元素的前面。 30 //插入数据，写三个参数，第二个参数为0 31 arr.splice(3,0,&quot;haha&quot;); 32 console.log(arr); 替换：写三个或以上的参数，将一部分数据删除，用另外的数据替代。 23 // 替换数据 24 arr.splice(3,5,&quot;haha&quot;,true,[2,3]); 25 console.log(arr); 3.4、倒序和排序 倒序：reverse() 颠倒数组元素的顺序：第一个变成最后一个，最后一个变成第一个。 33 //数组可以存一组数据 34 var arr = [1,2,3,4,5,6,7,8,9,10,11,12]; 35 //倒序 36 arr.reverse(); 37 console.log(arr); 排序：sort();可以穿参数，也可以不传。 如果没有指明比较函数（没有传参数），那么元素会被转换为字符串并按照字符编码顺序顺序排序。例如 “Cherry” 会被排列到 “banana” 之前。当对数字进行排序的时候， 9 会出现在 80 之后，因为他们会先被转换为字符串，而 “80” 比 “9” 要靠前。 26 //排序、默认情况，比较字符编码顺序 27 arr.sort(); 28 console.log(arr); sort函数有一个参数，叫做比较函数，规定了我们排序的依据。 如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。记 a 和 b 是两个将要被比较的元素： 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 38 //升序排列，能控制的是条件 39 arr.sort(function(a,b){ 40 if(a &gt; b){ 41 return -1; 42 }else if(a &lt; b){ 43 return 1; 44 }else{ 45 return 0; 46 } 47 }); 48 console.log(arr); 3.5、转字符串 join() 将数组的所有元素连接成一个字符串。 join加入的意思，在数组数据之间加入一个连字符，整体连城一个字符串。 连字符：join方法的参数。不传参数，默认逗号是连字符。 数组转成字符串，用新变量接收。 29 //数组可以存一组数据 30 var arr = [1,52,23,4,75,36,7,88,90,10,11,12]; 31 var str = arr.join(); 32 var str2 = arr.join(&quot;(ㄒoㄒ)&quot;); 33 console.log(arr); 34 console.log(str); 35 console.log(str2);","categories":[{"name":"arr","slug":"arr","permalink":"http://yoursite.com/categories/arr/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"函数的使用","slug":"title8","date":"2016-10-17T09:27:56.000Z","updated":"2017-02-20T13:34:26.157Z","comments":true,"path":"2016/10/17/title8/","link":"","permalink":"http://yoursite.com/2016/10/17/title8/","excerpt":"","text":"函数就是功能。函数可以封装一段代码，整体会具备一个功能，可以人为的定义自己的功能。函数执行时候，所有的这一段封装的代码都会立即执行，实现这个功能。 1 //定义函数 2 function fun(){ 3 console.log(1); 4 console.log(2); 5 console.log(3); 6 console.log(4); 7 console.log(5); 8 } 9 //使用函数 10 fun(); 11 fun(); 函数的特点①：函数能够封装一些重复性的代码，使用时直接调用，简化代码。 1、函数的声明和调用1.1 函数的声明 函数必须先定义才能使用。 函数定义：也叫作函数声明。关键字：function。本身就是功能意思。定义语法：function关键字后面必须跟一个空格，后面是我们自定义的函数名字，紧跟着是一个小括号（参数），后面紧跟着是一个大括号，里面放的就是我们封装的结构体。函数后面不用加分号。 1 function 函数名(参数){ 2 封装的结构体； 3 } 函数名是一种标识符，必须遵循标识符命名规范： 首字符必须是字母、下划线、美元符号。 其他字符可以是字母、下划线、美元符号、数字。 区分大小写，且不能是关键字和保留字。 1 function fun(){ 2 alert(&quot;hello world&quot;); 3 } 意义：只是定义了一下函数执行时要做的工作，并不会去自动执行这些代码。函数只有调用的时候，才会执行内部的结构体。 1.2函数的调用 函数调用方法：函数名（）；直接在函数名后面加小括号。 1 //函数声明 2 function fun(){ 3 alert(&quot;hello world&quot;); 4 } 5 //函数的调用 6 fun(); 函数内部的结构体执行的位置，与定义的位置无关，与函数调用的位置有关。 1 //定义函数 2 function fun(){ 3 console.log(1); 4 console.log(2); 5 console.log(3); 6 } 7 console.log(10); 8 console.log(20); 9 console.log(30); 10 fun(); 函数一次声明，可以多次调用。函数每次调用时，内部的结构体都会全部一起执行。 1 fun(); 2 fun(); 2、函数的参数函数使用的目的，方便我们重复使用某一个功能，有时候需要功能发生一些变化，函数留了一个接口给我们，让我们的程序可以根据输入值的不同发生相应变化。 参数就是函数预留的接口：通过参数的变化，让函数执行结果发生改变。参数书写位置：函数名后面的小括号里。 1 function 函数名(参数){ 2 封装的结构体； 3 } 参数：就是一些变量。可以有一个变量或者多个变量。 1 //定义函数 2 function fun(a){ 3 console.log(a); 4 } 5 //调用时 6 fun(1); 函数的参数：定义时，小括号内的参数叫做形式参数（形参），调用时小括号内的参数叫做实际参数（实参），真正调用时参与到结构体里面的数据是实际参数的数据。 整个函数调用的过程，就是实际参数传递给形式参数（过程叫做传参），执行语句的过程。 函数的执行结果跟传递的参数息息相关。 参数本身是变量：变量的数据类型是动态变化，跟我们变量的赋值的数据类型有关。根据传参的不同，我们的函数会出现不同的结果。 案例：定义一个求和的函数。 1 //定义求和函数 2 function sum(a,b){ 3 console.log(a + b); 4 } 5 //调用 6 sum(2,3); 7 sum(2,&quot;3&quot;); arguments：实际参数组成的一个类数组对象。函数的形参和实参的个数可以不同。函数的形式参数可以少于实际参数，匹配对应形参的个数，多余的实参，不参与程序的执行。 1 //定义求和函数 2 function sum(a,b){ 3 console.log(a + b); 4 } 5 //调用 6 sum(1,2,3,4); 函数的形式参数多于实际参数，对应的实参先匹配传递，多出来的形式参数相当于只定义没有赋值，有一个默认的undefined值，会参与程序执行。 1 //定义求和函数 2 function sum(a,b){ 3 console.log(a + b); 4 } 5 //调用 6 sum(3); 函数参数提供了一个便利： 其实根本不需要去看函数内部的结构体怎么定义的，只需要知道执行函数传递几个参数，能实现什么功能就行了。后期，只需要对相应的函数传参，执行实现某种功能即可。 定义函数后：给一个说明，告诉用户输入几个参数，参数的数据类型要求是什么，执行之后会有什么后果。也叫API使用说明。 函数的特点 ②：函数很便利，只需要知道怎么使用某一个函数，不需要了解内部的构造。可以使用自己的函数，也可以使用别人的定义的函数，只需要知道怎么用，不需要知道为什么。简化我们自己的编程。 3、函数的返回值函数可以通过参数接收数据，也可以通过一个return返回一个值。 return：返回的意思。将函数执行结果返回一个固定的值。 1 //定义函数 2 function sum(a,b){ 3 return a + b; 4 } 5 //函数返回的是一个计算后的值，需要一个输出语句看值是多少 6 console.log(sum(2,3)); 如果函数有return返回值，就相当于将函数矮化成了一个表达式，表达式都会计算出一个结果参与到程序里。 可以将有return的函数执行后赋值给一个变量。 函数的参数也是变量，函数执行时，传递实参可以是另外一个有return函数的执行结果。 2 console.log(sum(4,sum(2,3))); 函数的特点③： 函数可以有返回值，可以将他的返回值当做另一个函数的参数，参与编程。模块化编程。 return的另外一个功能：函数内部如果遇到return，不会往下继续执行，跳出函数。 2 function fun(){ 3 console.log(1); 4 console.log(2); 5 console.log(3); 6 return; 7 console.log(4); 8 console.log(5); 9 console.log(6); 10 } 11 fun(); 4、模块化编程逆向思维：输出0~10000之间的完美数 → 什么是完美数 → 一个数的约数和 写的过程：约数和函数 → 判断完美数函数 → 输出所有完美数 13 // 逆向思维：输出0~10000之间的完美数 → 什么是完美数 → 一个数的约数和 14 // 写的过程：约数和函数 → 判断完美数函数 → 输出所有完美数 15 16 //封装一个约数和函数，传入一个数，返回它的约数和 17 function sum(a){ 18 var sum = 0; 19 for(var i = 1 ; i &lt; a ; i++){ 20 if(a % i == 0){ 21 sum += i; 22 } 23 } 24 return sum; 25 } 26 //console.log(sum(10)); 27 //可以封装判断完美数函数，传入一个数，返回它是否是完美数 28 function isWanmei(a){ 29 if(a == sum(a)){ 30 return true; 31 }else{ 32 return false; 33 } 34 } 35 //console.log(isWanmei(16)); 36 //输出0-10000之间的所有完美数 37 for(var i = 1 ; i &lt;= 10000; i++){ 38 if(isWanmei(i)){ 39 console.log(i); 40 } 41 } &gt; 5、函数递归递归：函数内部通过函数名调用这个函数本身。 19 //定义函数，内部调用了这个函数 20 function sum(a,b){ 21 b = sum(a,b); 22 return a + b; 23 } 24 console.log(sum(1,2)); 递归如果写的不够严谨，容易出错。使用时一定要考虑好。 斐波那契数列： 1、1、2、3、5、8、13、21、34、55、89、144、233……用求和函数内部，参数就是自己的上一次函数执行。 2 //定义函数，从第三项开始，等于前两项的和 3 //输出第几项斐波那契数列的值 4 function fib(a){ 5 if(a == 1 || a == 2){ 6 return 1; 7 }else{ 8 return fib(a-1) + fib(a-2); 9 } 10 } 11 console.log(fib(1)); 12 console.log(fib(2)); 13 console.log(fib(3)); 14 console.log(fib(4)); 15 console.log(fib(5)); 16 console.log(fib(6)); 17 console.log(fib(7)); 18 console.log(fib(8)); 6、函数表达式通过将一个匿名函数（或者有函数名的函数）矮化成一个表达式，赋值给一个变量的形式定义函数。 调用方法：使用变量名加小括号调用。不能用函数自身的名字调用，会报错。能够在函数内部用自己函数名字。 匿名函数：函数没有名字。也叫拉姆达函数。 9 //定义：将一个函数赋值给变量 10 //这种定义方式最后要加分号，相当于一个普通的语句给变量赋值。 11 var fun = function(){ 12 console.log(1); 13 }; 14 // 调用使用变量加小括号 15 //因为变量内部的值是一个函数，数据类型是函数的类型，函数能加小括号执行。 16 fun(); 9 var fun = function fun1(){ 10 console.log(1); 11 }; 12 //函数赋值给一个变量，函数名在外面就相当于未定义 13 fun(); 14 fun1(); 但是，函数名在函数内部是可以使用的。 8 var fun = function fun1(a){ 9 if(a == 1 || a == 2){ 10 return 1; 11 }else{ 12 return fun1(a - 1) + fun1(a - 2); 13 } 14 }; 15 //函数赋值给一个变量，函数名在外面就相当于未定义 16 console.log(fun(3)); 17 console.log(fun1(3)); 7、函数的数据类型函数数据类型：function。函数类型 10 // //定义：将一个函数赋值给变量 11 var fun = function fun1(a){ 12 if(a == 1 || a == 2){ 13 return 1; 14 }else{ 15 return fun1(a - 1) + fun1(a - 2); 16 } 17 }; 18 function fun2(){ 19 console.log(1); 20 } 21 console.log(typeof fun); 22 console.log(typeof fun2); function数据类型是一种复杂数据类型，也叫作引用类型。 简单数据类型：number、string、undefined、boolean、null。 变量内部数据类型是动态数据类型，存储数据是什么类型就是什么。 变量内部存的数据如果是简单数据类型的，存的就是一个实际的确切的能自身更改的值。 变量内部存的数据如果是引用类型，存的不是一个确切的object，而是这个对象的地址、指针。 如果存的是简单数据类型，将一个变量赋值给另一个变量的时候，相当于将变量内部的值复制了一份给新变量，而其中一个变量发生变化，对另一个不会产生任何影响。 7 var a = 1; 8 var b = a; 9 b = 2; 10 console.log(a); 11 console.log(b); 如果变量存的是引用类型，赋值给别的变量时，是将对象的地址复制一份给b，a和b指向的是一个对象原型，通过a或者b对对象做出变化，另外一个也会相应发生变化。 17 //复杂的数据类型，存储地址 18 var a = function(){ 19 console.log(1); 20 }; 21 var b = a; 22 b.haha = 2; 23 console.log(a.haha); 24 console.log(b.haha);","categories":[{"name":"函数","slug":"函数","permalink":"http://yoursite.com/categories/函数/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"JS循环语句","slug":"title7","date":"2016-10-13T09:27:56.000Z","updated":"2017-02-20T13:34:33.142Z","comments":true,"path":"2016/10/13/title7/","link":"","permalink":"http://yoursite.com/2016/10/13/title7/","excerpt":"","text":"1、循环语句循环语句是一系列反复执行直到符合特定条件的命令。 循环语句实际是对某一段代码进行循环执行，在规定的一个判断条件表达式为假的时候，跳出循环，停止重复执行。 JavaScript 支持 for, do while, while这些循环语句。另外，你可以在循环语句中使用break和continue 语句 。 1、for循环语句for循环语句是一种前测试循环语句。在执行下一次需要重复的代码之前，我需要先测试一下条件表达式到底是真还是假。如果是真，可以执行，如果是假，就不在循环，跳出for循环。for循环内部的循环语句执行时有先决条件。 1 //体验一下考拉体重飙升的过程 2 for(var i = 7 ; i &lt;= 178 ; i+=3){ 3 console.log(&quot;考拉今天&quot; + i + &quot;斤了&quot;); 4 } for循环的语法： 1 for(){} 其他人总结的规律： 1 for(定义循环变量；变量的最大值；步长){ 2 循环体； 3 }以上总结有局限性，for循环并不是只有这一种书写情况。 运行原理： 遇到for循环，先执行①位置的语句，然后执行语句②条件表达式，如果②的值为true，继续执行语句③；如果②的结果为false，直接跳出for循环，执行语句⑤。如果能执行到语句③，执行完之后，去执行语句④，然后再执行语句②，如果②的值为true，继续执行语句③；如果②的结果为false，直接跳出for循环，执行语句⑤。重复这个过程……直到条件②语句为假false，彻底跳出for循环，去执行语句⑤。 注意：（）里面有三个语句，用两个分号分割开，最后一个语句后面不要加分号。 1 for(var i = 3 ; i &lt;= 35 ; i += 6;){ 2 console.log(i); 3 } 1 //第二个 2 for(var i = 5 ; i &lt; 25 ; i += 5){ 3 console.log(i); 4 } 1 //第三个 2 for(var i = 30; i &gt;= 10 ; i -= 7){ 3 console.log(i); 4 } 1 //第四个 2 for(var i = 3 ; i &lt;= 35 ; i *= 2){ 3 console.log(i); 4 } for循环内部定义的这个i变量，是一个全局变量，定义在全局，可以在全局任意地方使用。可以将i变量的声明和赋初值，写在for循环外面，第一个语句的位置可以空着。 1 //第五种 2 var i = 3; 3 for(; i &lt;= 10 ; i += 3){ 虽然第一个语句可以不写，但是分号不能省略 4 console.log(i); 5 } 如果不写第一个分号，会报错，认为你没写第三个语句 1 //第六个 2 var i = 3; 3 for(console.log(i++); i &lt;= 10 ; i += 3){ 4 console.log(i); 5 } 如果限制条件没有了，不写，认为可以一直进入到语句③，循环会无限进行下去，叫做死循环。程序一定要合理，不要书写死循环。 1 //第七个 2 var i = 3; 3 for(console.log(i++); ; i += 3){ 4 console.log(i); 5 } 6 var i = 3; 7 for(console.log(i++); i &gt; 1 ; i += 3){ 8 console.log(i); 9 }10 1 //第八个 2 for(var i = 4 ; i &lt;= 12 ;){ 3 i += 3; 4 console.log(i); 5 } 1 //第九个 2 for(var i = 4 ; i &lt;= 3 ;){ 3 i += 3; 4 console.log(i); 5 } for循环内部可以嵌套if语句，输出并不是无条件输出，只有满足某一个条件才会执行输出代码。 1 //第十个，嵌套if语句 2 for(var i = 3 ; i &lt;= 20 ; i += 5){ 3 if(i % 2 == 0){ 4 console.log(i); 5 } 6 } for循环还可以嵌套for循环，注意我们定义的循环变量一定不能重复。循环变量常用名字i,j,k. 1 //第十一个 2 for(var i = 1 ; i &lt;= 5 ; i++){ 3 for(var j = 1; j &lt;= 4 ; j++){ 4 console.log(i,j); 5 } 6 } 2、穷举思想一般我们希望得到一组有特殊意义的数据，电脑并不会直接帮我们输出，而是需要我们编写一段代码，规定一个合理范围，从范围内找到这些数据。电脑需要一一去验证某一个数据是否符合条件，如果符合就输出。 程序必须将范围内每一个数据都检测一遍，通过判断条件确定是否符合要求。这些都需要我们来编写。用到我们的循环将所有可能情况循环一遍，挑出有用的，用if语句。 穷举思想：将可能性全部列举完，穷就是穷尽、完全的意思。 外层：for循环，列举。 内层：if语句，判断。 3、do while循环do while循环是一种后测试循环语句，重复执行某一段代码，直到入口条件测试为假时，跳出循环。 1 语法： 2 do{ 3 statement 4 }while(expression);5 6 do：做某事 while：当……时候 特点：在第一次测试条件之前，结构体会提前执行一次。通常会定义一些变量，让循环有一些不同。需要将这样的变量定义在循环外面，如果定义在内部，会每次重置，有可能死循环。 1 //循环变量定义在循环外面 2 var i = 1; 3 do{ 4 console.log(i); 5 i++; 6 }while(i &lt;= 10); 结构体总是会至少输出一次，条件是后测试的，哪怕条件为假，我也会执行一次结构体。 1 //循环变量定义在循环外面 2 var i = 1; 3 do{ 4 console.log(i); 5 i++; 6 }while(i &gt;= 10); for循环其实可以模拟do while的结构体先执行一次的情况，但是不够优化，尽量少用。 1 //for循环模拟do while 2 var i = 1; 3 for(console.log(i); i &gt;= 9 ; ){ 4 console.log(++i); 5 } 1 //如果变量写在内部，每次循环都会重置，有可能是死循环 2 do{ 3 var i = 1; //全局变量不要定义在内部，会被重置，死循环 4 console.log(i); 5 i++; 6 }while(i &lt;= 10); 7 变量自加的语句，写在输出语句前面和后面，得到的结果是不一样的。 4、while循环while语句反复执行直到一个特定的条件计算为假。 while语句是一个前测试循环语句，在循环体中的代码执行之前，就要测试出口条件。 语法： 1 while(expression){ 2 statement;} 注意：如果有循环变量，需要定义在循环外边。 1 //循环变量写在外面 2 var i = 1; 3 while(i &lt; 10){ 4 console.log(i); 5 i += 3; 6 } 可以用for循环模拟，都是前测试循环语句。 1 //while语句能做的，for循环都能做 2 for(var i = 1 ; i &lt; 10 ; i += 3){ 3 console.log(i); 4 } 变量自加的过程写的位置不同，结果不同。 1 var i = 1; 2 while(i &lt; 10){ 3 i += 3; 4 console.log(i); 5 } 总结：for循环是最重要，用的最多的循环语句。如果必须先执行一次结构体，再判断，最好用do while循环。while能做的for都能做。随意挑选。 5、breakbreak会终止我们的循环。 1 //碰到5的倍数，就停止循环 2 for(var i = 1 ; i &lt; 40 ; i++){ 3 console.log(i); 4 if(i % 5 == 0){ 5 break; 6 } 7 } break如果没有特殊指向，只能终止自己在的内层循环，不能终止外层的其他循环。 1 for(var i = 1 ; i &lt;= 4 ; i++){ 2 for(var j = 1 ; j &lt;= 4 ; j++){ 3 console.log(i,j); 4 if(j == 2){ 5 break; 6 } 7 } 8 } break控制外层循环：给外层循环加一个标签，标签可以代表外层循环，在break后面加这个标签，就会终止标签对应的这一层循环。 1 waiceng : for(var i = 1 ; i &lt;= 4 ; i++){ 2 for(var j = 1 ; j &lt;= 4 ; j++){ 3 console.log(i,j); 4 if(j == 2){ 5 break waiceng; 6 } 7 } 8 } 所有循环语句：如果能够执行break语句，都会跳出循环。 6、continue作用：终止当前这一次的循环，直接进入下一次循环。案例：从1到10，去找偶数，判断如果不是2，不输出直接进入下一个循环。 1 for(var i = 1 ; i &lt;= 10 ; i++){ 2 //如果你不能被3整除，直接跳过看下一个可能性 3 if(i % 3 != 0){ 4 continue; 5 } 6 console.log(i); 7 } continue语句与break一样，也只能作用于当前的循环，不能控制外层循环。 1 for(var i = 1 ; i &lt; 4; i++){ 2 for(var j = 1 ; j &lt; 4 ; j++){ 3 if(j == 2){ 4 //这不是我要的，继续下一次循环 5 continue; 6 } 7 console.log(i,j); 8 } 9 } 控制外层循环：给外层循环加一个标签，将标签名写在continue后面，就可以控制了。 1 waiceng:for(var i = 1 ; i &lt; 4; i++){ 2 for(var j = 1 ; j &lt; 4 ; j++){ 3 if(j == 2){ 4 //这不是我要的，继续下一次循环 5 continue waiceng; 6 } 7 console.log(i,j); 8 } 9 } break和continue：能够优化我们的代码。判断一个数是不是质数，通过break简化。 1 var sum = 0; 2 for(var i = 2 ; i &lt;= Math.sqrt(n) ; i++){ 3 if(n % i == 0){ 4 //说明i是n的一个约数，n肯定不是质数 5 sum++; 6 // alert(n + &quot;不是质数&quot;); 7 break; 8 } 9 } 10 if(sum == 0){ 11 alert(n+&quot;是质数&quot;); 12 }else{ 13 alert(n + &quot;不是质数&quot;);14 } 简化：输出1~10000之间的质数 1 //输出2~10000之间的质数 2 //列出所有的情况，只要发现这个数不是质数的可能性，直接跳到下一次循环 3 waiceng:for(var i = 2 ; i &lt;= 10000 ; i++){ 4 //判断除了1和本身之外只要有质数，打断，跳入下一次循环 5 for(var j = 2 ; j &lt;= Math.sqrt(i) ; j++ ){ 6 if(i % j == 0){ 7 continue waiceng; 8 } 9 } 10 //能够进行到这一步，说明前面的continue没发生作用，j一直都不是i的约数 11 // 确定i就是一个质数 12 console.log(i); 13 }","categories":[{"name":"循环语句","slug":"循环语句","permalink":"http://yoursite.com/categories/循环语句/"}],"tags":[{"name":"for","slug":"for","permalink":"http://yoursite.com/tags/for/"}]},{"title":"JS条件分支语句","slug":"title6","date":"2016-10-10T09:27:56.000Z","updated":"2017-02-20T10:30:22.091Z","comments":true,"path":"2016/10/10/title6/","link":"","permalink":"http://yoursite.com/2016/10/10/title6/","excerpt":"","text":"1、三元运算符他是唯一一个需要三个元素参与的运算。也叫作三元表达式。 符号：? : 1 语法：boolean_expression ? true_value : false_value; 表示：前面的布尔表达式的值只有true和false两种，如果为true，运算结果就是冒号前面的true_value，如果是false，运算结果就是冒号后面的false_value。 表达式：在js里面如果出现表达式，在参与代码运行时，会先计算出结果。 1 var a = 23; 2 console.log(true ? 1 : 0); 3 console.log(false ? 1 : 0); 4 console.log(7 &gt; 8 ? 1 : 0); 5 console.log(a &gt; 0 ? 1 : 0); 6 console.log(&quot;nihao&quot; ? 1 : 0); 7 console.log(&quot;&quot; ? 1 : 0); 三元运算符的结果都可以用if语句模仿。 1 //用if语句模拟三元运算符 2 var a = 23; 3 if(a &gt; 0){ 4 console.log(1); 5 }else{ 6 console.log(0); 7 } 简单的二选一得到值的程序里，三元运算符比if语句要更加简单。而且，三元运算符会直接计算出一个值，可以赋值给变量。 1 var a = 7 &gt; 8 ? 1 : 0; 2 console.log(a); 遇到给变量通过条件二选一赋值的时候，三元表达式更加好用。 1 var beishu; 2 if(year == 0){ 3 //发月薪的1倍月薪年终奖，如果月薪大于8000，那么就是发1.2倍 4 beishu = salary &gt; 8000 ? 1.2 : 1; 5 }else if(year == 1){ 6 beishu = salary &gt; 10000 ? 1.7 : 1.5; 7 }else{ 8 beishu = salary &gt; 12000 ? 3.2 : 3; 9 } 10 bonus = salary * beishu; 11 alert(&quot;您的年终奖是&quot; + bonus + &quot;元&quot;); 拓展：逻辑运算符也有选择的功能。 1 var year = parseFloat(prompt(&quot;请输入你的工作年限，不满1年输入0&quot;)) || 0; 2、switch语句开关语句允许一个程序求一个表达式的值，并且尝试去匹配表达式的值到一个case标签。如果匹配成功，这个程序执行相关的语句。 比较if语句和switch语句： if语句： 1 if(xingzuo == &quot;白羊座&quot;){ 2 alert(&quot;会有旧朋友约见面，还有一两场的应酬，相对是比较有口福的一天，但是要注意别饮食过量，引起肠胃不适，另外还需要花费一笔钱。爱情不太稳定，会有点的小状况，部...&quot;); 3 }else if(xingzuo == &quot;金牛座&quot;){ 4 alert(&quot;今天运势佳，生活无忧无虑，爱情欢乐浪漫，时刻能感受到激情的乐趣，单身者寻寻觅觅，真爱可能就在身边。另一半会是你工作上的好帮手，能为你解决许多问题。&quot;); 5 }else if(xingzuo == &quot;双子座&quot;){ 6 alert(&quot;今日头脑清醒，思路也变得清晰许多，时间比较宽裕，可以多看看书，多补充一些额外的专业知识，对以后的发展会有帮助。对投资理财有点兴趣，领悟能力不错&quot;); 7 }else{ 8 alert(&quot;不好意思，查不到了&quot;); 9 } switch语句： 1 switch(xingzuo){ 2 case &quot;白羊座&quot;: 3 alert(&quot;会有旧朋友约见面，还有一两场的应酬，相对是比较有口福的一天，但是要注意别饮食过量，引起肠胃不适，另外还需要花费一笔钱。爱情不太稳定，会有点的小状况，部...&quot;); 4 break; 5 case &quot;金牛座&quot;: 6 alert(&quot;今天运势佳，生活无忧无虑，爱情欢乐浪漫，时刻能感受到激情的乐趣，单身者寻寻觅觅，真爱可能就在身边。另一半会是你工作上的好帮手，能为你解决许多问题。&quot;); 7 break; 8 case &quot;双子座&quot;: 9 alert(&quot;今日头脑清醒，思路也变得清晰许多，时间比较宽裕，可以多看看书，多补充一些额外的专业知识，对以后的发展会有帮助。对投资理财有点兴趣，领悟能力不错&quot;); 10 break; 11 default: 12 alert(&quot;不好意思，查不到了&quot;); 13 break; 14 } 语法： 1 switch(expression){ 2 case label1: //如果表达式的值等于label1，执行下面的statement1. 3 statement1; 4 break; //遇到break，直接跳出switch语句。 5 case label2: //如果表达式的值等于label2，执行下面的statement2. 6 statement2; 7 break; //遇到break，直接跳出switch语句。 8 case label3: //如果表达式的值等于label3，执行下面的statement3. 9 statement3; 10 break; //遇到break，直接跳出switch语句。 11 …… 12 default://前面的情况都不匹配，执行default后面的结构体 13 statement_n; 14 break;15 } default：相当于if语句里面的else。可以省略。如果写了，前面不符合就走default，如果不写，前面情况都不符合，直接跳出switch。后面的break可以不写。 break：打断程序，强制跳出当前的switch语句。如果不写break，程序会继续往下进行，直到碰到一个break或者程序执行完，才能跳出。 1 switch(a){ 2 case 3: 3 alert(&quot;three&quot;); 4 case 4: 5 alert(&quot;four&quot;); 6 case 5: 7 alert(&quot;five&quot;); 8 case 6: 9 alert(&quot;six&quot;); 10 case 7: 11 alert(&quot;seven&quot;); 12 case 8: 13 alert(&quot;eight&quot;); 14 case 9: 15 alert(&quot;nine&quot;); 16 default: 17 alert(&quot;sorry, I don&apos;t know&quot;); 18 } 虽然不写不能跳出程序，我们可以利用这个特点做一些特殊的小程序。 1 var a = parseInt(prompt(&quot;请输入一个个位数，会输出它是奇数还是偶数&quot;)); 2 switch(a){ 3 case 1: 4 case 3: 5 case 5: 6 case 7: 7 case 9: 8 alert(&quot;奇数&quot;); 9 break; 10 default: 11 alert(&quot;偶数&quot;); 12 } 以下写法是错误： 1 case 1 || 3 || 5 || 7 || 9: //程序遇到表达式会先计算出结果。2 alert(“奇数”);3 break; switch语句能做的，if语句都能做。但是对于给某一个值进行匹配的情况，switch语句更优化。 总结： if语句最常用，可以做所有的条件分支语句。三元运算符，多用于给某一个变量赋值时二选一的情况。switch语句，多用于给某一个变量去匹配固定值的情况。以下也可以判断成绩好坏，但是不如if语句清晰。 1 var a = 67; 2 switch(true){ 3 case a &gt;= 90: 4 alert(&quot;best&quot;); 5 break; 6 case a &gt;= 70: 7 alert(&quot;better&quot;); 8 break; 9 case a &gt;= 60: 10 alert(&quot;good&quot;); 11 break; 12 default: 13 alert(&quot;bad&quot;); 14 }","categories":[{"name":"条件分支语句","slug":"条件分支语句","permalink":"http://yoursite.com/categories/条件分支语句/"}],"tags":[{"name":"switch","slug":"switch","permalink":"http://yoursite.com/tags/switch/"}]},{"title":"if语句","slug":"title5","date":"2016-10-10T09:27:56.000Z","updated":"2017-02-20T10:30:08.471Z","comments":true,"path":"2016/10/10/title5/","link":"","permalink":"http://yoursite.com/2016/10/10/title5/","excerpt":"","text":"1、if语句if是如果的意思。else，否则。 1 语法： 2 if(condition){ 3 statement1 //结构体，多行代码，写在一对大括号内部 4 }else{ 5 statement2 6 } 结构体要执行就都执行，要不执行，就都不执行。 condition：条件表达式，强制给我们转成布尔值。 含义：如果条件condition为真，执行第一个结构体。如果为假，执行第二个结构体。 1 if(条件){ 2 条件为真，执行的结构体； 3 }else{ 4 条件为假，执行的结构体； } if语句可以没有else，条件成立执行结构体，不成立直接退出程序 1 if(a &lt; 60){ 2 alert(&quot;抱歉没及格，努力吧&quot;);3 } 如果执行的结构体只有单行语句，可以省略大括号 1 if(a &gt;= 60) 2 alert(&quot;恭喜，及格了&quot;); 3 else 4 alert(&quot;很遗憾，没及格，继续努力&quot;); 也能写在if语句的同一行，仅限单行结构体。 1 if(a &gt;= 60) alert(&quot;恭喜，及格了&quot;); 2 else alert(&quot;很遗憾，没及格，继续努力&quot;); 这两种写法不会报错，但是为了避免出一些不必要的问题，尽量写大括号。大括号后面不需要写分号，不会出错。 if语句殊途同归，不管执行哪个程序，退出后都继续执行后面的语句 1 if(a &gt;= 60){ 2 alert(&quot;恭喜，及格了&quot;); 3 }else{ 4 alert(&quot;很遗憾，没及格，继续努力&quot;); 5 } 6 alert(&quot;好好准备下一次考试&quot;); 2、多条件分支语句条件并不是只有一个，每一个条件对应一个结构体。 if……else if …… else if…… else if…… else …… 如果……否则如果……否则如果……否则…… 1 if(条件1){ 2 满足条件1执行的结构体 3 }else if(条件2){ 4 条件1不满足，满足条件2时执行的结构体 5 }else if(条件3){ 6 条件1/2都不满足，满足条件3时执行的结构体 7 }else if(条件4){ 8 条件1/2/3都不满足，满足条件4时执行的结构体 9 }else{ 10 以上条件都不满足，执行的结构体11 } 跳楼现象：程序会选择一个分支执行（跳楼），如果执行了这个分支，表示前面分支的条件都没有满足。 案例：详细划分成绩评价，优秀，良好，及格，不及格。 1 if(a &gt;= 90){ 2 alert(&quot;优秀&quot;); 3 }else if(a &gt;= 70){ //如果走到这一步，隐含了a&lt;90 4 alert(&quot;良好&quot;); //执行完之后，直接跳楼，不会执行后面的条件分之 5 }else if(a &gt;= 60){ 6 alert(&quot;及格&quot;); //如果走到这一步，隐含了a&lt;70 7 }else{ 8 alert(&quot;不及格&quot;);9 } 大坑 1 var b = 1; 2 if(b &lt;= 3){ //只会选择这个条件内部的结构体，执行后直接跳楼 3 b += 4; 4 }else if(b == 5){ 5 b += 3 6 }else if(b == 8 ){ 7 b += 4 8 }else{ 9 b += 10; 10 } 11 console.log(b); 3、if语句嵌套制作一个结构的时候，有两个限制条件，可以使用if语句的嵌套。 if语句可以嵌套if语句使用，最终执行符合条件成立的结构体 1 if(sex == &quot;男&quot; &amp;&amp; age &gt;= 22){ 2 alert(&quot;可以领证了&quot;); 3 }else if(sex == &quot;女&quot; &amp;&amp; age &gt;= 20){ 4 alert(&quot;可以领证了&quot;); 5 }else{ 6 alert(&quot;你还小，等等吧&quot;); 7 } 以上程序也可以达到效果：结构划分不清晰，条件比较复杂。 1 //if语句嵌套方法，每一层if语句只判断一个条件，内部再去进行另一个条件的判断。 2 //第一层，只判断性别 3 if(sex == &quot;男&quot;){ 4 //第二次，判断年龄 5 if(age &gt;= 22){ 6 alert(&quot;可以领证了&quot;); 7 }else{ 8 alert(&quot;你还小，等等吧&quot;); 9 } 10 }else{ 11 //第二次，判断年龄 12 if(age &gt;= 20){ 13 alert(&quot;可以领证了&quot;); 14 }else{ 15 alert(&quot;你还小，等等吧&quot;); 16 } 17 }","categories":[{"name":"条件分支语句","slug":"条件分支语句","permalink":"http://yoursite.com/categories/条件分支语句/"}],"tags":[{"name":"if","slug":"if","permalink":"http://yoursite.com/tags/if/"}]},{"title":"运算符介绍","slug":"title4","date":"2016-09-30T09:27:56.000Z","updated":"2017-02-20T10:29:52.571Z","comments":true,"path":"2016/09/30/title4/","link":"","permalink":"http://yoursite.com/2016/09/30/title4/","excerpt":"","text":"运算符1、概述 运算符（Operators，也翻译为操作符），是发起运算的最简单形式。数学运算符(Arithmetic operators)比较运算符(Comparison operators)逻辑运算符(Logical operators)赋值运算符(Assignment operators)按位运算符(Bitwise operators)条件 (三元) 运算符(Conditional operator) 2、数学运算符数学运算符： + - * / % () 运算顺序：先算乘除取余，再算加减，有小括号先算小括号。js里数学运算没有[]、{}，全部用（）代替。 正规：数字与数字之间进行数学运算。非正规：数字与其他类型数据进行运算，其他类型数据之间进行数学运算。 ①如果是数字与纯数字字符串字符串之间进行运算。 除了＋号之外，其他的运算符，会自动将字符串转成数字。这个过程是私下进行，叫做隐式转换。不需要使用parseInt等方法。 1 // 数字与纯数字字符串,纯数字字符串之间 2 console.log(12 + &quot;2&quot;); //&quot;122&quot; 3 //在纯数字字符串参与运算之前，被隐式转换成数字类型 4 console.log(12 - &quot;2&quot;); //&quot;122&quot; 5 console.log(12 * &quot;2&quot;); //&quot;122&quot; 6 console.log(12 / &quot;2&quot;); //&quot;122&quot; 7 console.log(12 % &quot;2&quot;); //&quot;122&quot; 8 console.log(&quot;12&quot; % &quot;2&quot;); //&quot;122&quot; ②其他类型的数据参与数学运算。 其他类型的数据也会发生饮食转换。] 转换为0：空字符串、null、false转成1：true转NaN：undefined、非空非纯数字字符串。 1 console.log(23 + true); 2 console.log(23 - true); 3 console.log(23 * true); 4 console.log(23 / true); 5 console.log(23 % true); 6 console.log(23 + false); 7 console.log(23 + null); 8 console.log(23 - “”); 9 console.log(23 - undefined); 10 console.log(23 - “hello”); 11 console.log(23 - “12hello”); 1 “”→0 null→0 false→0 true→1 “12helle”→NaN undefined→NaN ③特殊数字参与运算。 特殊值NaN参与的运算都会返回NaN。 1 //所有NaN参与的运算都返回NaN 2 console.log(12 + NaN); 3 console.log(12 - NaN); 4 console.log(12 * NaN); 5 console.log(12 / NaN); 6 console.log(12 % NaN); Infinity参与的运算，要单独看。 1 //Infinity参与运算 2 console.log(23 + Infinity); 3 console.log(23 - Infinity); 4 console.log(23 * Infinity); 5 console.log(23 / Infinity); 6 console.log(23 % Infinity); 7 console.log(Infinity % Infinity); 8 console.log(Infinity + Infinity); 9 console.log(Infinity - Infinity); 10 console.log(Infinity * Infinity); 11 console.log(Infinity / Infinity); 特殊值的数学运算，防止被大公司面试阴，要过一下脑子。不过数学运算的特殊值，真心没有任何实战价值，建议没必要刻意记忆，留着脑容量记更有用的。《高3》P47~P50 总结一下：纯数字字符串、字符串在参与数学运算时，除了加号之外，其他的运算都会隐式转换。其他数据类型参与任何数学运算都会被隐式转换。 3、比较运算符种类： 大于&lt; 小于= 大于等于&lt;= 小于等于== 相等!= 不等=== 全等!== 不全等 比较运算符输出结果，都是布尔值，要么是true，要么是false。 1 //数字与数字比较 2 console.log(7 &gt; 8); 3 console.log(7 &lt; 8); 4 console.log(7 &gt;= 8); 5 console.log(7 &lt;= 8); 6 console.log(7 == 8); 7 console.log(7 != 8); 8 console.log(7 === 8); 9 console.log(7 !== 8); 10 console.log(8 === 8); 11 console.log(8 !== 8); 非常规：数字与其他类型数据进行比较，或者其他数据类型之间进行比较。 ①如果数字进行其他比较，其他类型的数据会隐式转换为数字，然后再比较。 纯数字字符串转为对应的数字，空字符串、null、false转0，true转成1. 1 console.log(1 == “1”); 2 console.log(1 == true); 3 console.log(0 == false); 4 console.log(0 == null); 5 console.log(0 &gt;= null); 6 console.log(0 &lt;= null); 7 console.log(0 == “”); 相等于和全等于的区别：相等只判断值相等就够了，全等于还要判断数据类型。 1 //判断全等,除了判断值得大小，还要判断数据类型。 2 console.log(1 === &quot;1&quot;); 3 console.log(1 === true); 4 5 //不等于、不全等于，先看等于和全等于，取反 6 console.log(1 !== &quot;1&quot;); ②字符串与字符串进行比较。 不会隐式转换为数字，比较的是Unicode字符编码顺序。顺序在前面的小于顺序在后面。 字符编码顺序：数字0~9、大写字母A~Z、小写字母a~z。 比较方法：比较的不是字符串的长度，根据字符编码顺序，一个字符一个字符比较，直到比较出大小。 1 //字符串与字符串进行比较 2 console.log(&quot;12&quot; &lt; &quot;2&quot;); 3 console.log(&quot;22&quot; &lt; &quot;2&quot;); 4 console.log(&quot;abc&quot; &lt; &quot;banana&quot;); 5 console.log(&quot;ball&quot; &lt; &quot;banana&quot;); 6 console.log(&quot;ball&quot; &lt; &quot;23&quot;); 7 console.log(&quot;ball&quot; &lt; &quot;ABC&quot;); ③NaN参与的比较 除了不等于和不全等于，NaN参与的比较运算返回的都是false。 ④Infinity自身的比较 特殊情况： 比较：3&gt;2&gt;1; 原因：代码从前往后执行，先计算3&gt;2,得到的是true，再比较时true&gt;1,返回false。控制台快捷键：清空控制台：ctrl+L执行代码：enter换行：shift+enter重新输入上一次代码：Ctrl+↑。 4、逻辑运算符逻辑运算符常用于布尔类型值之间; 当操作数都是布尔值时，返回值也是布尔值。 &amp;&amp; 逻辑与运算符 且 交集|| 逻辑或运算符 并集! 逻辑非运算符 ①逻辑与运算 真值表 a &amp;&amp; ba b 输出真 真 真真 假 假假 真 假假 假 假 规律：都真才真，有假就假。 1 //逻辑与运算 2 console.log(true &amp;&amp; true); 3 console.log(true &amp;&amp; false); 4 console.log(false &amp;&amp; true); 5 console.log(false &amp;&amp; false); ②逻辑或运算 真值表 a || b a b 输出 真 真 真 真 假 真 假 真 真 假 假 假 规律：有真就真，都假为假。 1 //逻辑或运算 2 console.log(true || true); 3 console.log(true || false); 4 console.log(false || true); 5 console.log(false || false); ③逻辑非运算 规律：非真即假，非假即真。 1 // 逻辑非运算 2 console.log(!true); 3 console.log(!false); 4 console.log(!!!!!!!!!!!!false); 正常：用于布尔值之间的逻辑运算。 非正常：其他类型的数据参与逻辑运算。将其他的数据隐式转换成布尔类型的值，计算完之后，输出对应位置的数据。不一定是输出布尔值。 隐式转换成true：非0数字、非空字符串。隐式转换为false：0、NaN、空字符串、undefined、null 1 //非布尔类型的数据 2 console.log(35 &amp;&amp; null); 3 console.log(35 || null); 4 console.log(35 &amp;&amp; &quot;nihao&quot;); 5 console.log(35 || &quot;nihao&quot;); 当它们用于非布尔值的时候，返回值就可能是非布尔值。其实这种运算非常简单，就两句话： (逻辑与 &amp;&amp; ) 如果a能被转换为false，那么返回a；否则，返回b。(逻辑或 || ) 如果a能被转换为true，那么返回a；否则，返回b。 要能深层次的理解上面的话，达到不用刻意背，自行能推倒出来的“最高境界”。花式写法：短路语法。 5、短路语法将逻辑运算，模拟电路里面的短路。 ①逻辑与比喻成串联电路。 电流通过a到b；如果a为真，电流可以流通到b，不论b为真还是假，直接抛出b。如果a为假，电流通不过，停留在a，就直接抛出a。 1 // //逻辑与运算 2 console.log(23 &amp;&amp; &quot;haha&quot;); 3 console.log(23 &amp;&amp; null); 4 console.log(undefined &amp;&amp; Infinity); 5 console.log(NaN &amp;&amp; null); ②逻辑或比喻成并联电路。 电流优先通过a。如果a为真，电流可以直接通过a，不需要到b，直接抛出a。如果a为假，电流不能通过a，换到b流过，不管b为真还是假，都抛出b。 1 //逻辑或运算 2 console.log(23 || &quot;haha&quot;); 3 console.log(23 || null); 4 console.log(undefined || Infinity); 5 console.log(NaN || null); 逻辑运算有顺序：非、与、或。 案例：NaN &amp;&amp; null || 23 &amp;&amp; !true || !false 原式= NaN &amp;&amp; null || 23 &amp;&amp; !true || !false = NaN &amp;&amp; null || 23 &amp;&amp; false || true = NaN || false || true = false || true = true 6、赋值运算符做了两步工作：先运算，后赋值。必须有变量参与运算。 = 等于 += 加等于 将后面的值加到原来的变量值上，得到的值赋值给变量 -= 减等于 *= /= %= ++ 递加 在原来的基础上加1，再赋值 – 递减 在原来基础上减一，在赋值 1 //带等号的赋值运算符 2 var a = 1; 3 4 //加等于 5 a += 2;// a = a + 2; 6 console.log(a); //3 7 8 //减等于 9 a -= 5; // a = a - 5; 10 console.log(a); //-2 11 12 //乘等于 13 a *= -5; // a = a * -5; 14 console.log(a); //10 15 16 //除等于 17 a /= 2; // a = a / 2; 18 console.log(a); //5 19 20 //取余等于 21 a %= 6; // a = a % 6; 22 console.log(a); //5 递加：符号++，与前面的变量之间不能有空格。而且++符号可以写在变量的前面，也可以写在后面。着这两种情况使用时有一些区别。 ++a:如果在一个算式里，第一次使用的值，是加完后的值，第二次使用也是加完后的新值。a++：如果在一个算是里，参与运算时，第一次使用时原来的就值，第二次使用的时候就是新值。 1 var a = 2; 2 console.log(a++); 3 console.log(a); 4 a = 2; 5 console.log(++a); 6 console.log(a); 特殊运算： 1 var a = 10, 2 b = 20, 3 c = 30; 4 var sum = ++a + b++ + a++ + ++c; 5 console.log(sum); //73 6 console.log(a); //12 7 console.log(b); //21 8 console.log(c); //31 7、综合运算顺序贴身的 → 数学的 → 比较 → 逻辑的 → 赋值的。 1 综合案例： 2 var a = 4; 3 a *= 1 * (2 + 3) &amp;&amp; ++a || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || !9;4 原式 = a *= 1 * (2 + 3) &amp;&amp; ++a || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || !9; = a *= 1 * (2 + 3) &amp;&amp; 5 || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || false; = a *= 5 &amp;&amp; 5 || 5 &gt; 6 &amp;&amp; 7 &lt; 8 || false; = a *= 5 &amp;&amp; 5 || false &amp;&amp; true || false = a *= 5 || false || false = a *= 5 a = 20","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"IE6兼容及hack使用","slug":"title3","date":"2016-09-28T09:27:56.000Z","updated":"2017-02-20T12:46:01.313Z","comments":true,"path":"2016/09/28/title3/","link":"","permalink":"http://yoursite.com/2016/09/28/title3/","excerpt":"","text":"一、HACK我们真正的网页是由一份html和css来完成，在不同用户电脑上可能不一样的渲染效果。但是我们需要所有浏览器渲染效果都是一致的，由于存在兼容问题，对于一些特殊的html和css，要根据浏览器的不同，写不同的代码，显示效果是一样的，这个技术就叫做HACK（Hacker黑客）。 hack：针对不同的浏览器写不同的html和css，达到显示一致的效果。分类：html hack，css hack。 1、html的hack根据不同的浏览器写不同的html代码。需要用到一个辅助的代码，叫做hack符号。IE浏览器存在很多兼容问题，IE给我们留了一个接口，规定的IE版本的浏览器认识里面是html结构，其他的浏览器认为里面的是注释。 &lt;!--[if lte IE 9]&gt; 这是一段文字 &lt;![endif]--&gt; 这段代码里面的文字，只能在IE9及以下的版本浏览器内看得到。其他的不显示，认为是注释。 if：如果 lte：小于等于 IE 浏览器 9版本。 lte：less than or equal ，小于等于 lt：less than ，小于 gt：greater than ，大于 gte： greater than or equal ，大于等于 如果低于IE8就显示，其他的认为是注释。 &lt;!--[if lt IE 8]&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;![endif]--&gt; 如果高于IE8就显示，其他的认为是注释。 &lt;!--[if gt IE 8]&gt; &lt;h2&gt;大于IE8能看见&lt;/h2&gt; &lt;![endif]--&gt; 如果只有IE8认识，其他都是注释。 &lt;!--[if IE 8]&gt; &lt;p&gt;只有IE8认识&lt;/p&gt; &lt;![endif]--&gt; 作为浏览器版本提醒： 有一些代码在IE中加载，其他浏览器不加载。 位置不能乱写：不能卸载css样式里面 &lt;style&gt; .box{ width: 100px; height: 100px; border-radius: 50%; background: skyblue; } &lt;!--[if IE 6]&gt; &lt;script src=&quot;js/ie6.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/style&gt; 2、css的hack针对不同的浏览器写不同的css样式。 css hack：值的hack、选择器的hack 2.1 值的hack 对某一个特定的属性值写hack。/IE6/hack符：_下划线、-横线。 .box{ width: 100px; height: 100px; background: skyblue; _background: gold;//表示只有IE6认识 } 其他浏览器会认为是未知的属性名：unknown property name。 /IE6、7/ hack符：~ ! @ # $ % ^ &amp; * ( ) + ` [ ] | &lt; &gt; ? / .任意一个符号都可以，表示只有ie6/7认识，其他的都是不认识。 !background: green; |background: green; +background: green; [background: green; /IE8/hack符：在属性值的后面加\\0/。 .selector { color: blue\\0/; } 只有IE8里加载这个属性。 background: red\\0/; /IE8/9/hack符：在属性值后面加\\0. /*IE6/7/8/9/10*/ hack符：在属性值后面加\\9 background: red\\9; 实际工作：记住IE6的下划线。IE6/7记住一个！。 2.2 选择器hack 针对不同的浏览器，加载不同选择器内的所有样式。 / IE 6 and below /  html .selector {}只有IE6及以下的浏览器认识这个选择器。高级浏览器认为html就是整个结构的根元素，不包含在*通配符选择器内，所以不认识这个选择器。而IE6及以下是认识。 .box{ width: 100px; height: 100px; background: skyblue; } * html .box{ width: 200px; height: 200px; background: pink; } 等价于：内部的属性值都加hack符。 _width: 200px; _height: 200px; _background: pink; / IE 7 and below / .selector, {}IE7及以下才认识的选择器写法。 .box,{ width: 200px; height: 200px; background: green; } 等价于： .box{ !width: 200px; !height: 200px; !background: green; } / Everything but IE 6 / html &gt; body .selector {}表示出了IE6其他的浏览器都认识。IE6不支持&gt;表示的子级选择器。 html&gt;body .box{ width: 200px; height: 200px; background: purple; } / Everything but IE 6/7 / html &gt; /**/ body .selector {} head ~ / / body .selector {} 除了IE6/7，其他的都认识。实际：选择器的hack不常用，不会把所有的属性都重写，单一的属性单独设置，直接用值hack。 二、IE6兼容问题 1、盒模型 1.1 DTD 如果页面没有写文档DTD，页面盒子在加载时其他高级浏览器正常加载，IE6加载模式是一种怪异模式。 正常：宽高确定后，添加内边距、border盒子整体外扩。 怪异：宽高确定后，添加内边距、border盒子会往内自减，实际书写内容区域变小。 解决方法：写DTD。 1.2盒子高度不能低于字号 IE6有默认字号是18px。其他浏览器都能够设置盒子高度低于默认字号的盒子。IE6不能让盒子高度低于18px。 解决方法：给你要设置高度的盒子单独设置一个字号属性，属性值小于你要设置的盒子高度。 _font-size: 0;只有IE6加载这个属性。 1.3 图片边框问题 图片外如果包裹了一个a标签，在IE6里会比正常情况给图片多加了一个蓝色的边框。 解决方法：给img都清除边框。 img{ border: none; } 2、浮动 2.1 一个浮动一个不浮动 高级浏览器：不浮动的元素会钻到浮动元素下面。 IE6：排在浮动元素后面。不会出现压盖效果。 解决方法：不要用浮动制作压盖，同级元素一个浮动另外一个也要浮动。 2.2 3像素bug 如果元素一个浮动，一个不浮动，IE6里会并排排列，同时两个元素之间多了3像素间距。 解决方法： ①同级元素一个浮动另外一个也要浮动。②给浮动的元素添加一个margin-right值为-3px的属性。 .box1{ width: 100px; height: 100px; background: #f40; float: left; margin-right: -3px; } 2.3 双倍margin问题 如果浮动的方向和margin边距的方向相同，那么首个浮动的元素距离父盒子的边距是margin值的两倍。 解决方法： ①浮动的方向与margin的方向相反，父盒子和第一个元素的间距用父盒子的padding挤出来。不要用儿子踹父亲。 ul{ list-style: none; width: 780px; padding-right: 20px; height: 40px; border: 1px solid #000; margin: 100px auto; } ul li{ float: right; width: 100px; height: 40px; background: #f40; margin-left: 20px; } ②非要用margin去撑开。单独给IE6的第一个盒子设置一个margin值减半。 ul li.half_margin{ _margin-right: 10px; } 2.4 overflow:hidden失效 加了overflow属性之后，盒子可以清除内部的浮动，自适应高度。IE6以前不能使用它来清浮动的效果。布局：layout。 IE有两个加载机制：有布局、没有布局。 有布局：hasLayout，盒子在布局时，根据内部元素的内容来进行布局。 没有布局：盒子在布局时，盒模型数据是来源于父元素。我们需要想办法触发有布局机制。有很多属性都能触发。有一个属性始终能够触发zoom放大属性。属性值：数字，1表示按1倍放大，2表示按2倍放大…… .box{ width: 700px; border: 10px solid #999; margin-bottom: 20px; overflow: hidden; _zoom: 1; } 三、图片和透明 1、图片 网页使用的三种图片：JPG、png、GIF。分辨率：72像素/英寸 1.1 JPG图片 是我们最常用的一种图片格式。 特点：色彩丰富。可以压缩，品质可以调整。 缺点：不能保存图层，不能做动图，不能保存背景透明、图片半透明的效果。 用途：有实际意义的结构，用作插入图，背景不是透明的背景图，图片大小比较小。 1.2 png图片 特点：不可压缩，可以保存图层，可以保存透明和半透明。 缺点：文件太大。 大小并不是一定png就比JPG大。色彩很丰富，图层保存比较多的时候，肯定是png文件大。如果保存的图片背景透明，文件色彩、形状都比较简单，png图片导出成没有图层的时候，文件反而比JPG要小。png图片保留一份带图层，往网上上传是需要将png图片导出一份图层合并之后。 用途：背景透明和半透明的图片，精灵图，图片比较小色彩不是很复杂。 1.3 GIF图片 GIF图片无所压缩不压缩的问题。色彩比较单一，色值有256种、128种、216种、64种……2种。 特点：文件小，可以存动图，能够保存透明，不能保存半透明。 动图：通过添加时间轴帧动画，每一帧都有一张图片，连续按照一定的时间间隔播放，有一个动图的效果。背景透明：同一个图片，png比GIF文件要大。 用途：动图，完全透明的背景图片（解决pngIE6背景透明的兼容问题）。 2、盒子透明 需要用一个属性完成，透明度属性opacity，属性值是0到1之间的小数。 opacity: 0.5;透明效果：盒子本身半透明，内部的元素也跟着透明。 IE8及以下的浏览器不支持opacity属性。虽然不支持，IE有自己的设置盒子透明的属性，滤镜属性filter。http://justcoding.iteye.com/blog/940184/比较强大。内部有多重滤镜属性，其中包括alpha通道透明。 透明度的数值注意：0~100之间的整数。 filter: alpha(opacity=50); 解决内容同时透明的问题：只让盒子透明，内容不透明。将文字单独拿出来放在别的盒子里，用定位定到半透明幕布上面。 3、图片透明 除了IE6，其他浏览器都能够正常的加载背景透明或半透明效果的PNG图片。ie6不支持。 解决IE6的png图片兼容问题： 方法一：如果只有透明，没有半透明，可以用GIF图片格式代替，GIF在IE6里没有兼容问题。 方法二：给我们页面添加一段只有IE6认识的js代码，解决png背景透明问题。 &lt;!--[if IE 6]&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/png.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; DD_belatedPNG.fix(&quot;选择器&quot;);//多个选择器，用逗号隔开 &lt;/script&gt; &lt;![endif]--&gt;","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"CSS中定位的使用","slug":"title2","date":"2016-09-23T09:27:56.000Z","updated":"2017-02-20T12:46:09.808Z","comments":true,"path":"2016/09/23/title2/","link":"","permalink":"http://yoursite.com/2016/09/23/title2/","excerpt":"","text":"1、相对定位定位：元素位置相对于某一个参考物进行的位置的偏移。 相对定位：元素相对于自身进行的位置偏移。position：定位属性。属性值：relative。相对的。 偏移的数据量。有其他属性来控制，方向属性，left、right、top、bottom。 position: relative; left: 100px; top: 110px; 便宜方向判断：如果属性值为正，偏移方向与属性方向相反。 left: 100px; 向右100 top: 110px; 向下110 right: 20px; 向左20 bottom: 20px; 向上20 等价于：属性值为负值，便宜方向与属性方向相同。 right: -100px; 向右100 bottom: -110px; 向下110 综合：水平方向和垂直方向可以任选一个属性，进行搭配。 .box{ left: 100px; //以元素自身左上角顶点为参考点，向右向下移动 top: 110px; } left: 100px; bottom: 110px; //以元素自身的左下顶点为参考点，向右上移动。 right: 50px; bottom: 110px; //以元素自身的右下顶点为参考点，向左上移动。 right: 50px; top: 110px; //以元素自身的右上顶点为参考点，向左下移动。 特点：显示的位置是偏移后的位置，原位置还保留，没有被其他元素给占有，形影分离。相对定位不会让元素脱离标准流，标准流的位置还是他自己的。用途不是很多，也有自己的特殊用途。 ①结构比较稳固，经常拿来做绝对定位的参考元素，子绝父相。②微调。 div span{ font-size: 12px; position: relative; bottom: 6px; } 2、绝对定位绝对定位的定位参考元素不固定的，但是不是本身。属性值：absolute。绝对的。也有四个方向的偏移量：left、right、top、bottom。 position: absolute; top: 100px; left: 150px; 特点：与相对定位比较，元素绝对定位之后，脱离标准流，标准流的位置让给了后面的元素。绝对定位的元素根据选取偏移方向不同，参考点也不同。 ①参考元素为body时的定位参考点 有top参与的绝对定位，定位的参考点是页面（body）的左上角和右上角 position: absolute; top: 200px; right: 300px; 有bottom参与的绝对定位：参考点是页面（body）首屏的左下角和右下角。 position: absolute; bottom: 200px; left: 300px; ②祖先元素作为参考元素 如果祖先元素中有定位的元素，元素绝对定位的参考元素就是距离它最近的有定位的祖先元素。 &lt;div class=&quot;box1&quot;&gt; //有相对定位 &lt;div class=&quot;box2&quot;&gt; //有相对定位 &lt;div class=&quot;box3&quot;&gt;//没有定位 &lt;p&gt;&lt;/p&gt; //绝对定位，参考元素是box2 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box1&quot;&gt; //有相对定位 &lt;div class=&quot;box2&quot;&gt; //有绝对定位 &lt;div class=&quot;box3&quot;&gt;//没有定位 &lt;p&gt;&lt;/p&gt; //绝对定位，参考元素是box2 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 绝对定位元素的参考盒子，可以是相对定位，也可以是绝对定位，还可以是固定定位。 子绝父相：子元素是绝对定位，参考的祖先元素是相对定位。 子绝父绝：子元素是绝对定位，参考的祖先元素是绝对地位。 子绝父固：子元素是绝对定位，参考的祖先元素是固定地位。 只要祖先元素中有任何一种定位，距离该子元素最近，它就是定位参考元素。子绝父相方法最常用：相对定位的元素不脱离标准流，结构稳定，对于当参考物来说比较方便。 ③祖先元素参考时的参考点 会忽视我们祖先元素的padding区域，以border内部的四个顶点作为相应方向的参考。相应方向：与使用的定位偏移方向是一致。 position: absolute; bottom: 50px; left: 50px; ④制作压盖效果 用绝对定位制作压盖效果。 .box{ position: relative; width: 400px; height: 400px; border: 1px solid #000; padding: 20px; margin: 100px auto; } .demo1{ width: 400px; height: 400px; background: skyblue; } .demo2{ width: 100px; height: 30px; background: gold; position: absolute; left: 160px; bottom: 40px; } ⑤绝对定位元素的居中 不能使用标准流的方法，只能先左边线居中，自身拽回宽度一半。 .demo2{ width: 100px; height: 30px; background: gold; position: absolute; left: 50%; 移动父亲宽度的50% bottom: 40px; margin-left: -50px;将元素本身拽回自身宽度的一般 } 补充：鼠标显示小手状态cursor: pointer; 3、固定定位固定定位，参考我们的浏览器窗口进行定位。属性值：fixed。始终保持针对浏览器窗口某一个顶点位置相对不变。也有四个方向的偏移量的值：left、right、top、bottom。 position: fixed; bottom: 80px; right: 80px; 4、压盖顺序z-index默认压盖顺序： ①有定位的元素压盖没有定位的元素。②有定位的元素，不区分定位类型，只要html结构写在后面的压盖写在前面。 自定义压盖顺序 属性：z-index，压盖顺序。属性值：数字，没有任何单位，数值越大，压盖数值小的。 ①只能给定位的元素加，其他的标准流的或者浮动元素都没有z-index属性。默认的定位元素的z-index值是1. position: relative; left: 0; bottom: 300px; z-index: 2; ②属性值越大的会压盖属性值越小的。 ③如果属性值相同，看html结构书写顺序，后面的压盖前面的。 ④父子盒模型里，如果父子都有定位，都有自定义的z-index值，两对父子对比时，不管子元素的属性值多大，只要父亲z-index值小，都只能被压盖。子级再大，如果父级数值小，都不管用。 &lt;div class=&quot;box1&quot; //父亲一z-index是5 &lt;div class=&quot;small&quot;&gt;1&lt;/div&gt;//30 &lt;/div&gt; &lt;div class=&quot;box2&quot;&gt;//父亲二z-index是4 &lt;div class=&quot;big&quot;&gt;2&lt;/div&gt;//100 &lt;/div&gt;","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"CSS-background背景","slug":"title1","date":"2016-09-19T09:27:56.000Z","updated":"2017-02-20T12:46:15.098Z","comments":true,"path":"2016/09/19/title1/","link":"","permalink":"http://yoursite.com/2016/09/19/title1/","excerpt":"","text":"1、background-color背景色渲染位置：border及以内。属性值：十六进制、rgb、rgba、颜色名。 background-color: blue; 2、background-image背景图实际渲染位置：跟背景色一样，能看到的其实就是border以内。属性值：url(图片路径)。 background-image: url(images/hai.jpg); 添加的背景图片会铺满整个盒子的背景区域。 url：uniform resource locator。统一资源定位符。实际就是背景图片的来源。url内部的值：图片的路径，可以是相对路径，也可以是绝对路径。 背景图和背景色的压盖顺序：image压盖color。 3、background-repeat背景重复设置背景图片以什么方式进行重复。属性值：repeat 默认值，整个背景区域重复no-repeat 不重复repeat-x 水平方向重复repeat-y 垂直方向重复 background-repeat: repeat; background-repeat: no-repeat; background-repeat: repeat-x; background-repeat: repeat-y;` body背景加载效果： repeat-x的一个妙用：制作一个渐变背景的导航栏。给盒子添加一个背景图：水平方向1像素宽，垂直方向就是正常高度，让背景图，水平重复铺开。 background-image: url(images/nav_bg.png); background-repeat: repeat-x; background-position背景图位置 作用：规定我们插入的背景图的在盒子里的位置。属性值：像素表示法、单词表示法、百分比表示法。 ①像素表示法属性值有两个，都用像素表示： background-position: 150px 100px; 第一个属性值：背景图片左上角距离盒子背景区域左上角（border以内）的水平偏移量。 第二个属性值：背景图片左上角距离盒子背景区域左上角（border以内）的垂直偏移量。 位置的属性值分正负。正方向：向右向下移动；负方向：向左向上移动。指的是图片针对（0,0）点移动的方向。 css精灵图技术：很多元素都有背景图，需要有实际存在图片，就需要发送多个http请求下载图片。将很多小的背景图合成在一张图片上，谁用背景图加载的都是一张图片。用法：给一个合适盒子大小，通过背景图定位找到图片的位置。 ②单词表示法 图片位置水平和垂直方向用代表方向的单词来表示 水平方向，第一个属性值：left ，center，right。背景在盒子内部居左、居中、居右。 垂直方向，第二个属性值：top，center，bottom。背景图在盒子内部居上、居中、居下。 background-position: center center; body大背景效果：水平居中、垂直居上。 background-position: center top; 制作通栏ｂａｎｎｅｒ。 ③百分比表示法 关注：百分比参考依据。 background-position: 100% 50%; background-attachment背景附着 指的是背景是否随着页面滚动而滚动。 属性值：scroll 滚动，背景图会随着页面滚动走。 fixed 固定，背景图不会随着页面滚动而滚走。 background-attachment: fixed; background复合属性background: #f00 fixed url(images/bg4.jpg) no-repeat center top; 五个属性之间位置可以更换，position的两个属性值位置不能电脑。 #二、背景实际应用# 1、padding挤出背景图效果方法：给盒子用padding-left留出一个空白区域，添加一个合适的背景图，不重复。 padding-top: 96px; background: url(images/in_12.png) no-repeat center top; 2、文字换图片提高搜索引擎优化：搜索时都是搜索文字。 h1标签内部放的是logo的图片。用一个技巧，logo图不用插入图，换成背景图，内部放置的是简单的关键字。 h1 a{ display: block; height: 96px; background: url(images/in_15.png); 添加背景图，用户看到 text-indent: -9999px; 隐藏文字 overflow: hidden; }","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"css中浮动的影响","slug":"title","date":"2016-09-11T09:27:56.000Z","updated":"2017-02-20T12:46:21.781Z","comments":true,"path":"2016/09/11/title/","link":"","permalink":"http://yoursite.com/2016/09/11/title/","excerpt":"1、浮动存在的问题浮动的元素不能撑高父级。元素脱离标准流之后， 不能再撑高它的父级盒子浮动会影响后面的浮动的元素。如果后面的浮动方向相同， 会去贴上一个浮动最后一个元素的边。 2、清楚浮动影响的方法 给父盒子加高度给父级元素增加高度， 它内部的浮动元素， 被限制了范围， 不会再影响后面的元素浮动。 效果： 解决父级高度的问题， 解决浮动影响后面的浮动的问题。 问题： 高度还是不能够自适应。 清除浮动属性 clear 元素都可以设置一个叫做 clear 的属性， 清除浮动的作用。 属性值： left、 right、 both。作用： clear 整体表示清除自身受到的其他元素带来的浮动的影响。left： 清除受到的左浮动影响。right： 清除受到的右浮动影响。both： 清除受到的左右两个方向的浮动影响。 box1{ clear: both;} ` 解决： 浮动的互相影响。` 问题： 父盒子还是不能被子盒子撑高。 margin 如果小于中间浮动的子元素的高度， 显示效果失效。隔墙法外墙法：在右浮动元素的父盒子之间隔一堵墙。 添加两个类， 一个是用来清除浮动， 一个用来模拟外边距。 cl{ clear: both; 清除浮动 } .h20{ height: 20px; 模拟间距 } 解决： 浮动互相影响。问题： 高度自适应， MARGIN 失效。","text":"1、浮动存在的问题浮动的元素不能撑高父级。元素脱离标准流之后， 不能再撑高它的父级盒子浮动会影响后面的浮动的元素。如果后面的浮动方向相同， 会去贴上一个浮动最后一个元素的边。 2、清楚浮动影响的方法 给父盒子加高度给父级元素增加高度， 它内部的浮动元素， 被限制了范围， 不会再影响后面的元素浮动。 效果： 解决父级高度的问题， 解决浮动影响后面的浮动的问题。 问题： 高度还是不能够自适应。 清除浮动属性 clear 元素都可以设置一个叫做 clear 的属性， 清除浮动的作用。 属性值： left、 right、 both。作用： clear 整体表示清除自身受到的其他元素带来的浮动的影响。left： 清除受到的左浮动影响。right： 清除受到的右浮动影响。both： 清除受到的左右两个方向的浮动影响。 box1{ clear: both;} ` 解决： 浮动的互相影响。` 问题： 父盒子还是不能被子盒子撑高。 margin 如果小于中间浮动的子元素的高度， 显示效果失效。隔墙法外墙法：在右浮动元素的父盒子之间隔一堵墙。 添加两个类， 一个是用来清除浮动， 一个用来模拟外边距。 cl{ clear: both; 清除浮动 } .h20{ height: 20px; 模拟间距 } 解决： 浮动互相影响。问题： 高度自适应， MARGIN 失效。 内墙法：将清除浮动的墙放在有浮动元素的父盒子内部的最后。 只要有浮动， 就在盒子内部加一堵墙。 解决： 浮动互相影响， 高度自适应， margin 失效。 缺点： ①html 结构布局， 很多需要进行浮动， 每个浮动的盒子内都需要隔一堵墙。 页面结构复杂会出现很多冗余的没有意义的标签。 ②一个盒子内的标签要浮动就都浮动， 浮动后面的墙是一个标准流里的元素overflow： hidden盒子内部的元素可以设置溢出模式， 隐藏， 自动显示。overflow： 溢出。 属性值： hidden 溢出隐藏， auto 溢出滚动（ 多出的内容出现滚动条）` { `overflow： hidden; overflow： auto;` } overflow 的其他小功能： 能够清除盒子内部元素的浮动影响 解决： 浮动互相影响， 高度自适应， margin 失效。 优势： 能够解决所有的问题， 不会增加无用的标签。 3、overflow： hidden； 的加载机制：高度自适应： 如果元素有溢出隐藏的属性， 网页加载时， 会强制的去元素内部搜索， 识别所有内部元素的高度， 会用最高的元素高度配给我们父盒子的自适应高度。 浮动影响： 加载时， 如果有溢出隐藏， 强制检索， 看盒子内部是否有浮动的元素， 如果有， 会被整体管理起来， 在自身的高度内， 不会影响其他的浮动元素。实际工作中： 就用 overflow 来清浮动","categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]}]}