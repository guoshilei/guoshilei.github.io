[{"title":"css中浮动的影响","date":"2014-10-11T09:27:56.000Z","path":"2014/10/11/title/","text":"1、浮动存在的问题浮动的元素不能撑高父级。元素脱离标准流之后， 不能再撑高它的父级盒子浮动会影响后面的浮动的元素。如果后面的浮动方向相同， 会去贴上一个浮动最后一个元素的边。 2、清楚浮动影响的方法给父盒子加高度给父级元素增加高度， 它内部的浮动元素， 被限制了范围， 不会再影响后面的元素浮动。效果： 解决父级高度的问题， 解决浮动影响后面的浮动的问题。 问题： 高度还是不能够自适应。清除浮动属性 clear元素都可以设置一个叫做 clear 的属性， 清除浮动的作用。属性值： left、 right、 both。作用： clear 整体表示清除自身受到的其他元素带来的浮动的影响。left： 清除受到的左浮动影响。right： 清除受到的右浮动影响。both： 清除受到的左右两个方向的浮动影响。 box1{ clear: both; } 解决： 浮动的互相影响。 问题： 父盒子还是不能被子盒子撑高。 margin 如果小于中间浮动的子元素的高度， 显示效果失效。隔墙法外墙法：在右浮动元素的父盒子之间隔一堵墙。 添加两个类， 一个是用来清除浮动， 一个用来模拟外边距。cl{ clear: both; 清除浮动 } .h20{ height: 20px; 模拟间距 } 解决： 浮动互相影响。 问题： 高度自适应， margin 失效。 内墙法：将清除浮动的墙放在有浮动元素的父盒子内部的最后。 只要有浮动， 就在盒子内部加一堵墙。 解决： 浮动互相影响， 高度自适应， margin 失效。缺点： ①html 结构布局， 很多需要进行浮动， 每个浮动的盒子内都需要隔一堵墙。 页面结构复杂会出现很多冗余的没有意义的标签。②一个盒子内的标签要浮动就都浮动， 浮动后面的墙是一个标准流里的元素overflow： hidden盒子内部的元素可以设置溢出模式， 隐藏， 自动显示。overflow： 溢出。属性值： hidden 溢出隐藏， auto 溢出滚动（ 多出的内容出现滚动条）{ overflow： hidden; overflow： auto;} overflow 的其他小功能： 能够清除盒子内部元素的浮动影响 解决： 浮动互相影响， 高度自适应， margin 失效。优势： 能够解决所有的问题， 不会增加无用的标签。 3、overflow： hidden； 的加载机制：高度自适应： 如果元素有溢出隐藏的属性， 网页加载时， 会强制的去元素内部搜索， 识别所有内部元素的高度， 会用最高的元素高度配给我们父盒子的自适应高度。浮动影响： 加载时， 如果有溢出隐藏， 强制检索， 看盒子内部是否有浮动的元素， 如果有， 会被整体管理起来， 在自身的高度内， 不会影响其他的浮动元素。实际工作中： 就用 overflow 来清浮动","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]}]